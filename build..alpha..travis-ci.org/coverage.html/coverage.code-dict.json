{"/home/travis/build/npmtest/node-npmtest-yarn/test.js":"/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/lib.npmtest_yarn.js":"/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_yarn = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_yarn = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-yarn && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_yarn\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_yarn.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_yarn.rollup.js'] =\n            local.assetsDict['/assets.npmtest_yarn.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_yarn.__dirname + '/lib.npmtest_yarn.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/bin/yarn.js":"#!/usr/bin/env node\n\n/* eslint-disable no-var */\n/* eslint-disable flowtype/require-valid-file-annotation */\n'use strict';\n\n// validate that used node version is supported\nvar semver = require('semver');\nvar ver = process.versions.node;\nver = ver.split('-')[0]; // explode and truncate tag from version #511\n\nvar path = null;\n\nif (semver.satisfies(ver, '>=5.0.0')) {\n  path = '../lib/cli/index.js';\n} else if (semver.satisfies(ver, '>=4.0.0')) {\n  path = '../lib-legacy/cli/index.js';\n} else {\n  console.log(require('chalk').red('Node version ' + ver + ' is not supported, please use Node.js 4.0 or higher.'));\n  process.exit(1);\n}\n\n// load v8-compile-cache\nif (semver.satisfies(ver, '>=5.7.0')) {\n  require('v8-compile-cache');\n}\n\n// ensure cache directory exists\nvar mkdirp = require('mkdirp');\nvar constants = require('../lib-legacy/constants');\nmkdirp.sync(constants.MODULE_CACHE_DIRECTORY);\n\n// init roadrunner\nvar YARN_VERSION = require('../package.json').version;\nvar roadrunner = require('roadrunner');\n\n// load cache\nroadrunner.load(constants.CACHE_FILENAME);\nvar cacheVersion = roadrunner.get('CACHE_BREAKER').version;\nif (!cacheVersion || cacheVersion !== YARN_VERSION) {\n  // reset cache if it's for an older yarn\n  roadrunner.reset(constants.CACHE_FILENAME);\n}\n// set this cache to the current yarn version\nroadrunner.set('CACHE_BREAKER', {version: YARN_VERSION});\n\n// save cache on SIGINT\nroadrunner.setup(constants.CACHE_FILENAME);\n\nmodule.exports = require(path);\n","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/constants.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathKey = getPathKey;\nexports.isRootUser = isRootUser;\nconst path = require('path');\nconst userHome = require('./util/user-home-dir').default;\n\nconst DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];\n\nconst YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';\n\nconst YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';\nconst YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';\nconst YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';\n\nconst SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version';\nconst SELF_UPDATE_TARBALL_URL = exports.SELF_UPDATE_TARBALL_URL = 'https://yarnpkg.com/latest.tar.gz';\nconst SELF_UPDATE_DOWNLOAD_FOLDER = exports.SELF_UPDATE_DOWNLOAD_FOLDER = 'updates';\n\n// cache version, bump whenever we make backwards incompatible changes\nconst CACHE_VERSION = exports.CACHE_VERSION = 1;\n\n// lockfile version, bump whenever we make backwards incompatible changes\nconst LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1;\n\n// max amount of network requests to perform concurrently\nconst NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8;\n\n// max amount of child processes to execute concurrently\nconst CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;\n\nconst REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];\n\nfunction getDirectory(category) {\n  // use %LOCALAPPDATA%/Yarn on Windows\n  if (process.platform === 'win32' && process.env.LOCALAPPDATA) {\n    return path.join(process.env.LOCALAPPDATA, 'Yarn', category);\n  }\n\n  // otherwise use ~/.{category}/yarn\n  return path.join(userHome, `.${category}`, 'yarn');\n}\n\nfunction getCacheDirectory() {\n  if (process.platform === 'darwin') {\n    return path.join(userHome, 'Library', 'Caches', 'Yarn');\n  }\n\n  return getDirectory('cache');\n}\n\nconst MODULE_CACHE_DIRECTORY = exports.MODULE_CACHE_DIRECTORY = getCacheDirectory();\nconst CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getDirectory('config');\nconst LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(CONFIG_DIRECTORY, 'link');\nconst GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(CONFIG_DIRECTORY, 'global');\nconst CACHE_FILENAME = exports.CACHE_FILENAME = path.join(MODULE_CACHE_DIRECTORY, '.roadrunner.json');\n\nconst INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';\nconst LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';\nconst METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';\nconst TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';\nconst CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';\n\nconst DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';\nconst SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;\nconst SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';\n\nconst ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);\n\nfunction getPathKey(platform, env) {\n  let pathKey = 'PATH';\n\n  // windows calls its path \"Path\" usually, but this is not guaranteed.\n  if (platform === 'win32') {\n    pathKey = 'Path';\n\n    for (const key in env) {\n      if (key.toLowerCase() === 'path') {\n        pathKey = key;\n      }\n    }\n  }\n\n  return pathKey;\n}\n\nfunction getUid() {\n  if (process.platform !== 'win32' && process.getuid) {\n    return process.getuid();\n  }\n  return null;\n}\n\nconst ROOT_USER = exports.ROOT_USER = isRootUser(getUid());\n\nfunction isRootUser(uid) {\n  return uid === 0;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/user-home-dir.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst path = require('path');\n\nvar _require = require('../constants');\n\nconst ROOT_USER = _require.ROOT_USER;\n\n\nconst userHomeDir = process.platform === 'linux' && ROOT_USER ? path.resolve('/usr/local/share') : require('os').homedir();\n\nexports.default = userHomeDir;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/index.js":"'use strict';\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../reporters/index.js');\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('../registries/index.js');\n}\n\nvar _index3;\n\nfunction _load_index3() {\n  return _index3 = _interopRequireWildcard(require('./commands/index.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _network;\n\nfunction _load_network() {\n  return _network = _interopRequireWildcard(require('../util/network.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _aliases;\n\nfunction _load_aliases() {\n  return _aliases = _interopRequireDefault(require('./aliases.js'));\n}\n\nvar _config;\n\nfunction _load_config() {\n  return _config = _interopRequireDefault(require('../config.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nconst chalk = require('chalk');\n\nconst commander = require('commander');\nconst fs = require('fs');\nconst invariant = require('invariant');\nconst lockfile = require('proper-lockfile');\nconst loudRejection = require('loud-rejection');\nconst net = require('net');\nconst onDeath = require('death');\nconst path = require('path');\nconst pkg = require('../../package.json');\n\nloudRejection();\n\n//\nconst startArgs = process.argv.slice(0, 2);\nlet args = process.argv.slice(2);\n\n// ignore all arguments after a --\nlet endArgs = [];\nfor (let i = 0; i < args.length; i++) {\n  const arg = args[i];\n  if (arg === '--') {\n    endArgs = args.slice(i + 1);\n    args = args.slice(0, i);\n  }\n}\n\n// NOTE: Pending resolution of https://github.com/tj/commander.js/issues/346\n// Remove this (and subsequent use in the logic below) after bug is resolved and issue is closed\nconst ARGS_THAT_SHARE_NAMES_WITH_OPTIONS = ['version'];\n\n// set global options\ncommander.version(pkg.version);\ncommander.usage('[command] [flags]');\ncommander.option('--verbose', 'output verbose messages on internal operations');\ncommander.option('--offline', 'trigger an error if any required dependencies are not available in local cache');\ncommander.option('--prefer-offline', 'use network only if dependencies are not available in local cache');\ncommander.option('--strict-semver');\ncommander.option('--json', '');\ncommander.option('--ignore-scripts', \"don't run lifecycle scripts\");\ncommander.option('--har', 'save HAR output of network traffic');\ncommander.option('--ignore-platform', 'ignore platform checks');\ncommander.option('--ignore-engines', 'ignore engines check');\ncommander.option('--ignore-optional', 'ignore optional dependencies');\ncommander.option('--force', 'install and build scripts even if they were built before, overwrite lockfile');\ncommander.option('--skip-integrity-check', 'run install without checking if node_modules is installed');\ncommander.option('--no-bin-links', \"don't generate bin links when setting up packages\");\ncommander.option('--flat', 'only allow one version of a package');\ncommander.option('--prod, --production [prod]', '');\ncommander.option('--no-lockfile', \"don't read or generate a lockfile\");\ncommander.option('--pure-lockfile', \"don't generate a lockfile\");\ncommander.option('--frozen-lockfile', \"don't generate a lockfile and fail if an update is needed\");\ncommander.option('--link-duplicates', 'create hardlinks to the repeated modules in node_modules');\ncommander.option('--global-folder <path>', '');\ncommander.option('--modules-folder <path>', 'rather than installing modules into the node_modules folder relative to the cwd, output them here');\ncommander.option('--cache-folder <path>', 'specify a custom folder to store the yarn cache');\ncommander.option('--mutex <type>[:specifier]', 'use a mutex to ensure only one yarn instance is executing');\ncommander.option('--no-emoji', 'disable emoji in output');\ncommander.option('--proxy <host>', '');\ncommander.option('--https-proxy <host>', '');\ncommander.option('--no-progress', 'disable progress bar');\ncommander.option('--network-concurrency <number>', 'maximum number of concurrent network requests', parseInt);\ncommander.option('--non-interactive', 'do not show interactive prompts');\n\n// get command name\nlet commandName = args.shift() || '';\nlet command;\n\n//\nconst getDocsLink = name => `${(_constants || _load_constants()).YARN_DOCS}${name || ''}`;\nconst getDocsInfo = name => 'Visit ' + chalk.bold(getDocsLink(name)) + ' for documentation about this command.';\n\n//\nif (commandName === '--help' || commandName === '-h') {\n  commandName = 'help';\n}\n\n// if no args or command name looks like a flag then default to `install`\nif (!commandName || commandName[0] === '-') {\n  if (commandName) {\n    args.unshift(commandName);\n  }\n  commandName = 'install';\n}\n\n// aliases: i -> install\nif (commandName && typeof (_aliases || _load_aliases()).default[commandName] === 'string') {\n  const alias = (_aliases || _load_aliases()).default[commandName];\n  command = {\n    run(config, reporter) {\n      throw new (_errors || _load_errors()).MessageError(`Did you mean \\`yarn ${alias}\\`?`);\n    }\n  };\n}\n\n//\nif (commandName === 'help' && args.length) {\n  commandName = (0, (_misc || _load_misc()).camelCase)(args.shift());\n  args.push('--help');\n}\n\n//\ninvariant(commandName, 'Missing command name');\nif (!command) {\n  const camelised = (0, (_misc || _load_misc()).camelCase)(commandName);\n  if (camelised) {\n    command = (_index3 || _load_index3())[camelised];\n  }\n}\n\n//\nif (command && typeof command.setFlags === 'function') {\n  command.setFlags(commander);\n}\n\nif (args.indexOf('--help') >= 0 || args.indexOf('-h') >= 0) {\n  const examples = command && command.examples || [];\n  if (examples.length) {\n    commander.on('--help', () => {\n      console.log('  Examples:\\n');\n      for (const example of examples) {\n        console.log(`    $ yarn ${example}`);\n      }\n      console.log();\n    });\n  }\n  commander.on('--help', () => console.log('  ' + getDocsInfo(commandName) + '\\n'));\n\n  commander.parse(startArgs.concat(args));\n  commander.help();\n  process.exit(1);\n}\n\n// parse flags\nargs.unshift(commandName);\n\nif (ARGS_THAT_SHARE_NAMES_WITH_OPTIONS.indexOf(commandName) >= 0 && args[0] === commandName) {\n  args.shift();\n}\n\ncommander.parse(startArgs.concat(args));\ncommander.args = commander.args.concat(endArgs);\n\nif (command) {\n  commander.args.shift();\n} else {\n  command = (_index3 || _load_index3()).run;\n}\ninvariant(command, 'missing command');\n\n//\nlet Reporter = (_index || _load_index()).ConsoleReporter;\nif (commander.json) {\n  Reporter = (_index || _load_index()).JSONReporter;\n}\nconst reporter = new Reporter({\n  emoji: commander.emoji && process.stdout.isTTY && process.platform === 'darwin',\n  verbose: commander.verbose,\n  noProgress: !commander.progress\n});\nreporter.initPeakMemoryCounter();\n\n//\nconst config = new (_config || _load_config()).default(reporter);\n\n// print header\nlet outputWrapper = true;\nif (typeof command.hasWrapper === 'function') {\n  outputWrapper = command.hasWrapper(commander, commander.args);\n}\nif (commander.json) {\n  outputWrapper = false;\n}\nif (outputWrapper && commandName !== 'help') {\n  reporter.header(commandName, pkg);\n}\n\nif (command.noArguments && commander.args.length) {\n  reporter.error(reporter.lang('noArguments'));\n  reporter.info(getDocsInfo(commandName));\n  process.exit(1);\n}\n\n//\nif (commander.yes) {\n  reporter.warn(reporter.lang('yesWarning'));\n}\n\n//\nif (!commander.offline && (_network || _load_network()).isOffline()) {\n  reporter.warn(reporter.lang('networkWarning'));\n}\n\n//\nif (command.requireLockfile && !fs.existsSync(path.join(config.cwd, (_constants || _load_constants()).LOCKFILE_FILENAME))) {\n  reporter.error(reporter.lang('noRequiredLockfile'));\n  process.exit(1);\n}\n\n//\nconst run = () => {\n  invariant(command, 'missing command');\n  return command.run(config, reporter, commander, commander.args).then(() => {\n    reporter.close();\n    if (outputWrapper) {\n      reporter.footer(false);\n    }\n  });\n};\n\n//\nconst runEventuallyWithFile = (mutexFilename, isFirstTime) => {\n  return new Promise(ok => {\n    const lockFilename = mutexFilename || path.join(config.cwd, (_constants || _load_constants()).SINGLE_INSTANCE_FILENAME);\n    lockfile.lock(lockFilename, { realpath: false }, (err, release) => {\n      if (err) {\n        if (isFirstTime) {\n          reporter.warn(reporter.lang('waitingInstance'));\n        }\n        setTimeout(() => {\n          ok(runEventuallyWithFile(mutexFilename, isFirstTime));\n        }, 200); // do not starve the CPU\n      } else {\n        onDeath(() => {\n          process.exit(1);\n        });\n        ok(run().then(release));\n      }\n    });\n  });\n};\n\n//\nconst runEventuallyWithNetwork = mutexPort => {\n  return new Promise(ok => {\n    const connectionOptions = {\n      port: +mutexPort || (_constants || _load_constants()).SINGLE_INSTANCE_PORT\n    };\n\n    const server = net.createServer();\n\n    server.on('error', () => {\n      // another Yarn instance exists, let's connect to it to know when it dies.\n      reporter.warn(reporter.lang('waitingInstance'));\n      const socket = net.createConnection(connectionOptions);\n\n      socket.on('connect', () => {\n        // Allow the program to exit if this is the only active server in the event system.\n        socket.unref();\n      }).on('close', hadError => {\n        // the `close` event gets always called after the `error` event\n        if (!hadError) {\n          process.nextTick(() => {\n            ok(runEventuallyWithNetwork(mutexPort));\n          });\n        }\n      }).on('error', () => {\n        // No server to listen to ? Let's retry to become the next server then.\n        process.nextTick(() => {\n          ok(runEventuallyWithNetwork(mutexPort));\n        });\n      });\n    });\n\n    const onServerEnd = () => {\n      server.close();\n      return Promise.resolve();\n    };\n\n    // open the server and continue only if succeed.\n    server.listen(connectionOptions, () => {\n      // ensure the server gets closed properly on SIGNALS.\n      onDeath(onServerEnd);\n\n      ok(run().then(onServerEnd));\n    });\n  });\n};\n\nfunction onUnexpectedError(err) {\n  function indent(str) {\n    return '\\n  ' + str.trim().split('\\n').join('\\n  ');\n  }\n\n  const log = [];\n  log.push(`Arguments: ${indent(process.argv.join(' '))}`);\n  log.push(`PATH: ${indent(process.env.PATH || 'undefined')}`);\n  log.push(`Yarn version: ${indent(pkg.version)}`);\n  log.push(`Node version: ${indent(process.versions.node)}`);\n  log.push(`Platform: ${indent(process.platform + ' ' + process.arch)}`);\n\n  // add manifests\n  for (const registryName of (_index2 || _load_index2()).registryNames) {\n    const possibleLoc = path.join(config.cwd, (_index2 || _load_index2()).registries[registryName].filename);\n    const manifest = fs.existsSync(possibleLoc) ? fs.readFileSync(possibleLoc, 'utf8') : 'No manifest';\n    log.push(`${registryName} manifest: ${indent(manifest)}`);\n  }\n\n  // lockfile\n  const lockLoc = path.join(config.cwd, (_constants || _load_constants()).LOCKFILE_FILENAME);\n  const lockfile = fs.existsSync(lockLoc) ? fs.readFileSync(lockLoc, 'utf8') : 'No lockfile';\n  log.push(`Lockfile: ${indent(lockfile)}`);\n\n  log.push(`Trace: ${indent(err.stack)}`);\n\n  const errorReportLoc = writeErrorReport(log);\n\n  reporter.error(reporter.lang('unexpectedError', err.message));\n\n  if (errorReportLoc) {\n    reporter.info(reporter.lang('bugReport', errorReportLoc));\n  }\n}\n\nfunction writeErrorReport(log) {\n  const errorReportLoc = path.join(config.cwd, 'yarn-error.log');\n\n  try {\n    fs.writeFileSync(errorReportLoc, log.join('\\n\\n') + '\\n');\n  } catch (err) {\n    reporter.error(reporter.lang('fileWriteError', errorReportLoc, err.message));\n    return undefined;\n  }\n\n  return errorReportLoc;\n}\n\n//\nconfig.init({\n  binLinks: commander.binLinks,\n  modulesFolder: commander.modulesFolder,\n  globalFolder: commander.globalFolder,\n  cacheRootFolder: commander.cacheFolder,\n  preferOffline: commander.preferOffline,\n  captureHar: commander.har,\n  ignorePlatform: commander.ignorePlatform,\n  ignoreEngines: commander.ignoreEngines,\n  ignoreScripts: commander.ignoreScripts,\n  offline: commander.preferOffline || commander.offline,\n  looseSemver: !commander.strictSemver,\n  production: commander.production,\n  httpProxy: commander.proxy,\n  httpsProxy: commander.httpsProxy,\n  networkConcurrency: commander.networkConcurrency,\n  nonInteractive: commander.nonInteractive,\n  commandName\n}).then(() => {\n\n  // option \"no-progress\" stored in yarn config\n  const noProgressConfig = config.registries.yarn.getOption('no-progress');\n\n  if (noProgressConfig) {\n    reporter.disableProgress();\n  }\n\n  const exit = () => {\n    process.exit(0);\n  };\n  // verbose logs outputs process.uptime() with this line we can sync uptime to absolute time on the computer\n  reporter.verbose(`current time: ${new Date().toISOString()}`);\n\n  const mutex = commander.mutex;\n  if (mutex && typeof mutex === 'string') {\n    const parts = mutex.split(':');\n    const mutexType = parts.shift();\n    const mutexSpecifier = parts.join(':');\n\n    if (mutexType === 'file') {\n      return runEventuallyWithFile(mutexSpecifier, true).then(exit);\n    } else if (mutexType === 'network') {\n      return runEventuallyWithNetwork(mutexSpecifier).then(exit);\n    } else {\n      throw new (_errors || _load_errors()).MessageError(`Unknown single instance type ${mutexType}`);\n    }\n  } else {\n    return run().then(exit);\n  }\n}).catch(err => {\n  reporter.verbose(err.stack);\n\n  if (err instanceof (_errors || _load_errors()).MessageError) {\n    reporter.error(err.message);\n  } else {\n    onUnexpectedError(err);\n  }\n\n  if (commandName) {\n    const actualCommandForHelp = (_index3 || _load_index3())[commandName] ? commandName : (_aliases || _load_aliases()).default[commandName];\n    if (command && actualCommandForHelp) {\n      reporter.info(getDocsInfo(actualCommandForHelp));\n    }\n  }\n\n  process.exit(1);\n});","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/aliases.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst shorthands = {\n  c: 'config',\n  i: 'install',\n  la: 'list',\n  ll: 'list',\n  ln: 'link',\n  ls: 'list',\n  r: 'remove',\n  rb: 'rebuild',\n  rm: 'remove',\n  t: 'test',\n  tst: 'test',\n  un: 'remove',\n  up: 'upgrade',\n  v: 'version'\n};\n\nconst affordances = {\n  'add-user': 'login',\n  adduser: 'login',\n  author: 'owner',\n  'dist-tag': 'tag',\n  'dist-tags': 'tag',\n  isntall: 'install',\n  'run-script': 'run',\n  runScript: 'run',\n  show: 'info',\n  uninstall: 'remove',\n  update: 'upgrade',\n  verison: 'version',\n  view: 'info'\n};\n\nexports.default = (0, (_extends2 || _load_extends()).default)({}, shorthands, affordances);","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/misc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortAlpha = sortAlpha;\nexports.entries = entries;\nexports.removePrefix = removePrefix;\nexports.removeSuffix = removeSuffix;\nexports.addSuffix = addSuffix;\nexports.hyphenate = hyphenate;\nexports.camelCase = camelCase;\nconst _camelCase = require('camelcase');\n\nfunction sortAlpha(a, b) {\n  // sort alphabetically in a deterministic way\n  const shortLen = Math.min(a.length, b.length);\n  for (let i = 0; i < shortLen; i++) {\n    const aChar = a.charCodeAt(i);\n    const bChar = b.charCodeAt(i);\n    if (aChar !== bChar) {\n      return aChar - bChar;\n    }\n  }\n  return a.length - b.length;\n}\n\nfunction entries(obj) {\n  const entries = [];\n  if (obj) {\n    for (const key in obj) {\n      entries.push([key, obj[key]]);\n    }\n  }\n  return entries;\n}\n\nfunction removePrefix(pattern, prefix) {\n  if (pattern.startsWith(prefix)) {\n    pattern = pattern.slice(prefix.length);\n  }\n\n  return pattern;\n}\n\nfunction removeSuffix(pattern, suffix) {\n  if (pattern.endsWith(suffix)) {\n    return pattern.slice(0, -suffix.length);\n  }\n\n  return pattern;\n}\n\nfunction addSuffix(pattern, suffix) {\n  if (!pattern.endsWith(suffix)) {\n    return pattern + suffix;\n  }\n\n  return pattern;\n}\n\nfunction hyphenate(str) {\n  return str.replace(/[A-Z]/g, match => {\n    return '-' + match.charAt(0).toLowerCase();\n  });\n}\n\nfunction camelCase(str) {\n  if (/[A-Z]/.test(str)) {\n    return null;\n  } else {\n    return _camelCase(str);\n  }\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prune = exports.dedupe = exports.lockfile = exports.upgradeInteractive = exports.why = exports.versions = exports.version = exports.upgrade = exports.unlink = exports.team = exports.tag = exports.run = exports.remove = exports.publish = exports.pack = exports.owner = exports.outdated = exports.list = exports.logout = exports.login = exports.link = exports.licenses = exports.install = exports.init = exports.info = exports.import = exports.help = exports.global = exports.generateLockEntry = exports.config = exports.clean = exports.check = exports.cache = exports.bin = exports.add = exports.access = undefined;\n\nvar _access;\n\nfunction _load_access() {\n  return _access = _interopRequireWildcard(require('./access.js'));\n}\n\nvar _add;\n\nfunction _load_add() {\n  return _add = _interopRequireWildcard(require('./add.js'));\n}\n\nvar _bin;\n\nfunction _load_bin() {\n  return _bin = _interopRequireWildcard(require('./bin.js'));\n}\n\nvar _cache;\n\nfunction _load_cache() {\n  return _cache = _interopRequireWildcard(require('./cache.js'));\n}\n\nvar _check;\n\nfunction _load_check() {\n  return _check = _interopRequireWildcard(require('./check.js'));\n}\n\nvar _clean;\n\nfunction _load_clean() {\n  return _clean = _interopRequireWildcard(require('./clean.js'));\n}\n\nvar _config;\n\nfunction _load_config() {\n  return _config = _interopRequireWildcard(require('./config.js'));\n}\n\nvar _generateLockEntry;\n\nfunction _load_generateLockEntry() {\n  return _generateLockEntry = _interopRequireWildcard(require('./generate-lock-entry.js'));\n}\n\nvar _global;\n\nfunction _load_global() {\n  return _global = _interopRequireWildcard(require('./global.js'));\n}\n\nvar _help;\n\nfunction _load_help() {\n  return _help = _interopRequireWildcard(require('./help.js'));\n}\n\nvar _import;\n\nfunction _load_import() {\n  return _import = _interopRequireWildcard(require('./import.js'));\n}\n\nvar _info;\n\nfunction _load_info() {\n  return _info = _interopRequireWildcard(require('./info.js'));\n}\n\nvar _init;\n\nfunction _load_init() {\n  return _init = _interopRequireWildcard(require('./init.js'));\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = _interopRequireWildcard(require('./install.js'));\n}\n\nvar _licenses;\n\nfunction _load_licenses() {\n  return _licenses = _interopRequireWildcard(require('./licenses.js'));\n}\n\nvar _link;\n\nfunction _load_link() {\n  return _link = _interopRequireWildcard(require('./link.js'));\n}\n\nvar _login;\n\nfunction _load_login() {\n  return _login = _interopRequireWildcard(require('./login.js'));\n}\n\nvar _logout;\n\nfunction _load_logout() {\n  return _logout = _interopRequireWildcard(require('./logout.js'));\n}\n\nvar _list;\n\nfunction _load_list() {\n  return _list = _interopRequireWildcard(require('./list.js'));\n}\n\nvar _outdated;\n\nfunction _load_outdated() {\n  return _outdated = _interopRequireWildcard(require('./outdated.js'));\n}\n\nvar _owner;\n\nfunction _load_owner() {\n  return _owner = _interopRequireWildcard(require('./owner.js'));\n}\n\nvar _pack;\n\nfunction _load_pack() {\n  return _pack = _interopRequireWildcard(require('./pack.js'));\n}\n\nvar _publish;\n\nfunction _load_publish() {\n  return _publish = _interopRequireWildcard(require('./publish.js'));\n}\n\nvar _remove;\n\nfunction _load_remove() {\n  return _remove = _interopRequireWildcard(require('./remove.js'));\n}\n\nvar _run;\n\nfunction _load_run() {\n  return _run = _interopRequireWildcard(require('./run.js'));\n}\n\nvar _tag;\n\nfunction _load_tag() {\n  return _tag = _interopRequireWildcard(require('./tag.js'));\n}\n\nvar _team;\n\nfunction _load_team() {\n  return _team = _interopRequireWildcard(require('./team.js'));\n}\n\nvar _unlink;\n\nfunction _load_unlink() {\n  return _unlink = _interopRequireWildcard(require('./unlink.js'));\n}\n\nvar _upgrade;\n\nfunction _load_upgrade() {\n  return _upgrade = _interopRequireWildcard(require('./upgrade.js'));\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('./version.js'));\n}\n\nvar _versions;\n\nfunction _load_versions() {\n  return _versions = _interopRequireWildcard(require('./versions.js'));\n}\n\nvar _why;\n\nfunction _load_why() {\n  return _why = _interopRequireWildcard(require('./why.js'));\n}\n\nvar _upgradeInteractive;\n\nfunction _load_upgradeInteractive() {\n  return _upgradeInteractive = _interopRequireWildcard(require('./upgrade-interactive.js'));\n}\n\nvar _useless;\n\nfunction _load_useless() {\n  return _useless = _interopRequireDefault(require('./_useless.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.access = _access || _load_access();\nexports.add = _add || _load_add();\nexports.bin = _bin || _load_bin();\nexports.cache = _cache || _load_cache();\nexports.check = _check || _load_check();\nexports.clean = _clean || _load_clean();\nexports.config = _config || _load_config();\nexports.generateLockEntry = _generateLockEntry || _load_generateLockEntry();\nexports.global = _global || _load_global();\nexports.help = _help || _load_help();\nexports.import = _import || _load_import();\nexports.info = _info || _load_info();\nexports.init = _init || _load_init();\nexports.install = _install || _load_install();\nexports.licenses = _licenses || _load_licenses();\nexports.link = _link || _load_link();\nexports.login = _login || _load_login();\nexports.logout = _logout || _load_logout();\nexports.list = _list || _load_list();\nexports.outdated = _outdated || _load_outdated();\nexports.owner = _owner || _load_owner();\nexports.pack = _pack || _load_pack();\nexports.publish = _publish || _load_publish();\nexports.remove = _remove || _load_remove();\nexports.run = _run || _load_run();\nexports.tag = _tag || _load_tag();\nexports.team = _team || _load_team();\nexports.unlink = _unlink || _load_unlink();\nexports.upgrade = _upgrade || _load_upgrade();\nexports.version = _version || _load_version();\nexports.versions = _versions || _load_versions();\nexports.why = _why || _load_why();\nexports.upgradeInteractive = _upgradeInteractive || _load_upgradeInteractive();\nconst lockfile = exports.lockfile = (0, (_useless || _load_useless()).default)(\"The lockfile command isn't necessary. `yarn install` will produce a lockfile.\");\n\nconst dedupe = exports.dedupe = (0, (_useless || _load_useless()).default)(\"The dedupe command isn't necessary. `yarn install` will already dedupe.\");\n\nconst prune = exports.prune = (0, (_useless || _load_useless()).default)(\"The prune command isn't necessary. `yarn install` will prune extraneous packages.\");","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/access.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = undefined;\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('access', {\n  public() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  restricted() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  grant() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  revoke() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  lsPackages() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  lsCollaborators() {\n    return Promise.reject(new Error('TODO'));\n  },\n\n  edit() {\n    return Promise.reject(new Error('TODO'));\n  }\n}, ['access public [<package>]', 'access restricted [<package>]', 'access grant <read-only|read-write> <scope:team> [<package>]', 'access revoke <scope:team> [<package>]', 'access ls-packages [<user>|<scope>|<scope:team>]', 'access ls-collaborators [<package> [<user>]]', 'access edit [<package>]']);\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/_build-sub-commands.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.default = function (rootCommandName, subCommands) {\n  let run = (() => {\n    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n      const subName = (0, (_misc || _load_misc()).camelCase)(args.shift() || '');\n      if (subName && subCommands[subName]) {\n        const command = subCommands[subName];\n        const res = yield command(config, reporter, flags, args);\n        if (res !== false) {\n          return Promise.resolve();\n        }\n      }\n\n      if (usage && usage.length) {\n        reporter.error(`${reporter.lang('usage')}:`);\n        for (const msg of usage) {\n          reporter.error(`yarn ${rootCommandName} ${msg}`);\n        }\n      }\n      return Promise.reject(new (_errors || _load_errors()).MessageError(reporter.lang('invalidCommand', subCommandNames.join(', '))));\n    });\n\n    return function run(_x2, _x3, _x4, _x5) {\n      return _ref.apply(this, arguments);\n    };\n  })();\n\n  let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  const subCommandNames = Object.keys(subCommands).map((_misc || _load_misc()).hyphenate);\n\n  function setFlags(commander) {\n    commander.usage(`${rootCommandName} [${subCommandNames.join('|')}] [flags]`);\n  }\n\n  const examples = usage.map(cmd => {\n    return `${rootCommandName} ${cmd}`;\n  });\n\n  return { run, setFlags, examples };\n};\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/add.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.Add = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (!args.length) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('missingAddDependencies'));\n    }\n\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd, reporter);\n\n    yield (0, (_install || _load_install()).wrapLifecycle)(config, flags, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const install = new Add(args, flags, config, reporter, lockfile);\n      yield install.init();\n    }));\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _list;\n\nfunction _load_list() {\n  return _list = require('./list.js');\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nclass Add extends (_install || _load_install()).Install {\n  constructor(args, flags, config, reporter, lockfile) {\n    super(flags, config, reporter, lockfile);\n    this.args = args;\n    // only one flag is supported, so we can figure out which one was passed to `yarn add`\n    this.flagToOrigin = [flags.dev && 'devDependencies', flags.optional && 'optionalDependencies', flags.peer && 'peerDependencies', 'dependencies'].filter(Boolean).shift();\n  }\n\n  /**\n   * TODO\n   */\n\n  prepareRequests(requests) {\n    const requestsWithArgs = requests.slice();\n\n    for (const pattern of this.args) {\n      requestsWithArgs.push({\n        pattern,\n        registry: 'npm',\n        optional: false\n      });\n    }\n    return requestsWithArgs;\n  }\n\n  /**\n   * returns version for a pattern based on Manifest\n   */\n  getPatternVersion(pattern, pkg) {\n    var _flags = this.flags;\n    const exact = _flags.exact,\n          tilde = _flags.tilde;\n\n    const parts = (_packageRequest || _load_packageRequest()).default.normalizePattern(pattern);\n    let version;\n    if ((_packageRequest || _load_packageRequest()).default.getExoticResolver(pattern)) {\n      // wasn't a name/range tuple so this is just a raw exotic pattern\n      version = pattern;\n    } else if (parts.hasVersion && parts.range) {\n      // if the user specified a range then use it verbatim\n      version = parts.range === 'latest' ? `^${pkg.version}` : parts.range;\n    } else if (tilde) {\n      // --save-tilde\n      version = `~${pkg.version}`;\n    } else if (exact) {\n      // --save-exact\n      version = pkg.version;\n    } else {\n      // default to save prefix\n      version = `${String(this.config.getOption('save-prefix') || '')}${pkg.version}`;\n    }\n    return version;\n  }\n\n  preparePatterns(patterns) {\n    const preparedPatterns = patterns.slice();\n    for (const pattern of this.resolver.dedupePatterns(this.args)) {\n      const pkg = this.resolver.getResolvedPattern(pattern);\n      invariant(pkg, `missing package ${pattern}`);\n      const version = this.getPatternVersion(pattern, pkg);\n      const newPattern = `${pkg.name}@${version}`;\n      preparedPatterns.push(newPattern);\n      this.addedPatterns.push(newPattern);\n      if (newPattern === pattern) {\n        continue;\n      }\n      this.resolver.replacePattern(pattern, newPattern);\n    }\n    return preparedPatterns;\n  }\n\n  bailout(patterns) {\n    return Promise.resolve(false);\n  }\n\n  /**\n   * Description\n   */\n\n  init() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this.addedPatterns = [];\n      const patterns = yield (_install || _load_install()).Install.prototype.init.call(_this);\n      yield _this.maybeOutputSaveTree(patterns);\n      yield _this.savePackages();\n      return patterns;\n    })();\n  }\n\n  /**\n   * Description\n   */\n\n  fetchRequestFromCwd() {\n    return (_install || _load_install()).Install.prototype.fetchRequestFromCwd.call(this, this.args);\n  }\n\n  /**\n   * Output a tree of any newly added dependencies.\n   */\n\n  maybeOutputSaveTree(patterns) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // don't limit the shown tree depth\n      const opts = {\n        reqDepth: 0\n      };\n\n      var _ref = yield (0, (_list || _load_list()).buildTree)(_this2.resolver, _this2.linker, patterns, opts, true, true);\n\n      const trees = _ref.trees,\n            count = _ref.count;\n\n      _this2.reporter.success(count === 1 ? _this2.reporter.lang('savedNewDependency') : _this2.reporter.lang('savedNewDependencies', count));\n      _this2.reporter.tree('newDependencies', trees);\n    })();\n  }\n\n  /**\n   * Save added packages to manifest if any of the --save flags were used.\n   */\n\n  savePackages() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // fill rootPatternsToOrigin without `excludePatterns`\n      yield (_install || _load_install()).Install.prototype.fetchRequestFromCwd.call(_this3);\n      const patternOrigins = Object.keys(_this3.rootPatternsToOrigin);\n\n      // get all the different registry manifests in this folder\n      const manifests = yield _this3.config.getRootManifests();\n\n      // add new patterns to their appropriate registry manifest\n      for (const pattern of _this3.addedPatterns) {\n        const pkg = _this3.resolver.getResolvedPattern(pattern);\n        invariant(pkg, `missing package ${pattern}`);\n        const version = _this3.getPatternVersion(pattern, pkg);\n        const ref = pkg._reference;\n        invariant(ref, 'expected package reference');\n        // lookup the package to determine dependency type; used during `yarn upgrade`\n        const depType = patternOrigins.reduce(function (acc, prev) {\n          if (prev.indexOf(`${pkg.name}@`) === 0) {\n            return _this3.rootPatternsToOrigin[prev];\n          }\n          return acc;\n        }, null);\n\n        // depType is calculated when `yarn upgrade` command is used\n        const target = depType || _this3.flagToOrigin;\n\n        // add it to manifest\n        const object = manifests[ref.registry].object;\n\n\n        object[target] = object[target] || {};\n        object[target][pkg.name] = version;\n      }\n\n      yield _this3.config.saveRootManifests(manifests);\n    })();\n  }\n}\n\nexports.Add = Add;\nfunction setFlags(commander) {\n  commander.usage('add [packages ...] [flags]');\n  commander.option('-D, --dev', 'save package to your `devDependencies`');\n  commander.option('-P, --peer', 'save package to your `peerDependencies`');\n  commander.option('-O, --optional', 'save package to your `optionalDependencies`');\n  commander.option('-E, --exact', 'install exact version');\n  commander.option('-T, --tilde', 'install most recent release with the same minor version');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/install.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapLifecycle = exports.run = exports.Install = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    let lockfile;\n    if (flags.lockfile === false) {\n      lockfile = new (_wrapper || _load_wrapper()).default();\n    } else {\n      lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd, reporter);\n    }\n\n    if (args.length) {\n      const exampleArgs = args.slice();\n      if (flags.saveDev) {\n        exampleArgs.push('--dev');\n      }\n      if (flags.savePeer) {\n        exampleArgs.push('--peer');\n      }\n      if (flags.saveOptional) {\n        exampleArgs.push('--optional');\n      }\n      if (flags.saveExact) {\n        exampleArgs.push('--exact');\n      }\n      if (flags.saveTilde) {\n        exampleArgs.push('--tilde');\n      }\n      let command = 'add';\n      if (flags.global) {\n        command = 'global add';\n      }\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('installCommandRenamed', `yarn ${command} ${exampleArgs.join(' ')}`));\n    }\n\n    yield wrapLifecycle(config, flags, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const install = new Install(flags, config, reporter, lockfile);\n      yield install.init();\n    }));\n  });\n\n  return function run(_x14, _x15, _x16, _x17) {\n    return _ref9.apply(this, arguments);\n  };\n})();\n\nlet wrapLifecycle = exports.wrapLifecycle = (() => {\n  var _ref11 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, flags, factory) {\n    yield config.executeLifecycleScript('preinstall');\n\n    yield factory();\n\n    // npm behaviour, seems kinda funky but yay compatibility\n    yield config.executeLifecycleScript('install');\n    yield config.executeLifecycleScript('postinstall');\n\n    if (!config.production) {\n      yield config.executeLifecycleScript('prepublish');\n    }\n  });\n\n  return function wrapLifecycle(_x18, _x19, _x20) {\n    return _ref11.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireDefault(require('../../util/normalize-manifest/index.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('../../registries/index.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('../../lockfile/stringify.js'));\n}\n\nvar _packageFetcher;\n\nfunction _load_packageFetcher() {\n  return _packageFetcher = _interopRequireDefault(require('../../package-fetcher.js'));\n}\n\nvar _packageInstallScripts;\n\nfunction _load_packageInstallScripts() {\n  return _packageInstallScripts = _interopRequireDefault(require('../../package-install-scripts.js'));\n}\n\nvar _packageCompatibility;\n\nfunction _load_packageCompatibility() {\n  return _packageCompatibility = _interopRequireDefault(require('../../package-compatibility.js'));\n}\n\nvar _packageResolver;\n\nfunction _load_packageResolver() {\n  return _packageResolver = _interopRequireDefault(require('../../package-resolver.js'));\n}\n\nvar _packageLinker;\n\nfunction _load_packageLinker() {\n  return _packageLinker = _interopRequireDefault(require('../../package-linker.js'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _clean;\n\nfunction _load_clean() {\n  return _clean = require('./clean.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../../constants.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('../../util/crypto.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../../util/map.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst semver = require('semver');\nconst emoji = require('node-emoji');\nconst isCI = require('is-ci');\nconst path = require('path');\n\nvar _require = require('../../../package.json');\n\nconst YARN_VERSION = _require.version,\n      YARN_INSTALL_METHOD = _require.installationMethod;\n\nconst ONE_DAY = 1000 * 60 * 60 * 24;\n\n/**\n * Try and detect the installation method for Yarn and provide a command to update it with.\n */\n\nfunction getUpdateCommand() {\n  if (YARN_INSTALL_METHOD === 'tar') {\n    return `curl -o- -L ${(_constants || _load_constants()).YARN_INSTALLER_SH} | bash`;\n  }\n\n  if (YARN_INSTALL_METHOD === 'homebrew') {\n    return 'brew upgrade yarn';\n  }\n\n  if (YARN_INSTALL_METHOD === 'deb') {\n    return 'sudo apt-get update && sudo apt-get install yarn';\n  }\n\n  if (YARN_INSTALL_METHOD === 'rpm') {\n    return 'sudo yum install yarn';\n  }\n\n  if (YARN_INSTALL_METHOD === 'npm') {\n    return 'npm upgrade --global yarn';\n  }\n\n  if (YARN_INSTALL_METHOD === 'chocolatey') {\n    return 'choco upgrade yarn';\n  }\n\n  if (YARN_INSTALL_METHOD === 'apk') {\n    return 'apk update && apk add -u yarn';\n  }\n\n  return null;\n}\n\nfunction getUpdateInstaller() {\n  // Windows\n  if (YARN_INSTALL_METHOD === 'msi') {\n    return (_constants || _load_constants()).YARN_INSTALLER_MSI;\n  }\n\n  return null;\n}\n\nfunction normalizeFlags(config, rawFlags) {\n  const flags = {\n    // install\n    har: !!rawFlags.har,\n    ignorePlatform: !!rawFlags.ignorePlatform,\n    ignoreEngines: !!rawFlags.ignoreEngines,\n    ignoreScripts: !!rawFlags.ignoreScripts,\n    ignoreOptional: !!rawFlags.ignoreOptional,\n    force: !!rawFlags.force,\n    flat: !!rawFlags.flat,\n    lockfile: rawFlags.lockfile !== false,\n    pureLockfile: !!rawFlags.pureLockfile,\n    skipIntegrityCheck: !!rawFlags.skipIntegrityCheck,\n    frozenLockfile: !!rawFlags.frozenLockfile,\n    linkDuplicates: !!rawFlags.linkDuplicates,\n\n    // add\n    peer: !!rawFlags.peer,\n    dev: !!rawFlags.dev,\n    optional: !!rawFlags.optional,\n    exact: !!rawFlags.exact,\n    tilde: !!rawFlags.tilde\n  };\n\n  if (config.getOption('ignore-scripts')) {\n    flags.ignoreScripts = true;\n  }\n\n  if (config.getOption('ignore-platform')) {\n    flags.ignorePlatform = true;\n  }\n\n  if (config.getOption('ignore-engines')) {\n    flags.ignoreEngines = true;\n  }\n\n  if (config.getOption('ignore-optional')) {\n    flags.ignoreOptional = true;\n  }\n\n  if (config.getOption('force')) {\n    flags.force = true;\n  }\n\n  return flags;\n}\n\nclass Install {\n  constructor(flags, config, reporter, lockfile) {\n    this.rootManifestRegistries = [];\n    this.rootPatternsToOrigin = (0, (_map || _load_map()).default)();\n    this.resolutions = (0, (_map || _load_map()).default)();\n    this.lockfile = lockfile;\n    this.reporter = reporter;\n    this.config = config;\n    this.flags = normalizeFlags(config, flags);\n\n    this.resolver = new (_packageResolver || _load_packageResolver()).default(config, lockfile);\n    this.fetcher = new (_packageFetcher || _load_packageFetcher()).default(config, this.resolver);\n    this.compatibility = new (_packageCompatibility || _load_packageCompatibility()).default(config, this.resolver, this.flags.ignoreEngines);\n    this.linker = new (_packageLinker || _load_packageLinker()).default(config, this.resolver);\n    this.scripts = new (_packageInstallScripts || _load_packageInstallScripts()).default(config, this.resolver, this.flags.force);\n  }\n\n  /**\n   * Create a list of dependency requests from the current directories manifests.\n   */\n\n  fetchRequestFromCwd() {\n    var _this = this;\n\n    let excludePatterns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const patterns = [];\n      const deps = [];\n      const manifest = {};\n\n      const ignorePatterns = [];\n      const usedPatterns = [];\n\n      // exclude package names that are in install args\n      const excludeNames = [];\n      for (const pattern of excludePatterns) {\n        // can't extract a package name from this\n        if ((_packageRequest || _load_packageRequest()).default.getExoticResolver(pattern)) {\n          continue;\n        }\n\n        // extract the name\n        const parts = (_packageRequest || _load_packageRequest()).default.normalizePattern(pattern);\n        excludeNames.push(parts.name);\n      }\n\n      for (const registry of Object.keys((_index2 || _load_index2()).registries)) {\n        const filename = (_index2 || _load_index2()).registries[registry].filename;\n\n        const loc = path.join(_this.config.cwd, filename);\n        if (!(yield (_fs || _load_fs()).exists(loc))) {\n          continue;\n        }\n\n        _this.rootManifestRegistries.push(registry);\n        const json = yield _this.config.readJson(loc);\n        yield (0, (_index || _load_index()).default)(json, _this.config.cwd, _this.config, true);\n\n        Object.assign(_this.resolutions, json.resolutions);\n        Object.assign(manifest, json);\n\n        const pushDeps = function (depType, _ref, isUsed) {\n          let hint = _ref.hint,\n              optional = _ref.optional;\n\n          const depMap = json[depType];\n          for (const name in depMap) {\n            if (excludeNames.indexOf(name) >= 0) {\n              continue;\n            }\n\n            let pattern = name;\n            if (!_this.lockfile.getLocked(pattern, true)) {\n              // when we use --save we save the dependency to the lockfile with just the name rather than the\n              // version combo\n              pattern += '@' + depMap[name];\n            }\n\n            if (isUsed) {\n              usedPatterns.push(pattern);\n            } else {\n              ignorePatterns.push(pattern);\n            }\n\n            _this.rootPatternsToOrigin[pattern] = depType;\n            patterns.push(pattern);\n            deps.push({ pattern, registry, hint, optional });\n          }\n        };\n\n        pushDeps('dependencies', { hint: null, optional: false }, true);\n        pushDeps('devDependencies', { hint: 'dev', optional: false }, !_this.config.production);\n        pushDeps('optionalDependencies', { hint: 'optional', optional: true }, !_this.flags.ignoreOptional);\n\n        break;\n      }\n\n      // inherit root flat flag\n      if (manifest.flat) {\n        _this.flags.flat = true;\n      }\n\n      return {\n        requests: deps,\n        patterns,\n        manifest,\n        usedPatterns,\n        ignorePatterns\n      };\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  prepareRequests(requests) {\n    return requests;\n  }\n\n  preparePatterns(patterns) {\n    return patterns;\n  }\n\n  bailout(patterns) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (_this2.flags.frozenLockfile && !_this2.lockFileInSync(patterns)) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('frozenLockfileError'));\n      }\n      if (_this2.flags.skipIntegrityCheck || _this2.flags.force) {\n        return false;\n      }\n\n      const match = yield _this2.matchesIntegrityHash(patterns);\n      const haveLockfile = yield (_fs || _load_fs()).exists(path.join(_this2.config.cwd, (_constants || _load_constants()).LOCKFILE_FILENAME));\n\n      if (match.matches && haveLockfile) {\n        _this2.reporter.success(_this2.reporter.lang('upToDate'));\n        return true;\n      }\n\n      if (!patterns.length && !match.expected) {\n        _this2.reporter.success(_this2.reporter.lang('nothingToInstall'));\n        yield _this2.createEmptyManifestFolders();\n        yield _this2.saveLockfileAndIntegrity(patterns);\n        return true;\n      }\n\n      return false;\n    })();\n  }\n\n  /**\n   * Produce empty folders for all used root manifests.\n   */\n\n  createEmptyManifestFolders() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (_this3.config.modulesFolder) {\n        // already created\n        return;\n      }\n\n      for (const registryName of _this3.rootManifestRegistries) {\n        const folder = _this3.config.registries[registryName].folder;\n\n        yield (_fs || _load_fs()).mkdirp(path.join(_this3.config.cwd, folder));\n      }\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  markIgnored(patterns) {\n    for (const pattern of patterns) {\n      const manifest = this.resolver.getStrictResolvedPattern(pattern);\n      const ref = manifest._reference;\n      invariant(ref, 'expected package reference');\n\n      if (ref.requests.length === 1) {\n        // this module was only depended on once by the root so we can safely ignore it\n        // if it was requested more than once then ignoring it would break a transitive\n        // dep that resolved to it\n        ref.ignore = true;\n      }\n    }\n  }\n\n  /**\n   * TODO description\n   */\n\n  init() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this4.checkUpdate();\n\n      // warn if we have a shrinkwrap\n      if (yield (_fs || _load_fs()).exists(path.join(_this4.config.cwd, 'npm-shrinkwrap.json'))) {\n        _this4.reporter.warn(_this4.reporter.lang('shrinkwrapWarning'));\n      }\n\n      let patterns = [];\n      const steps = [];\n\n      var _ref2 = yield _this4.fetchRequestFromCwd();\n\n      const depRequests = _ref2.requests,\n            rawPatterns = _ref2.patterns,\n            ignorePatterns = _ref2.ignorePatterns,\n            usedPatterns = _ref2.usedPatterns;\n\n\n      steps.push((() => {\n        var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n          _this4.reporter.step(curr, total, _this4.reporter.lang('resolvingPackages'), emoji.get('mag'));\n          yield _this4.resolver.init(_this4.prepareRequests(depRequests), _this4.flags.flat);\n          patterns = yield _this4.flatten(_this4.preparePatterns(rawPatterns));\n          return { bailout: yield _this4.bailout(usedPatterns) };\n        });\n\n        return function (_x2, _x3) {\n          return _ref3.apply(this, arguments);\n        };\n      })());\n\n      steps.push((() => {\n        var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n          _this4.markIgnored(ignorePatterns);\n          _this4.reporter.step(curr, total, _this4.reporter.lang('fetchingPackages'), emoji.get('truck'));\n          yield _this4.fetcher.init();\n          yield _this4.compatibility.init();\n        });\n\n        return function (_x4, _x5) {\n          return _ref4.apply(this, arguments);\n        };\n      })());\n\n      steps.push((() => {\n        var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n          // remove integrity hash to make this operation atomic\n          const loc = yield _this4.getIntegrityHashLocation();\n          yield (_fs || _load_fs()).unlink(loc);\n          _this4.reporter.step(curr, total, _this4.reporter.lang('linkingDependencies'), emoji.get('link'));\n          yield _this4.linker.init(patterns, _this4.flags.linkDuplicates);\n        });\n\n        return function (_x6, _x7) {\n          return _ref5.apply(this, arguments);\n        };\n      })());\n\n      steps.push((() => {\n        var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n          _this4.reporter.step(curr, total, _this4.flags.force ? _this4.reporter.lang('rebuildingPackages') : _this4.reporter.lang('buildingFreshPackages'), emoji.get('page_with_curl'));\n\n          if (_this4.flags.ignoreScripts) {\n            _this4.reporter.warn(_this4.reporter.lang('ignoredScripts'));\n          } else {\n            yield _this4.scripts.init(patterns);\n          }\n        });\n\n        return function (_x8, _x9) {\n          return _ref6.apply(this, arguments);\n        };\n      })());\n\n      if (_this4.flags.har) {\n        steps.push((() => {\n          var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n            const formattedDate = new Date().toISOString().replace(/:/g, '-');\n            const filename = `yarn-install_${formattedDate}.har`;\n            _this4.reporter.step(curr, total, _this4.reporter.lang('savingHar', filename), emoji.get('black_circle_for_record'));\n            yield _this4.config.requestManager.saveHar(filename);\n          });\n\n          return function (_x10, _x11) {\n            return _ref7.apply(this, arguments);\n          };\n        })());\n      }\n\n      if (yield _this4.shouldClean()) {\n        steps.push((() => {\n          var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (curr, total) {\n            _this4.reporter.step(curr, total, _this4.reporter.lang('cleaningModules'), emoji.get('recycle'));\n            yield (0, (_clean || _load_clean()).clean)(_this4.config, _this4.reporter);\n          });\n\n          return function (_x12, _x13) {\n            return _ref8.apply(this, arguments);\n          };\n        })());\n      }\n\n      let currentStep = 0;\n      for (const step of steps) {\n        const stepResult = yield step(++currentStep, steps.length);\n        if (stepResult && stepResult.bailout) {\n          return patterns;\n        }\n      }\n\n      // fin!\n      yield _this4.saveLockfileAndIntegrity(patterns);\n      _this4.maybeOutputUpdate();\n      _this4.config.requestManager.clearCache();\n      return patterns;\n    })();\n  }\n\n  /**\n   * Check if we should run the cleaning step.\n   */\n\n  shouldClean() {\n    return (_fs || _load_fs()).exists(path.join(this.config.cwd, (_constants || _load_constants()).CLEAN_FILENAME));\n  }\n\n  /**\n   * TODO\n   */\n\n  flatten(patterns) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (!_this5.flags.flat) {\n        return patterns;\n      }\n\n      const flattenedPatterns = [];\n\n      for (const name of _this5.resolver.getAllDependencyNamesByLevelOrder(patterns)) {\n        const infos = _this5.resolver.getAllInfoForPackageName(name).filter(function (manifest) {\n          const ref = manifest._reference;\n          invariant(ref, 'expected package reference');\n          return !ref.ignore;\n        });\n\n        if (infos.length === 0) {\n          continue;\n        }\n\n        if (infos.length === 1) {\n          // single version of this package\n          // take out a single pattern as multiple patterns may have resolved to this package\n          flattenedPatterns.push(_this5.resolver.patternsByPackage[name][0]);\n          continue;\n        }\n\n        const options = infos.map(function (info) {\n          const ref = info._reference;\n          invariant(ref, 'expected reference');\n          return {\n            // TODO `and is required by {PARENT}`,\n            name: _this5.reporter.lang('manualVersionResolutionOption', ref.patterns.join(', '), info.version),\n\n            value: info.version\n          };\n        });\n        const versions = infos.map(function (info) {\n          return info.version;\n        });\n        let version;\n\n        const resolutionVersion = _this5.resolutions[name];\n        if (resolutionVersion && versions.indexOf(resolutionVersion) >= 0) {\n          // use json `resolution` version\n          version = resolutionVersion;\n        } else {\n          version = yield _this5.reporter.select(_this5.reporter.lang('manualVersionResolution', name), _this5.reporter.lang('answer'), options);\n          _this5.resolutions[name] = version;\n        }\n\n        flattenedPatterns.push(_this5.resolver.collapseAllVersionsOfPackage(name, version));\n      }\n\n      // save resolutions to their appropriate root manifest\n      if (Object.keys(_this5.resolutions).length) {\n        const manifests = yield _this5.config.getRootManifests();\n\n        for (const name in _this5.resolutions) {\n          const version = _this5.resolutions[name];\n\n          const patterns = _this5.resolver.patternsByPackage[name];\n          if (!patterns) {\n            continue;\n          }\n\n          let manifest;\n          for (const pattern of patterns) {\n            manifest = _this5.resolver.getResolvedPattern(pattern);\n            if (manifest) {\n              break;\n            }\n          }\n          invariant(manifest, 'expected manifest');\n\n          const ref = manifest._reference;\n          invariant(ref, 'expected reference');\n\n          const object = manifests[ref.registry].object;\n          object.resolutions = object.resolutions || {};\n          object.resolutions[name] = version;\n        }\n\n        yield _this5.config.saveRootManifests(manifests);\n      }\n\n      return flattenedPatterns;\n    })();\n  }\n\n  /**\n   * Check if the loaded lockfile has all the included patterns\n   */\n\n  lockFileInSync(patterns) {\n    let inSync = true;\n    for (const pattern of patterns) {\n      if (!this.lockfile.getLocked(pattern)) {\n        inSync = false;\n        break;\n      }\n    }\n    return inSync;\n  }\n\n  /**\n   * Save updated integrity and lockfiles.\n   */\n\n  saveLockfileAndIntegrity(patterns) {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // stringify current lockfile\n      const lockSource = (0, (_stringify || _load_stringify()).default)(_this6.lockfile.getLockfile(_this6.resolver.patterns));\n\n      // write integrity hash\n      yield _this6.writeIntegrityHash(lockSource, patterns);\n\n      // --no-lockfile or --pure-lockfile flag\n      if (_this6.flags.lockfile === false || _this6.flags.pureLockfile) {\n        return;\n      }\n\n      const inSync = _this6.lockFileInSync(patterns);\n\n      // remove is followed by install with force on which we rewrite lockfile\n      if (inSync && patterns.length && !_this6.flags.force) {\n        return;\n      }\n\n      // build lockfile location\n      const loc = path.join(_this6.config.cwd, (_constants || _load_constants()).LOCKFILE_FILENAME);\n\n      // write lockfile\n      yield (_fs || _load_fs()).writeFilePreservingEol(loc, lockSource);\n\n      _this6._logSuccessSaveLockfile();\n    })();\n  }\n\n  _logSuccessSaveLockfile() {\n    this.reporter.success(this.reporter.lang('savedLockfile'));\n  }\n\n  /**\n   * Check if the integrity hash of this installation matches one on disk.\n   */\n\n  matchesIntegrityHash(patterns) {\n    var _this7 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const loc = yield _this7.getIntegrityHashLocation();\n      if (!(yield (_fs || _load_fs()).exists(loc))) {\n        return {\n          actual: '',\n          expected: '',\n          loc,\n          matches: false\n        };\n      }\n\n      const lockSource = (0, (_stringify || _load_stringify()).default)(_this7.lockfile.getLockfile(_this7.resolver.patterns));\n      const actual = _this7.generateIntegrityHash(lockSource, patterns);\n      const expected = (yield (_fs || _load_fs()).readFile(loc)).trim();\n\n      return {\n        actual,\n        expected,\n        loc,\n        matches: actual === expected\n      };\n    })();\n  }\n\n  /**\n   * Get the location of an existing integrity hash. If none exists then return the location where we should\n   * write a new one.\n   */\n\n  getIntegrityHashLocation() {\n    var _this8 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // build up possible folders\n      const possibleFolders = [];\n      if (_this8.config.modulesFolder) {\n        possibleFolders.push(_this8.config.modulesFolder);\n      }\n\n      // get a list of registry names to check existence in\n      let checkRegistryNames = _this8.resolver.usedRegistries;\n      if (!checkRegistryNames.length) {\n        // we haven't used any registries yet\n        checkRegistryNames = (_index2 || _load_index2()).registryNames;\n      }\n\n      // ensure we only write to a registry folder that was used\n      for (const name of checkRegistryNames) {\n        const loc = path.join(_this8.config.cwd, _this8.config.registries[name].folder);\n        possibleFolders.push(loc);\n      }\n\n      // if we already have an integrity hash in one of these folders then use it's location otherwise use the\n      // first folder\n      const possibles = possibleFolders.map(function (folder) {\n        return path.join(folder, (_constants || _load_constants()).INTEGRITY_FILENAME);\n      });\n      let loc = possibles[0];\n      for (const possibleLoc of possibles) {\n        if (yield (_fs || _load_fs()).exists(possibleLoc)) {\n          loc = possibleLoc;\n          break;\n        }\n      }\n      return loc;\n    })();\n  }\n  /**\n   * Write the integrity hash of the current install to disk.\n   */\n\n  writeIntegrityHash(lockSource, patterns) {\n    var _this9 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const loc = yield _this9.getIntegrityHashLocation();\n      invariant(loc, 'expected integrity hash location');\n      yield (_fs || _load_fs()).mkdirp(path.dirname(loc));\n      yield (_fs || _load_fs()).writeFile(loc, _this9.generateIntegrityHash(lockSource, patterns));\n    })();\n  }\n\n  /**\n   * Generate integrity hash of input lockfile.\n   */\n\n  generateIntegrityHash(lockfile, patterns) {\n    const opts = [lockfile];\n\n    opts.push(`patterns:${patterns.sort((_misc || _load_misc()).sortAlpha).join(',')}`);\n\n    if (this.flags.flat) {\n      opts.push('flat');\n    }\n\n    if (this.config.production) {\n      opts.push('production');\n    }\n\n    const linkedModules = this.config.linkedModules;\n    if (linkedModules.length) {\n      opts.push(`linked:${linkedModules.join(',')}`);\n    }\n\n    const mirror = this.config.getOfflineMirrorPath();\n    if (mirror != null) {\n      opts.push(`mirror:${mirror}`);\n    }\n\n    return (_crypto || _load_crypto()).hash(opts.join('-'), 'sha256');\n  }\n\n  /**\n   * Load the dependency graph of the current install. Only does package resolving and wont write to the cwd.\n   */\n\n  hydrate(fetch) {\n    var _this10 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const request = yield _this10.fetchRequestFromCwd();\n      const depRequests = request.requests,\n            rawPatterns = request.patterns,\n            ignorePatterns = request.ignorePatterns;\n\n\n      yield _this10.resolver.init(depRequests, _this10.flags.flat);\n      yield _this10.flatten(rawPatterns);\n      _this10.markIgnored(ignorePatterns);\n\n      if (fetch) {\n        // fetch packages, should hit cache most of the time\n        yield _this10.fetcher.init();\n        yield _this10.compatibility.init();\n\n        // expand minimal manifests\n        for (const manifest of _this10.resolver.getManifests()) {\n          const ref = manifest._reference;\n          invariant(ref, 'expected reference');\n\n          const loc = _this10.config.generateHardModulePath(ref);\n          const newPkg = yield _this10.config.readManifest(loc);\n          yield _this10.resolver.updateManifest(ref, newPkg);\n        }\n      }\n\n      return request;\n    })();\n  }\n\n  /**\n   * Check for updates every day and output a nag message if there's a newer version.\n   */\n\n  checkUpdate() {\n    if (!process.stdout.isTTY || isCI) {\n      // don't show upgrade dialog on CI or non-TTY terminals\n      return;\n    }\n\n    // only check for updates once a day\n    const lastUpdateCheck = Number(this.config.getOption('lastUpdateCheck')) || 0;\n    if (lastUpdateCheck && Date.now() - lastUpdateCheck < ONE_DAY) {\n      return;\n    }\n\n    // don't bug for updates on tagged releases\n    if (YARN_VERSION.indexOf('-') >= 0) {\n      return;\n    }\n\n    this._checkUpdate().catch(() => {\n      // swallow errors\n    });\n  }\n\n  _checkUpdate() {\n    var _this11 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let latestVersion = yield _this11.config.requestManager.request({\n        url: (_constants || _load_constants()).SELF_UPDATE_VERSION_URL\n      });\n      invariant(typeof latestVersion === 'string', 'expected string');\n      latestVersion = latestVersion.trim();\n      if (!semver.valid(latestVersion)) {\n        return;\n      }\n\n      // ensure we only check for updates periodically\n      _this11.config.registries.yarn.saveHomeConfig({\n        lastUpdateCheck: Date.now()\n      });\n\n      if (semver.gt(latestVersion, YARN_VERSION)) {\n        _this11.maybeOutputUpdate = function () {\n          _this11.reporter.warn(_this11.reporter.lang('yarnOutdated', latestVersion, YARN_VERSION));\n\n          const command = getUpdateCommand();\n          if (command) {\n            _this11.reporter.info(_this11.reporter.lang('yarnOutdatedCommand'));\n            _this11.reporter.command(command);\n          } else {\n            const installer = getUpdateInstaller();\n            if (installer) {\n              _this11.reporter.info(_this11.reporter.lang('yarnOutdatedInstaller', installer));\n            }\n          }\n        };\n      }\n    })();\n  }\n\n  /**\n   * Method to override with a possible upgrade message.\n   */\n\n  maybeOutputUpdate() {}\n}\n\nexports.Install = Install;\nfunction setFlags(commander) {\n  commander.usage('install [flags]');\n  commander.option('-g, --global', 'DEPRECATED');\n  commander.option('-S, --save', 'DEPRECATED - save package to your `dependencies`');\n  commander.option('-D, --save-dev', 'DEPRECATED - save package to your `devDependencies`');\n  commander.option('-P, --save-peer', 'DEPRECATED - save package to your `peerDependencies`');\n  commander.option('-O, --save-optional', 'DEPRECATED - save package to your `optionalDependencies`');\n  commander.option('-E, --save-exact', 'DEPRECATED');\n  commander.option('-T, --save-tilde', 'DEPRECATED');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/bin.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasWrapper = hasWrapper;\nexports.run = run;\n\nvar _yarnResolver;\n\nfunction _load_yarnResolver() {\n  return _yarnResolver = _interopRequireDefault(require('../../resolvers/registries/yarn-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nfunction hasWrapper() {}\n\nfunction run(config, reporter, flags, args) {\n  const binFolder = path.join(config.cwd, config.registries[(_yarnResolver || _load_yarnResolver()).default.registry].folder, '.bin');\n  console.log(binFolder);\n  return Promise.resolve();\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/cache.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.hasWrapper = hasWrapper;\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nfunction hasWrapper(flags, args) {\n  return args[0] !== 'dir';\n}\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('cache', {\n  ls(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let readCacheMetadata = (() => {\n        var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n          let parentDir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.cacheFolder;\n          let metadataFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_constants || _load_constants()).METADATA_FILENAME;\n\n          const folders = yield (_fs || _load_fs()).readdir(parentDir);\n          const packagesMetadata = [];\n\n          for (const folder of folders) {\n            if (folder[0] === '.') {\n              continue;\n            }\n\n            const loc = path.join(config.cacheFolder, parentDir.replace(config.cacheFolder, ''), folder);\n            // Check if this is a scoped package\n            if (!(yield (_fs || _load_fs()).exists(path.join(loc, metadataFile)))) {\n              // If so, recurrently read scoped packages metadata\n              packagesMetadata.push(...(yield readCacheMetadata(loc)));\n            } else {\n              var _ref2 = yield config.readPackageMetadata(loc);\n\n              const registry = _ref2.registry,\n                    manifest = _ref2.package,\n                    remote = _ref2.remote;\n\n              packagesMetadata.push([manifest.name, manifest.version, registry, remote && remote.resolved || '']);\n            }\n          }\n\n          return packagesMetadata;\n        });\n\n        return function readCacheMetadata() {\n          return _ref.apply(this, arguments);\n        };\n      })();\n\n      const body = yield readCacheMetadata();\n\n      reporter.table(['Name', 'Version', 'Registry', 'Resolved'], body);\n    })();\n  },\n\n  dir(config, reporter) {\n    reporter.log(config.cacheFolder);\n  },\n\n  clean(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (config.cacheFolder) {\n        yield (_fs || _load_fs()).unlink(config._cacheRootFolder);\n        yield (_fs || _load_fs()).mkdirp(config.cacheFolder);\n        reporter.success(reporter.lang('clearedCache'));\n      }\n    })();\n  }\n});\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/check.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.verifyTreeCheck = exports.noArguments = exports.requireLockfile = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet verifyTreeCheck = exports.verifyTreeCheck = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    let errCount = 0;\n    function reportError(msg) {\n      for (var _len = arguments.length, vars = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        vars[_key - 1] = arguments[_key];\n      }\n\n      reporter.error(reporter.lang(msg, ...vars));\n      errCount++;\n    }\n    // check all dependencies recursively without relying on internal resolver\n    const registryName = 'yarn';\n    const registry = config.registries[registryName];\n    const rootManifest = yield config.readManifest(registry.cwd, registryName);\n\n    const dependenciesToCheckVersion = [];\n    if (rootManifest.dependencies) {\n      for (const name in rootManifest.dependencies) {\n        dependenciesToCheckVersion.push({\n          name,\n          originalKey: name,\n          parentCwd: registry.cwd,\n          version: rootManifest.dependencies[name]\n        });\n      }\n    }\n    if (rootManifest.devDependencies && !config.production) {\n      for (const name in rootManifest.devDependencies) {\n        dependenciesToCheckVersion.push({\n          name,\n          originalKey: name,\n          parentCwd: registry.cwd,\n          version: rootManifest.devDependencies[name]\n        });\n      }\n    }\n\n    const locationsVisited = new Set();\n    while (dependenciesToCheckVersion.length) {\n      const dep = dependenciesToCheckVersion.shift();\n      const manifestLoc = path.join(dep.parentCwd, registry.folder, dep.name);\n      if (locationsVisited.has(manifestLoc + `@${dep.version}`)) {\n        continue;\n      }\n      locationsVisited.add(manifestLoc + `@${dep.version}`);\n      if (!(yield (_fs || _load_fs()).exists(manifestLoc))) {\n        reportError('packageNotInstalled', `${dep.originalKey}`);\n        continue;\n      }\n      const pkg = yield config.readManifest(manifestLoc, registryName);\n      if (semver.validRange(dep.version, config.looseSemver) && !semver.satisfies(pkg.version, dep.version, config.looseSemver)) {\n        reportError('packageWrongVersion', dep.originalKey, dep.version, pkg.version);\n        continue;\n      }\n      const dependencies = pkg.dependencies;\n      if (dependencies) {\n        for (const subdep in dependencies) {\n          const subDepPath = path.join(manifestLoc, registry.folder, subdep);\n          let found = false;\n          const relative = path.relative(registry.cwd, subDepPath);\n          const locations = path.normalize(relative).split(registry.folder + path.sep).filter(function (dir) {\n            return !!dir;\n          });\n          locations.pop();\n          while (locations.length >= 0) {\n            let possiblePath;\n            if (locations.length > 0) {\n              possiblePath = path.join(registry.cwd, registry.folder, locations.join(path.sep + registry.folder + path.sep));\n            } else {\n              possiblePath = registry.cwd;\n            }\n            if (yield (_fs || _load_fs()).exists(path.join(possiblePath, registry.folder, subdep))) {\n              dependenciesToCheckVersion.push({\n                name: subdep,\n                originalKey: `${dep.originalKey}#${subdep}`,\n                parentCwd: possiblePath,\n                version: dependencies[subdep]\n              });\n              found = true;\n              break;\n            }\n            if (!locations.length) {\n              break;\n            }\n            locations.pop();\n          }\n          if (!found) {\n            reportError('packageNotInstalled', `${dep.originalKey}#${subdep}`);\n          }\n        }\n      }\n    }\n\n    if (errCount > 0) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundErrors', errCount));\n    } else {\n      reporter.success(reporter.lang('folderInSync'));\n    }\n  });\n\n  return function verifyTreeCheck(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet integrityHashCheck = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    let errCount = 0;\n    function reportError(msg) {\n      for (var _len2 = arguments.length, vars = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        vars[_key2 - 1] = arguments[_key2];\n      }\n\n      reporter.error(reporter.lang(msg, ...vars));\n      errCount++;\n    }\n\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n\n    // get patterns that are installed when running `yarn install`\n\n    var _ref3 = yield install.hydrate(true);\n\n    const rawPatterns = _ref3.patterns;\n\n    const patterns = yield install.flatten(rawPatterns);\n\n    // check if patterns exist in lockfile\n    for (const pattern of patterns) {\n      if (!lockfile.getLocked(pattern)) {\n        reportError('lockfileNotContainPatter', pattern);\n      }\n    }\n\n    const integrityLoc = yield install.getIntegrityHashLocation();\n    if (integrityLoc && (yield (_fs || _load_fs()).exists(integrityLoc))) {\n      const match = yield install.matchesIntegrityHash(patterns);\n      if (match.matches === false) {\n        reportError('integrityHashesDontMatch', match.expected, match.actual);\n      }\n    } else {\n      reportError('noIntegirtyHashFile');\n    }\n\n    if (errCount > 0) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundErrors', errCount));\n    } else {\n      reporter.success(reporter.lang('folderInSync'));\n    }\n  });\n\n  return function integrityHashCheck(_x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (flags.verifyTree) {\n      yield verifyTreeCheck(config, reporter, flags, args);\n      return;\n    } else if (flags.integrity) {\n      yield integrityHashCheck(config, reporter, flags, args);\n      return;\n    }\n\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n\n    function humaniseLocation(loc) {\n      const relative = path.relative(path.join(config.cwd, 'node_modules'), loc);\n      const normalized = path.normalize(relative).split(path.sep);\n      return normalized.filter(p => p !== 'node_modules').reduce((result, part) => {\n        const length = result.length;\n        if (length && result[length - 1].startsWith('@') && !result[length - 1].includes(path.sep)) {\n          result[length - 1] += path.sep + part;\n        } else {\n          result.push(part);\n        }\n        return result;\n      }, []);\n    }\n\n    let warningCount = 0;\n    let errCount = 0;\n    function reportError(msg) {\n      for (var _len3 = arguments.length, vars = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        vars[_key3 - 1] = arguments[_key3];\n      }\n\n      reporter.error(reporter.lang(msg, ...vars));\n      errCount++;\n    }\n\n    // get patterns that are installed when running `yarn install`\n\n    var _ref5 = yield install.hydrate(true);\n\n    const rawPatterns = _ref5.patterns;\n\n    const patterns = yield install.flatten(rawPatterns);\n\n    // check if patterns exist in lockfile\n    for (const pattern of patterns) {\n      if (!lockfile.getLocked(pattern)) {\n        reportError('lockfileNotContainPatter', pattern);\n      }\n    }\n\n    // check if any of the node_modules are out of sync\n    const res = yield install.linker.getFlatHoistedTree(patterns);\n    for (const _ref6 of res) {\n      var _ref7 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref6, 2);\n\n      const loc = _ref7[0];\n      var _ref7$ = _ref7[1];\n      const originalKey = _ref7$.originalKey;\n      const pkg = _ref7$.pkg;\n      const ignore = _ref7$.ignore;\n\n      if (ignore) {\n        continue;\n      }\n\n      const parts = humaniseLocation(loc);\n\n      // grey out hoisted portions of key\n      let human = originalKey;\n      const hoistedParts = parts.slice();\n      const hoistedKey = parts.join('#');\n      if (human !== hoistedKey) {\n        const humanParts = human.split('#');\n\n        for (let i = 0; i < humanParts.length; i++) {\n          const humanPart = humanParts[i];\n\n          if (hoistedParts[0] === humanPart) {\n            hoistedParts.shift();\n\n            if (i < humanParts.length - 1) {\n              humanParts[i] += '#';\n            }\n          } else {\n            humanParts[i] = reporter.format.dim(`${humanPart}#`);\n          }\n        }\n\n        human = humanParts.join('');\n      }\n\n      const pkgLoc = path.join(loc, 'package.json');\n      if (!(yield (_fs || _load_fs()).exists(loc)) || !(yield (_fs || _load_fs()).exists(pkgLoc))) {\n        if (pkg._reference.optional) {\n          reporter.warn(reporter.lang('optionalDepNotInstalled', human));\n        } else {\n          reportError('packageNotInstalled', human);\n        }\n        continue;\n      }\n\n      const packageJson = yield config.readJson(pkgLoc);\n      if (pkg.version !== packageJson.version) {\n        // node_modules contains wrong version\n        reportError('packageWrongVersion', human, pkg.version, packageJson.version);\n      }\n\n      const deps = Object.assign({}, packageJson.dependencies, packageJson.peerDependencies);\n\n      for (const name in deps) {\n        const range = deps[name];\n        if (!semver.validRange(range, config.looseSemver)) {\n          continue; // exotic\n        }\n\n        const subHuman = `${human}#${name}@${range}`;\n\n        // find the package that this will resolve to, factoring in hoisting\n        const possibles = [];\n        let depPkgLoc;\n        for (let i = parts.length; i >= 0; i--) {\n          const myParts = parts.slice(0, i).concat(name);\n\n          // build package.json location for this position\n          const myDepPkgLoc = path.join(config.cwd, 'node_modules', myParts.join(`${path.sep}node_modules${path.sep}`), 'package.json');\n\n          possibles.push(myDepPkgLoc);\n        }\n        while (possibles.length) {\n          const myDepPkgLoc = possibles.shift();\n          if (yield (_fs || _load_fs()).exists(myDepPkgLoc)) {\n            depPkgLoc = myDepPkgLoc;\n            break;\n          }\n        }\n        if (!depPkgLoc) {\n          // we'll hit the module not install error above when this module is hit\n          continue;\n        }\n\n        //\n        const depPkg = yield config.readJson(depPkgLoc);\n        const foundHuman = `${humaniseLocation(path.dirname(depPkgLoc)).join('#')}@${depPkg.version}`;\n        if (!semver.satisfies(depPkg.version, range, config.looseSemver)) {\n          // module isn't correct semver\n          reportError('packageDontSatisfy', subHuman, foundHuman);\n          continue;\n        }\n\n        // check for modules above us that this could be deduped to\n        for (const loc of possibles) {\n          if (!(yield (_fs || _load_fs()).exists(loc))) {\n            continue;\n          }\n\n          const packageJson = yield config.readJson(loc);\n          if (packageJson.version === depPkg.version || semver.satisfies(packageJson.version, range, config.looseSemver) && semver.gt(packageJson.version, depPkg.version, config.looseSemver)) {\n            reporter.warn(reporter.lang('couldBeDeduped', subHuman, packageJson.version, `${humaniseLocation(path.dirname(loc)).join('#')}@${packageJson.version}`));\n            warningCount++;\n          }\n          break;\n        }\n      }\n    }\n\n    if (warningCount > 1) {\n      reporter.info(reporter.lang('foundWarnings', warningCount));\n    }\n\n    if (errCount > 0) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundErrors', errCount));\n    } else {\n      reporter.success(reporter.lang('folderInSync'));\n    }\n  });\n\n  return function run(_x9, _x10, _x11, _x12) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst semver = require('semver');\nconst path = require('path');\n\nconst requireLockfile = exports.requireLockfile = true;\nconst noArguments = exports.noArguments = true;\n\nfunction setFlags(commander) {\n  commander.option('--integrity');\n  commander.option('--verify-tree');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/clean.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.clean = exports.noArguments = exports.requireLockfile = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet clean = exports.clean = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter) {\n    const loc = path.join(config.cwd, (_constants || _load_constants()).CLEAN_FILENAME);\n    const file = yield (_fs || _load_fs()).readFile(loc);\n    const lines = file.split('\\n');\n    const filters = (0, (_filter || _load_filter()).ignoreLinesToRegex)(lines);\n\n    let removedFiles = 0;\n    let removedSize = 0;\n\n    // build list of possible module folders\n    const locs = new Set();\n    if (config.modulesFolder) {\n      locs.add(config.modulesFolder);\n    }\n    for (const name of (_index || _load_index()).registryNames) {\n      const registry = config.registries[name];\n      locs.add(path.join(config.cwd, registry.folder));\n    }\n\n    for (const folder of locs) {\n      if (!(yield (_fs || _load_fs()).exists(folder))) {\n        continue;\n      }\n\n      const spinner = reporter.activity();\n      const files = yield (_fs || _load_fs()).walk(folder);\n\n      var _sortFilter = (0, (_filter || _load_filter()).sortFilter)(files, filters);\n\n      const ignoreFiles = _sortFilter.ignoreFiles;\n\n      spinner.end();\n\n      const tick = reporter.progress(ignoreFiles.size);\n      // TODO make sure `main` field of all modules isn't ignored\n\n      for (const file of ignoreFiles) {\n        const loc = path.join(folder, file);\n        const stat = yield (_fs || _load_fs()).lstat(loc);\n        removedSize += stat.size;\n        removedFiles++;\n      }\n\n      for (const file of ignoreFiles) {\n        const loc = path.join(folder, file);\n        yield (_fs || _load_fs()).unlink(loc);\n        tick();\n      }\n    }\n\n    return { removedFiles, removedSize };\n  });\n\n  return function clean(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    reporter.step(1, 2, reporter.lang('cleanCreatingFile', (_constants || _load_constants()).CLEAN_FILENAME));\n\n    const cleanLoc = path.join(config.cwd, (_constants || _load_constants()).CLEAN_FILENAME);\n    if (!(yield (_fs || _load_fs()).exists(cleanLoc))) {\n      yield (_fs || _load_fs()).writeFile(cleanLoc, `${DEFAULT_FILTER}\\n`, { flag: 'wx' });\n    }\n\n    reporter.step(2, 2, reporter.lang('cleaning'));\n\n    var _ref3 = yield clean(config, reporter);\n\n    const removedFiles = _ref3.removedFiles,\n          removedSize = _ref3.removedSize;\n\n    reporter.info(reporter.lang('cleanRemovedFiles', removedFiles));\n    reporter.info(reporter.lang('cleanSavedSize', Number((removedSize / 1024 / 1024).toFixed(2))));\n  });\n\n  return function run(_x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _filter;\n\nfunction _load_filter() {\n  return _filter = require('../../util/filter.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst requireLockfile = exports.requireLockfile = true;\nconst noArguments = exports.noArguments = true;\n\nconst DEFAULT_FILTER = `\n# test directories\n__tests__\ntest\ntests\npowered-test\n\n# asset directories\ndocs\ndoc\nwebsite\nimages\nassets\n\n# examples\nexample\nexamples\n\n# code coverage directories\ncoverage\n.nyc_output\n\n# build scripts\nMakefile\nGulpfile.js\nGruntfile.js\n\n# configs\n.tern-project\n.gitattributes\n.editorconfig\n.*ignore\n.eslintrc\n.jshintrc\n.flowconfig\n.documentup.json\n.yarn-metadata.json\n.*.yml\n*.yml\n\n# misc\n*.gz\n*.md\n`.trim();","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/config.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.hasWrapper = hasWrapper;\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasWrapper(flags, args) {\n  return args[0] !== 'get';\n}\n/* eslint object-shorthand: 0 */\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('config', {\n  set(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (args.length === 0 || args.length > 2) {\n        return false;\n      }\n      const key = args[0];\n      const val = args[1] || true;\n      const yarnConfig = config.registries.yarn;\n      yield yarnConfig.saveHomeConfig({ [key]: val });\n      reporter.success(reporter.lang('configSet', key, val));\n      return true;\n    })();\n  },\n\n  get(config, reporter, flags, args) {\n    if (args.length !== 1) {\n      return false;\n    }\n\n    reporter.log(String(config.getOption(args[0])));\n    return true;\n  },\n\n  delete: (() => {\n    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n      if (args.length !== 1) {\n        return false;\n      }\n\n      const key = args[0];\n      const yarnConfig = config.registries.yarn;\n      yield yarnConfig.saveHomeConfig({ [key]: undefined });\n      reporter.success(reporter.lang('configDelete', key));\n      return true;\n    });\n\n    return function _delete(_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  })(),\n\n  list(config, reporter, flags, args) {\n    if (args.length) {\n      return false;\n    }\n\n    reporter.info(reporter.lang('configYarn'));\n    reporter.inspect(config.registries.yarn.config);\n\n    reporter.info(reporter.lang('configNpm'));\n    reporter.inspect(config.registries.npm.config);\n\n    return true;\n  }\n});\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/generate-lock-entry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.examples = exports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    let manifest;\n    if (flags.useManifest) {\n      manifest = yield config.readJson(flags.useManifest);\n    } else {\n      manifest = yield config.readRootManifest();\n    }\n    if (!manifest.name) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('noName'));\n    }\n    if (!manifest.version) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('noVersion'));\n    }\n\n    const entry = {\n      name: manifest.name,\n      version: manifest.version,\n      resolved: flags.resolved,\n      registry: flags.registry || manifest._registry,\n      optionalDependencies: manifest.optionalDependencies,\n      dependencies: manifest.dependencies\n    };\n    const pattern = flags.pattern || `${entry.name}@${entry.version}`;\n    console.log((0, (_stringify || _load_stringify()).default)({\n      [pattern]: (0, (_wrapper || _load_wrapper()).implodeEntry)(pattern, entry)\n    }));\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nexports.hasWrapper = hasWrapper;\nexports.setFlags = setFlags;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = require('../../lockfile/wrapper.js');\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('../../lockfile/stringify.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasWrapper() {\n  return false;\n}\n\nfunction setFlags(commander) {\n  commander.option('--use-manifest <location>', 'description');\n  commander.option('--resolved <resolved>', 'description');\n  commander.option('--registry <registry>', 'description');\n}\n\nconst examples = exports.examples = ['generate-lock-entry', 'generate-lock-entry --use-manifest ./package.json', 'generate-lock-entry --resolved local-file.tgz#hash'];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/global.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet updateCwd = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config) {\n    yield config.init({\n      cwd: config.globalFolder,\n      binLinks: true,\n      globalFolder: config.globalFolder,\n      cacheFolder: config._cacheRootFolder,\n      linkFolder: config.linkFolder\n    });\n  });\n\n  return function updateCwd(_x) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet getBins = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config) {\n    // build up list of registry folders to search for binaries\n    const dirs = [];\n    for (const registryName of Object.keys((_index || _load_index()).registries)) {\n      const registry = config.registries[registryName];\n      dirs.push(registry.loc);\n    }\n\n    // build up list of binary files\n    const paths = new Set();\n    for (const dir of dirs) {\n      const binDir = path.join(dir, '.bin');\n      if (!(yield (_fs || _load_fs()).exists(binDir))) {\n        continue;\n      }\n\n      for (const name of yield (_fs || _load_fs()).readdir(binDir)) {\n        paths.add(path.join(binDir, name));\n      }\n    }\n    return paths;\n  });\n\n  return function getBins(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet initUpdateBins = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags) {\n    const beforeBins = yield getBins(config);\n    const binFolder = getBinFolder(config, flags);\n\n    function throwPermError(err, dest) {\n      if (err.code === 'EACCES') {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('noFilePermission', dest));\n      } else {\n        throw err;\n      }\n    }\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const afterBins = yield getBins(config);\n\n      // remove old bins\n      for (const src of beforeBins) {\n        if (afterBins.has(src)) {\n          // not old\n          continue;\n        }\n\n        // remove old bin\n        const dest = path.join(binFolder, path.basename(src));\n        try {\n          yield (_fs || _load_fs()).unlink(dest);\n        } catch (err) {\n          throwPermError(err, dest);\n        }\n      }\n\n      // add new bins\n      for (const src of afterBins) {\n        if (beforeBins.has(src)) {\n          // already inserted\n          continue;\n        }\n\n        // insert new bin\n        const dest = path.join(binFolder, path.basename(src));\n        try {\n          yield (_fs || _load_fs()).unlink(dest);\n          yield (0, (_packageLinker || _load_packageLinker()).linkBin)(src, dest);\n          if (process.platform === 'win32' && dest.indexOf('.cmd') !== -1) {\n            yield (_fs || _load_fs()).rename(dest + '.cmd', dest);\n          }\n        } catch (err) {\n          throwPermError(err, dest);\n        }\n      }\n    });\n  });\n\n  return function initUpdateBins(_x3, _x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nexports.hasWrapper = hasWrapper;\nexports.getBinFolder = getBinFolder;\nexports.setFlags = setFlags;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('../../reporters/base-reporter.js'));\n}\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _add;\n\nfunction _load_add() {\n  return _add = require('./add.js');\n}\n\nvar _remove;\n\nfunction _load_remove() {\n  return _remove = require('./remove.js');\n}\n\nvar _upgrade;\n\nfunction _load_upgrade() {\n  return _upgrade = require('./upgrade.js');\n}\n\nvar _upgradeInteractive;\n\nfunction _load_upgradeInteractive() {\n  return _upgradeInteractive = require('./upgrade-interactive.js');\n}\n\nvar _packageLinker;\n\nfunction _load_packageLinker() {\n  return _packageLinker = require('../../package-linker.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass GlobalAdd extends (_add || _load_add()).Add {\n  maybeOutputSaveTree() {\n    for (const pattern of this.addedPatterns) {\n      const manifest = this.resolver.getStrictResolvedPattern(pattern);\n      ls(manifest, this.reporter, true);\n    }\n    return Promise.resolve();\n  }\n\n  _logSuccessSaveLockfile() {\n    // noop\n  }\n}\n\nconst path = require('path');\n\nfunction hasWrapper(flags, args) {\n  return args[0] !== 'bin';\n}\n\nfunction getGlobalPrefix(config, flags) {\n  if (flags.prefix) {\n    return flags.prefix;\n  } else if (config.getOption('prefix')) {\n    return String(config.getOption('prefix'));\n  } else if (process.env.PREFIX) {\n    return process.env.PREFIX;\n  } else if (process.platform === 'win32') {\n    // c:\\node\\node.exe --> prefix=c:\\node\\\n    return path.dirname(process.execPath);\n  } else {\n    // /usr/local/bin/node --> prefix=/usr/local\n    let prefix = path.dirname(path.dirname(process.execPath));\n\n    // destdir only is respected on Unix\n    if (process.env.DESTDIR) {\n      prefix = path.join(process.env.DESTDIR, prefix);\n    }\n\n    return prefix;\n  }\n}\n\nfunction getBinFolder(config, flags) {\n  const prefix = getGlobalPrefix(config, flags);\n  if (process.platform === 'win32') {\n    return prefix;\n  } else {\n    return path.resolve(prefix, 'bin');\n  }\n}\n\nfunction ls(manifest, reporter, saved) {\n  const bins = manifest.bin ? Object.keys(manifest.bin) : [];\n  const human = `${manifest.name}@${manifest.version}`;\n  if (bins.length) {\n    if (saved) {\n      reporter.success(reporter.lang('packageInstalledWithBinaries', human));\n    } else {\n      reporter.info(reporter.lang('packageHasBinaries', human));\n    }\n    reporter.list(`bins-${manifest.name}`, bins);\n  } else if (saved) {\n    reporter.warn(reporter.lang('packageHasNoBinaries'));\n  }\n}\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('global', {\n  add(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield updateCwd(config);\n\n      const updateBins = yield initUpdateBins(config, reporter, flags);\n\n      // install module\n      const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n      const install = new GlobalAdd(args, flags, config, reporter, lockfile);\n      yield install.init();\n\n      // link binaries\n      yield updateBins();\n    })();\n  },\n\n  bin(config, reporter, flags, args) {\n    console.log(getBinFolder(config, flags));\n  },\n\n  ls(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield updateCwd(config);\n\n      // install so we get hard file paths\n      const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n      const install = new (_install || _load_install()).Install({ skipIntegrity: true }, config, new (_baseReporter || _load_baseReporter()).default(), lockfile);\n      const patterns = yield install.init();\n\n      // dump global modules\n      for (const pattern of patterns) {\n        const manifest = install.resolver.getStrictResolvedPattern(pattern);\n        ls(manifest, reporter, false);\n      }\n    })();\n  },\n\n  remove(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield updateCwd(config);\n\n      const updateBins = yield initUpdateBins(config, reporter, flags);\n\n      // remove module\n      yield (0, (_remove || _load_remove()).run)(config, reporter, flags, args);\n\n      // remove binaries\n      yield updateBins();\n    })();\n  },\n\n  upgrade(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield updateCwd(config);\n\n      const updateBins = yield initUpdateBins(config, reporter, flags);\n\n      // upgrade module\n      yield (0, (_upgrade || _load_upgrade()).run)(config, reporter, flags, args);\n\n      // update binaries\n      yield updateBins();\n    })();\n  },\n\n  upgradeInteractive(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield updateCwd(config);\n\n      const updateBins = yield initUpdateBins(config, reporter, flags);\n\n      // upgrade module\n      yield (0, (_upgradeInteractive || _load_upgradeInteractive()).run)(config, reporter, flags, args);\n\n      // update binaries\n      yield updateBins();\n    })();\n  }\n});\n\nconst run = _buildSubCommands.run,\n      _setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nfunction setFlags(commander) {\n  _setFlags(commander);\n  commander.option('--prefix <prefix>', 'bin prefix to use to install binaries');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/help.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = run;\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./index.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../../constants.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nconst chalk = require('chalk');\n\nfunction run(config, reporter, commander, args) {\n  const getDocsLink = name => `${(_constants || _load_constants()).YARN_DOCS}${name || ''}`;\n  const getDocsInfo = name => 'Visit ' + chalk.bold(getDocsLink(name)) + ' for documentation about this command.';\n\n  if (args.length) {\n    const helpCommand = (0, (_misc || _load_misc()).hyphenate)(args[0]);\n    if ((_index || _load_index())[helpCommand]) {\n      commander.on('--help', () => console.log('  ' + getDocsInfo(helpCommand) + '\\n'));\n    }\n  } else {\n    commander.on('--help', () => {\n      console.log('  Commands:\\n');\n      for (const name of Object.keys(_index || _load_index()).sort((_misc || _load_misc()).sortAlpha)) {\n        if ((_index || _load_index())[name].useless) {\n          continue;\n        }\n\n        console.log(`    - ${(0, (_misc || _load_misc()).hyphenate)(name)}`);\n      }\n      console.log('\\n  Run `' + chalk.bold('yarn help COMMAND') + '` for more information on specific commands.');\n      console.log('  Visit ' + chalk.bold(getDocsLink()) + ' to learn more about Yarn.\\n');\n    });\n  }\n  commander.help();\n  return Promise.resolve();\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/import.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.Import = exports.noArguments = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const imp = new Import(flags, config, reporter, new (_wrapper || _load_wrapper()).default({}));\n    yield imp.init();\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _check;\n\nfunction _load_check() {\n  return _check = require('./check.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _baseResolver;\n\nfunction _load_baseResolver() {\n  return _baseResolver = _interopRequireDefault(require('../../resolvers/base-resolver.js'));\n}\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('../../resolvers/exotics/hosted-git-resolver.js'));\n}\n\nvar _hostedGitResolver2;\n\nfunction _load_hostedGitResolver2() {\n  return _hostedGitResolver2 = require('../../resolvers/exotics/hosted-git-resolver.js');\n}\n\nvar _gistResolver;\n\nfunction _load_gistResolver() {\n  return _gistResolver = _interopRequireDefault(require('../../resolvers/exotics/gist-resolver.js'));\n}\n\nvar _gistResolver2;\n\nfunction _load_gistResolver2() {\n  return _gistResolver2 = require('../../resolvers/exotics/gist-resolver.js');\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('../../resolvers/exotics/git-resolver.js'));\n}\n\nvar _fileResolver;\n\nfunction _load_fileResolver() {\n  return _fileResolver = _interopRequireDefault(require('../../resolvers/exotics/file-resolver.js'));\n}\n\nvar _packageResolver;\n\nfunction _load_packageResolver() {\n  return _packageResolver = _interopRequireDefault(require('../../package-resolver.js'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _packageFetcher;\n\nfunction _load_packageFetcher() {\n  return _packageFetcher = _interopRequireDefault(require('../../package-fetcher.js'));\n}\n\nvar _packageLinker;\n\nfunction _load_packageLinker() {\n  return _packageLinker = _interopRequireDefault(require('../../package-linker.js'));\n}\n\nvar _packageCompatibility;\n\nfunction _load_packageCompatibility() {\n  return _packageCompatibility = _interopRequireDefault(require('../../package-compatibility.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst NPM_REGISTRY = /http[s]:\\/\\/registry.npmjs.org/g;\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst noArguments = exports.noArguments = true;\n\nclass ImportResolver extends (_baseResolver || _load_baseResolver()).default {\n  getCwd() {\n    if (this.request.parentRequest) {\n      const parent = this.resolver.getStrictResolvedPattern(this.request.parentRequest.pattern);\n      invariant(parent._loc, 'expected package location');\n      return path.dirname(parent._loc);\n    }\n    return this.config.cwd;\n  }\n\n  resolveHostedGit(info, Resolver) {\n    var _PackageRequest$norma = (_packageRequest || _load_packageRequest()).default.normalizePattern(this.pattern);\n\n    const range = _PackageRequest$norma.range;\n\n    const exploded = (0, (_hostedGitResolver2 || _load_hostedGitResolver2()).explodeHostedGitFragment)(range, this.reporter);\n    const hash = info.gitHead;\n    invariant(hash, 'expected package gitHead');\n    const url = Resolver.getTarballUrl(exploded, hash);\n    info._uid = hash;\n    info._remote = {\n      resolved: url,\n      type: 'tarball',\n      registry: this.registry,\n      reference: url,\n      hash: null\n    };\n    return info;\n  }\n\n  resolveGist(info, Resolver) {\n    var _PackageRequest$norma2 = (_packageRequest || _load_packageRequest()).default.normalizePattern(this.pattern);\n\n    const range = _PackageRequest$norma2.range;\n\n    var _explodeGistFragment = (0, (_gistResolver2 || _load_gistResolver2()).explodeGistFragment)(range, this.reporter);\n\n    const id = _explodeGistFragment.id;\n\n    const hash = info.gitHead;\n    invariant(hash, 'expected package gitHead');\n    const url = `https://gist.github.com/${id}.git`;\n    info._uid = hash;\n    info._remote = {\n      resolved: `${url}#${hash}`,\n      type: 'git',\n      registry: this.registry,\n      reference: url,\n      hash\n    };\n    return info;\n  }\n\n  resolveGit(info, Resolver) {\n    const url = info._resolved;\n    const hash = info.gitHead;\n    invariant(url, 'expected package _resolved');\n    invariant(hash, 'expected package gitHead');\n    info._uid = hash;\n    info._remote = {\n      resolved: `${url}#${hash}`,\n      type: 'git',\n      registry: this.registry,\n      reference: url,\n      hash\n    };\n    return info;\n  }\n\n  resolveFile(info, Resolver) {\n    var _PackageRequest$norma3 = (_packageRequest || _load_packageRequest()).default.normalizePattern(this.pattern);\n\n    const range = _PackageRequest$norma3.range;\n\n    let loc = (_misc || _load_misc()).removePrefix(range, 'file:');\n    if (!path.isAbsolute(loc)) {\n      loc = path.join(this.config.cwd, loc);\n    }\n    info._uid = info.version;\n    info._remote = {\n      type: 'copy',\n      registry: this.registry,\n      hash: null,\n      reference: loc\n    };\n    return info;\n  }\n\n  resolveRegistry(info) {\n    let url = info._resolved;\n    const hash = info._shasum;\n    invariant(url, 'expected package _resolved');\n    invariant(hash, 'expected package _shasum');\n    if (this.config.getOption('registry') === (_constants || _load_constants()).YARN_REGISTRY) {\n      url = url.replace(NPM_REGISTRY, (_constants || _load_constants()).YARN_REGISTRY);\n    }\n    info._uid = info.version;\n    info._remote = {\n      resolved: `${url}#${hash}`,\n      type: 'tarball',\n      registry: this.registry,\n      reference: url,\n      hash\n    };\n    return info;\n  }\n\n  resolveImport(info) {\n    var _PackageRequest$norma4 = (_packageRequest || _load_packageRequest()).default.normalizePattern(this.pattern);\n\n    const range = _PackageRequest$norma4.range;\n\n    const Resolver = (_packageRequest || _load_packageRequest()).default.getExoticResolver(range);\n    if (Resolver && Resolver.prototype instanceof (_hostedGitResolver || _load_hostedGitResolver()).default) {\n      return this.resolveHostedGit(info, Resolver);\n    } else if (Resolver && Resolver === (_gistResolver || _load_gistResolver()).default) {\n      return this.resolveGist(info, Resolver);\n    } else if (Resolver && Resolver === (_gitResolver || _load_gitResolver()).default) {\n      return this.resolveGit(info, Resolver);\n    } else if (Resolver && Resolver === (_fileResolver || _load_fileResolver()).default) {\n      return this.resolveFile(info, Resolver);\n    }\n    return this.resolveRegistry(info);\n  }\n\n  resolveLocation(loc) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const info = yield _this.config.tryManifest(loc, 'npm', false);\n      if (!info) {\n        return null;\n      }\n      return _this.resolveImport(info);\n    })();\n  }\n\n  resolve() {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _PackageRequest$norma5 = (_packageRequest || _load_packageRequest()).default.normalizePattern(_this2.pattern);\n\n      const name = _PackageRequest$norma5.name;\n\n      let cwd = _this2.getCwd();\n      while (!path.relative(_this2.config.cwd, cwd).startsWith('..')) {\n        const loc = path.join(cwd, 'node_modules', name);\n        const info = yield _this2.config.getCache(`import-resolver-${loc}`, function () {\n          return _this2.resolveLocation(loc);\n        });\n        if (info) {\n          return info;\n        }\n        cwd = path.resolve(cwd, '../..');\n      }\n      throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('importResolveFailed', name, _this2.getCwd()));\n    })();\n  }\n}\n\nclass ImportPackageRequest extends (_packageRequest || _load_packageRequest()).default {\n  constructor(req, resolver) {\n    super(req, resolver);\n    this.import = this.parentRequest instanceof ImportPackageRequest ? this.parentRequest.import : true;\n  }\n\n  getRootName() {\n    return this.resolver instanceof ImportPackageResolver && this.resolver.rootName || 'root';\n  }\n\n  getParentHumanName() {\n    return [this.getRootName()].concat(this.getParentNames()).join(' > ');\n  }\n\n  reportResolvedRangeMatch(info, resolved) {\n    if (info.version === resolved.version) {\n      return;\n    }\n    this.reporter.warn(this.reporter.lang('importResolvedRangeMatch', resolved.version, resolved.name, info.version, this.getParentHumanName()));\n  }\n\n  findVersionInfo() {\n    if (!this.import) {\n      this.reporter.verbose(this.reporter.lang('skippingImport', this.pattern, this.getParentHumanName()));\n      return super.findVersionInfo();\n    }\n    const resolver = new ImportResolver(this, this.pattern);\n    return resolver.resolve().catch(() => {\n      this.import = false;\n      this.reporter.warn(this.reporter.lang('importFailed', this.pattern, this.getParentHumanName()));\n      return super.findVersionInfo();\n    });\n  }\n}\n\nclass ImportPackageResolver extends (_packageResolver || _load_packageResolver()).default {\n  constructor(config, lockfile) {\n    super(config, lockfile);\n    this.next = [];\n    this.rootName = 'root';\n  }\n\n  find(req) {\n    this.next.push(req);\n    return Promise.resolve();\n  }\n\n  findOne(req) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (_this3.activity) {\n        _this3.activity.tick(req.pattern);\n      }\n      const request = new ImportPackageRequest(req, _this3);\n      yield request.find();\n    })();\n  }\n\n  findAll(deps) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield Promise.all(deps.map(function (dep) {\n        return _this4.findOne(dep);\n      }));\n      deps = _this4.next;\n      _this4.next = [];\n      if (!deps.length) {\n        return;\n      }\n      yield _this4.findAll(deps);\n    })();\n  }\n\n  resetOptional() {\n    for (const pattern in this.patterns) {\n      const ref = this.patterns[pattern]._reference;\n      invariant(ref, 'expected reference');\n      ref.optional = null;\n      for (const req of ref.requests) {\n        ref.addOptional(req.optional);\n      }\n    }\n  }\n\n  init(deps, isFlat, rootName) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this5.flat = isFlat;\n      _this5.rootName = rootName || _this5.rootName;\n      const activity = _this5.activity = _this5.reporter.activity();\n      _this5.seedPatterns = deps.map(function (dep) {\n        return dep.pattern;\n      });\n      yield _this5.findAll(deps);\n      _this5.resetOptional();\n      activity.end();\n      _this5.activity = null;\n    })();\n  }\n}\n\nclass Import extends (_install || _load_install()).Install {\n  constructor(flags, config, reporter, lockfile) {\n    super(flags, config, reporter, lockfile);\n    this.resolver = new ImportPackageResolver(this.config, this.lockfile);\n    this.fetcher = new (_packageFetcher || _load_packageFetcher()).default(config, this.resolver);\n    this.compatibility = new (_packageCompatibility || _load_packageCompatibility()).default(config, this.resolver, this.flags.ignoreEngines);\n    this.linker = new (_packageLinker || _load_packageLinker()).default(config, this.resolver);\n  }\n\n  init() {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (yield (_fs || _load_fs()).exists(path.join(_this6.config.cwd, (_constants || _load_constants()).LOCKFILE_FILENAME))) {\n        throw new (_errors || _load_errors()).MessageError(_this6.reporter.lang('lockfileExists'));\n      }\n      yield (0, (_check || _load_check()).verifyTreeCheck)(_this6.config, _this6.reporter, {}, []);\n\n      var _ref = yield _this6.fetchRequestFromCwd();\n\n      const requests = _ref.requests,\n            patterns = _ref.patterns,\n            manifest = _ref.manifest;\n\n      yield _this6.resolver.init(requests, _this6.flags.flat, manifest.name);\n      yield _this6.fetcher.init();\n      yield _this6.compatibility.init();\n      yield _this6.linker.resolvePeerModules();\n      yield _this6.saveLockfileAndIntegrity(patterns);\n      return patterns;\n    })();\n  }\n}\n\nexports.Import = Import;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/base-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass BaseResolver {\n  constructor(request, fragment) {\n    this.resolver = request.resolver;\n    this.reporter = request.reporter;\n    this.fragment = fragment;\n    this.registry = request.registry;\n    this.request = request;\n    this.pattern = request.pattern;\n    this.config = request.config;\n  }\n\n  fork(Resolver, resolveArg) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    const resolver = new Resolver(this.request, ...args);\n    resolver.registry = this.registry;\n    return resolver.resolve(resolveArg);\n  }\n\n  resolve() {\n    throw new Error('Not implemented');\n  }\n}\nexports.default = BaseResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-request.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = require('./util/normalize-manifest/validate.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _packageReference;\n\nfunction _load_packageReference() {\n  return _packageReference = _interopRequireDefault(require('./package-reference.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./resolvers/index.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('./resolvers/index.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('./util/version.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageRequest {\n  constructor(req, resolver) {\n    this.parentRequest = req.parentRequest;\n    this.lockfile = resolver.lockfile;\n    this.registry = req.registry;\n    this.reporter = resolver.reporter;\n    this.resolver = resolver;\n    this.optional = req.optional;\n    this.pattern = req.pattern;\n    this.config = resolver.config;\n\n    resolver.usedRegistries.add(req.registry);\n  }\n\n  static getExoticResolver(pattern) {\n    // TODO make this type more refined\n    for (const _ref of (0, (_misc || _load_misc()).entries)((_index || _load_index()).exotics)) {\n      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n      const Resolver = _ref2[1];\n\n      if (Resolver.isVersion(pattern)) {\n        return Resolver;\n      }\n    }\n    return null;\n  }\n\n  getParentNames() {\n    const chain = [];\n\n    let request = this.parentRequest;\n    while (request) {\n      const info = this.resolver.getStrictResolvedPattern(request.pattern);\n      chain.unshift(info.name);\n\n      request = request.parentRequest;\n    }\n\n    return chain;\n  }\n\n  getLocked(remoteType) {\n    // always prioritise root lockfile\n    const shrunk = this.lockfile.getLocked(this.pattern);\n\n    if (shrunk && shrunk.resolved) {\n      const resolvedParts = (_version || _load_version()).explodeHashedUrl(shrunk.resolved);\n\n      return {\n        name: shrunk.name,\n        version: shrunk.version,\n        _uid: shrunk.uid,\n        _remote: {\n          resolved: shrunk.resolved,\n          type: remoteType,\n          reference: resolvedParts.url,\n          hash: resolvedParts.hash,\n          registry: shrunk.registry\n        },\n        optionalDependencies: shrunk.optionalDependencies,\n        dependencies: shrunk.dependencies\n      };\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * If the input pattern matches a registry one then attempt to find it on the registry.\n   * Otherwise fork off to an exotic resolver if one matches.\n   */\n\n  findVersionOnRegistry(pattern) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref3 = yield _this.normalize(pattern);\n\n      const range = _ref3.range,\n            name = _ref3.name;\n\n\n      const exoticResolver = PackageRequest.getExoticResolver(range);\n      if (exoticResolver) {\n        let data = yield _this.findExoticVersionInfo(exoticResolver, range);\n\n        // clone data as we're manipulating it in place and this could be resolved multiple\n        // times\n        data = Object.assign({}, data);\n\n        // this is so the returned package response uses the overridden name. ie. if the\n        // package's actual name is `bar`, but it's been specified in the manifest like:\n        //   \"foo\": \"http://foo.com/bar.tar.gz\"\n        // then we use the foo name\n        data.name = name;\n\n        return data;\n      }\n\n      const Resolver = _this.getRegistryResolver();\n      const resolver = new Resolver(_this, name, range);\n      return resolver.resolve();\n    })();\n  }\n\n  /**\n   * Get the registry resolver associated with this package request.\n   */\n\n  getRegistryResolver() {\n    const Resolver = (_index2 || _load_index2()).registries[this.registry];\n    if (Resolver) {\n      return Resolver;\n    } else {\n      throw new (_errors || _load_errors()).MessageError(this.reporter.lang('unknownRegistryResolver', this.registry));\n    }\n  }\n\n  normalizeRange(pattern) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (pattern.includes(':') || pattern.includes('@') || PackageRequest.getExoticResolver(pattern)) {\n        return Promise.resolve(pattern);\n      }\n\n      if (yield (_fs || _load_fs()).exists(path.join(_this2.config.cwd, pattern))) {\n        return Promise.resolve(`file:${pattern}`);\n      }\n\n      return Promise.resolve(pattern);\n    })();\n  }\n\n  normalize(pattern) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _PackageRequest$norma = PackageRequest.normalizePattern(pattern);\n\n      const name = _PackageRequest$norma.name,\n            range = _PackageRequest$norma.range,\n            hasVersion = _PackageRequest$norma.hasVersion;\n\n      const newRange = yield _this3.normalizeRange(range);\n      return { name, range: newRange, hasVersion };\n    })();\n  }\n\n  /**\n   * Explode and normalize a pattern into it's name and range.\n   */\n\n  static normalizePattern(pattern) {\n    let hasVersion = false;\n    let range = 'latest';\n    let name = pattern;\n\n    // if we're a scope then remove the @ and add it back later\n    let isScoped = false;\n    if (name[0] === '@') {\n      isScoped = true;\n      name = name.slice(1);\n    }\n\n    // take first part as the name\n    const parts = name.split('@');\n    if (parts.length > 1) {\n      name = parts.shift();\n      range = parts.join('@');\n\n      if (range) {\n        hasVersion = true;\n      } else {\n        range = '*';\n      }\n    }\n\n    // add back @ scope suffix\n    if (isScoped) {\n      name = `@${name}`;\n    }\n\n    return { name, range, hasVersion };\n  }\n\n  /**\n   * Construct an exotic resolver instance with the input `ExoticResolver` and `range`.\n   */\n\n  findExoticVersionInfo(ExoticResolver, range) {\n    const resolver = new ExoticResolver(this, range);\n    return resolver.resolve();\n  }\n\n  /**\n   * If the current pattern matches an exotic resolver then delegate to it or else try\n   * the registry.\n   */\n\n  findVersionInfo() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const exoticResolver = PackageRequest.getExoticResolver(_this4.pattern);\n      if (exoticResolver) {\n        return yield _this4.findExoticVersionInfo(exoticResolver, _this4.pattern);\n      } else {\n        return yield _this4.findVersionOnRegistry(_this4.pattern);\n      }\n    })();\n  }\n\n  reportResolvedRangeMatch(info, resolved) {}\n\n  /**\n   * TODO description\n   */\n\n  find() {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // find version info for this package pattern\n      const info = yield _this5.findVersionInfo();\n      if (!info) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('unknownPackage', _this5.pattern));\n      }\n\n      (0, (_validate || _load_validate()).cleanDependencies)(info, false, _this5.reporter, function () {\n        // swallow warnings\n      });\n\n      // check if while we were resolving this dep we've already resolved one that satisfies\n      // the same range\n\n      var _PackageRequest$norma2 = PackageRequest.normalizePattern(_this5.pattern);\n\n      const range = _PackageRequest$norma2.range,\n            name = _PackageRequest$norma2.name;\n\n      const resolved = _this5.resolver.getHighestRangeVersionMatch(name, range);\n      if (resolved) {\n        _this5.reportResolvedRangeMatch(info, resolved);\n        const ref = resolved._reference;\n        invariant(ref, 'Resolved package info has no package reference');\n        ref.addRequest(_this5);\n        ref.addPattern(_this5.pattern, resolved);\n        return;\n      }\n\n      if (info.flat && !_this5.resolver.flat) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('flatGlobalError'));\n      }\n\n      // validate version info\n      PackageRequest.validateVersionInfo(info, _this5.reporter);\n\n      //\n      const remote = info._remote;\n      invariant(remote, 'Missing remote');\n\n      // set package reference\n      const ref = new (_packageReference || _load_packageReference()).default(_this5, info, remote);\n      ref.addPattern(_this5.pattern, info);\n      ref.addOptional(_this5.optional);\n      info._reference = ref;\n      info._remote = remote;\n\n      // start installation of dependencies\n      const promises = [];\n      const deps = [];\n\n      // normal deps\n      for (const depName in info.dependencies) {\n        const depPattern = depName + '@' + info.dependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: false,\n          parentRequest: _this5\n        }));\n      }\n\n      // optional deps\n      for (const depName in info.optionalDependencies) {\n        const depPattern = depName + '@' + info.optionalDependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: true,\n          parentRequest: _this5\n        }));\n      }\n\n      yield Promise.all(promises);\n      ref.addDependencies(deps);\n\n      // Now that we have all dependencies, it's safe to propagate optional\n      for (const otherRequest of ref.requests.slice(1)) {\n        ref.addOptional(otherRequest.optional);\n      }\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  static validateVersionInfo(info, reporter) {\n    // human readable name to use in errors\n    const human = `${info.name}@${info.version}`;\n\n    info.version = PackageRequest.getPackageVersion(info);\n\n    for (const key of (_constants || _load_constants()).REQUIRED_PACKAGE_KEYS) {\n      if (!info[key]) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('missingRequiredPackageKey', human, key));\n      }\n    }\n  }\n\n  /**\n   * Returns the package version if present, else defaults to the uid\n   */\n\n  static getPackageVersion(info) {\n    // TODO possibly reconsider this behaviour\n    return info.version === undefined ? info._uid : info.version;\n  }\n\n  /**\n   * Gets all of the outdated packages and sorts them appropriately\n   */\n\n  static getOutdatedPackages(lockfile, install, config, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref4 = yield install.fetchRequestFromCwd();\n\n      const depReqPatterns = _ref4.requests;\n\n\n      const deps = yield Promise.all(depReqPatterns.map((() => {\n        var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref6) {\n          let pattern = _ref6.pattern,\n              hint = _ref6.hint;\n\n          const locked = lockfile.getLocked(pattern);\n          if (!locked) {\n            throw new (_errors || _load_errors()).MessageError(reporter.lang('lockfileOutdated'));\n          }\n\n          const name = locked.name,\n                current = locked.version;\n\n          let latest = '';\n          let wanted = '';\n          let url = '';\n\n          const normalized = PackageRequest.normalizePattern(pattern);\n\n          if (PackageRequest.getExoticResolver(pattern) || PackageRequest.getExoticResolver(normalized.range)) {\n            latest = wanted = 'exotic';\n            url = normalized.range;\n          } else {\n            const registry = config.registries[locked.registry];\n\n            var _ref7 = yield registry.checkOutdated(config, name, normalized.range);\n\n            latest = _ref7.latest;\n            wanted = _ref7.wanted;\n            url = _ref7.url;\n          }\n\n          return { name, current, wanted, latest, url, hint };\n        });\n\n        return function (_x) {\n          return _ref5.apply(this, arguments);\n        };\n      })()));\n\n      // Make sure to always output `exotic` versions to be compatible with npm\n      const isDepOld = function (_ref8) {\n        let current = _ref8.current,\n            latest = _ref8.latest,\n            wanted = _ref8.wanted;\n        return latest === 'exotic' || latest !== 'exotic' && (semver.lt(current, wanted) || semver.lt(current, latest));\n      };\n      const orderByName = function (depA, depB) {\n        return depA.name.localeCompare(depB.name);\n      };\n\n      return deps.filter(isDepOld).sort(orderByName);\n    })();\n  }\n}\nexports.default = PackageRequest;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('./package-request.js'));\n}\n\nvar _requestManager;\n\nfunction _load_requestManager() {\n  return _requestManager = _interopRequireDefault(require('./util/request-manager.js'));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./util/blocking-queue.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageResolver {\n  constructor(config, lockfile) {\n    this.patternsByPackage = (0, (_map || _load_map()).default)();\n    this.fetchingPatterns = (0, (_map || _load_map()).default)();\n    this.fetchingQueue = new (_blockingQueue || _load_blockingQueue()).default('resolver fetching');\n    this.newPatterns = [];\n    this.patterns = (0, (_map || _load_map()).default)();\n    this.usedRegistries = new Set();\n    this.flat = false;\n\n    this.reporter = config.reporter;\n    this.lockfile = lockfile;\n    this.config = config;\n  }\n\n  // whether the dependency graph will be flattened\n\n\n  // list of registries that have been used in this resolution\n\n\n  // activity monitor\n\n\n  // patterns we've already resolved or are in the process of resolving\n\n\n  // new patterns that didn't exist in the lockfile\n\n\n  // TODO\n\n\n  // these are patterns that the package resolver was seeded with. these are required in\n  // order to resolve top level peerDependencies\n\n\n  // manages and throttles json api http requests\n\n\n  // list of patterns associated with a package\n\n\n  // lockfile instance which we can use to retrieve version info\n\n\n  // a map of dependency patterns to packages\n\n\n  // reporter instance, abstracts out display logic\n\n\n  // environment specific config methods and options\n\n\n  /**\n   * TODO description\n   */\n\n  isNewPattern(pattern) {\n    return this.newPatterns.indexOf(pattern) >= 0;\n  }\n\n  /**\n   * TODO description\n   */\n\n  updateManifest(ref, newPkg) {\n    // inherit fields\n    const oldPkg = this.patterns[ref.patterns[0]];\n    newPkg._reference = ref;\n    newPkg._remote = ref.remote;\n    newPkg.name = oldPkg.name;\n\n    // update patterns\n    for (const pattern of ref.patterns) {\n      this.patterns[pattern] = newPkg;\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a list of patterns, dedupe them to a list of unique patterns.\n   */\n\n  dedupePatterns(patterns) {\n    const deduped = [];\n    const seen = new Set();\n\n    for (const pattern of patterns) {\n      const info = this.getResolvedPattern(pattern);\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      deduped.push(pattern);\n    }\n\n    return deduped;\n  }\n\n  /**\n   * Get a list of all manifests by topological order.\n   */\n\n  getTopologicalManifests(seedPatterns) {\n    const pkgs = new Set();\n    const skip = new Set();\n\n    const add = seedPatterns => {\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n        skip.add(pkg);\n        add(ref.dependencies);\n        pkgs.add(pkg);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all manifests by level sort order.\n   */\n\n  getLevelOrderManifests(seedPatterns) {\n    const pkgs = new Set();\n    const skip = new Set();\n\n    const add = seedPatterns => {\n      const refs = [];\n\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n\n        refs.push(ref);\n        skip.add(pkg);\n        pkgs.add(pkg);\n      }\n\n      for (const ref of refs) {\n        add(ref.dependencies);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all package names in the depenency graph.\n   */\n\n  getAllDependencyNamesByLevelOrder(seedPatterns) {\n    const names = new Set();\n    for (const _ref of this.getLevelOrderManifests(seedPatterns)) {\n      const name = _ref.name;\n\n      names.add(name);\n    }\n    return names;\n  }\n\n  /**\n   * Retrieve all the package info stored for this package name.\n   */\n\n  getAllInfoForPackageName(name) {\n    const infos = [];\n    const seen = new Set();\n\n    for (const pattern of this.patternsByPackage[name]) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      infos.push(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * Get a flat list of all package references.\n   */\n\n  getPackageReferences() {\n    const refs = [];\n\n    for (const manifest of this.getManifests()) {\n      const ref = manifest._reference;\n      if (ref) {\n        refs.push(ref);\n      }\n    }\n\n    return refs;\n  }\n\n  /**\n   * Get a flat list of all package info.\n   */\n\n  getManifests() {\n    const infos = [];\n    const seen = new Set();\n\n    for (const pattern in this.patterns) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      infos.push(info);\n      seen.add(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * replace pattern in resolver, e.g. `name` is replaced with `name@^1.0.1`\n   */\n  replacePattern(pattern, newPattern) {\n    const pkg = this.getResolvedPattern(pattern);\n    invariant(pkg, `missing package ${pattern}`);\n    const ref = pkg._reference;\n    invariant(ref, 'expected package reference');\n    ref.patterns = [newPattern];\n    this.newPatterns.splice(this.newPatterns.indexOf(pattern), 1, newPattern);\n    this.addPattern(newPattern, pkg);\n    this.removePattern(pattern);\n  }\n\n  /**\n   * Make all versions of this package resolve to it.\n   */\n\n  collapseAllVersionsOfPackage(name, version) {\n    const patterns = this.dedupePatterns(this.patternsByPackage[name]);\n    const human = `${name}@${version}`;\n\n    // get manifest that matches the version we're collapsing too\n    let collapseToReference;\n    let collapseToManifest;\n    let collapseToPattern;\n    for (const pattern of patterns) {\n      const _manifest = this.patterns[pattern];\n      if (_manifest.version === version) {\n        collapseToReference = _manifest._reference;\n        collapseToManifest = _manifest;\n        collapseToPattern = pattern;\n        break;\n      }\n    }\n    invariant(collapseToReference && collapseToManifest && collapseToPattern, `Couldn't find package manifest for ${human}`);\n\n    for (const pattern of patterns) {\n      // don't touch the pattern we're collapsing to\n      if (pattern === collapseToPattern) {\n        continue;\n      }\n\n      // remove this pattern\n      const ref = this.getStrictResolvedPattern(pattern)._reference;\n      invariant(ref, 'expected package reference');\n      const refPatterns = ref.patterns.slice();\n      ref.prune();\n\n      // add pattern to the manifest we're collapsing to\n      for (const pattern of refPatterns) {\n        collapseToReference.addPattern(pattern, collapseToManifest);\n      }\n    }\n\n    return collapseToPattern;\n  }\n\n  /**\n   * TODO description\n   */\n\n  addPattern(pattern, info) {\n    this.patterns[pattern] = info;\n\n    const byName = this.patternsByPackage[info.name] = this.patternsByPackage[info.name] || [];\n    byName.push(pattern);\n  }\n\n  /**\n   * TODO description\n   */\n\n  removePattern(pattern) {\n    const pkg = this.patterns[pattern];\n    if (!pkg) {\n      return;\n    }\n\n    const byName = this.patternsByPackage[pkg.name];\n    if (!byName) {\n      return;\n    }\n\n    byName.splice(byName.indexOf(pattern), 1);\n    delete this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getResolvedPattern(pattern) {\n    return this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getStrictResolvedPattern(pattern) {\n    const manifest = this.getResolvedPattern(pattern);\n    invariant(manifest, 'expected manifest');\n    return manifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  getExactVersionMatch(name, version) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    for (const pattern of patterns) {\n      const info = this.getStrictResolvedPattern(pattern);\n      if (info.version === version) {\n        return info;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the manifest of the highest known version that satisfies a package range\n   */\n\n  getHighestRangeVersionMatch(name, range) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    const versionNumbers = [];\n    const resolvedPatterns = patterns.map(pattern => {\n      const info = this.getStrictResolvedPattern(pattern);\n      versionNumbers.push(info.version);\n\n      return info;\n    });\n\n    const maxValidRange = semver.maxSatisfying(versionNumbers, range);\n    if (!maxValidRange) {\n      return null;\n    }\n\n    const indexOfmaxValidRange = versionNumbers.indexOf(maxValidRange);\n    const maxValidRangeManifest = resolvedPatterns[indexOfmaxValidRange];\n\n    return maxValidRangeManifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  find(req) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const fetchKey = `${req.registry}:${req.pattern}`;\n      if (_this.fetchingPatterns[fetchKey]) {\n        return;\n      } else {\n        _this.fetchingPatterns[fetchKey] = true;\n      }\n\n      if (_this.activity) {\n        _this.activity.tick(req.pattern);\n      }\n\n      if (!_this.lockfile.getLocked(req.pattern, true)) {\n        _this.newPatterns.push(req.pattern);\n      }\n\n      const request = new (_packageRequest || _load_packageRequest()).default(req, _this);\n      yield request.find();\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  init(deps, isFlat) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this2.flat = isFlat;\n\n      //\n      const activity = _this2.activity = _this2.reporter.activity();\n\n      //\n      _this2.seedPatterns = deps.map(function (dep) {\n        return dep.pattern;\n      });\n\n      //\n      yield Promise.all(deps.map(function (req) {\n        return _this2.find(req);\n      }));\n\n      activity.end();\n      _this2.activity = null;\n    })();\n  }\n}\nexports.default = PackageResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/info.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (args.length > 2) {\n      reporter.error(reporter.lang('tooManyArguments', 2));\n      return;\n    }\n\n    let packageName = args.shift() || '.';\n\n    // Handle the case when we are referencing a local package.\n    if (packageName === '.') {\n      packageName = (yield config.readRootManifest()).name;\n    }\n\n    const packageInput = (_npmRegistry || _load_npmRegistry()).default.escapeName(packageName);\n\n    var _parsePackageName = (0, (_parsePackageName2 || _load_parsePackageName()).default)(packageInput);\n\n    const name = _parsePackageName.name,\n          version = _parsePackageName.version;\n\n\n    let result = yield config.registries.npm.request(name);\n    if (!result) {\n      reporter.error(reporter.lang('infoFail'));\n      return;\n    }\n\n    result = clean(result);\n\n    const versions = result.versions;\n    // $FlowFixMe\n    result.versions = Object.keys(versions).sort(semver.compareLoose);\n    result.version = version || result.versions[result.versions.length - 1];\n    result = Object.assign(result, versions[result.version]);\n\n    const fieldPath = args.shift();\n    const fields = fieldPath ? fieldPath.split('.') : [];\n\n    // Readmes can be long so exclude them unless explicitly asked for.\n    if (fields[0] !== 'readme') {\n      delete result.readme;\n    }\n\n    result = fields.reduce(function (prev, cur) {\n      return prev && prev[cur];\n    }, result);\n    reporter.inspect(result);\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nvar _parsePackageName2;\n\nfunction _load_parsePackageName() {\n  return _parsePackageName2 = _interopRequireDefault(require('../../util/parse-package-name.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst semver = require('semver');\n\nfunction clean(object) {\n  if (Array.isArray(object)) {\n    const result = [];\n    object.forEach(item => {\n      item = clean(item);\n      if (item) {\n        result.push(item);\n      }\n    });\n    return result;\n  } else if (typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      if (key.startsWith('_')) {\n        continue;\n      }\n\n      const item = clean(object[key]);\n      if (item) {\n        result[key] = item;\n      }\n    }\n    return result;\n  } else if (object) {\n    return object;\n  } else {\n    return null;\n  }\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/init.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getGitConfigInfo = exports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const manifests = yield config.getRootManifests();\n\n    let repository = {};\n    const author = {\n      name: config.getOption('init-author-name'),\n      email: config.getOption('init-author-email'),\n      url: config.getOption('init-author-url')\n    };\n    if (yield (_fs || _load_fs()).exists(path.join(config.cwd, '.git'))) {\n      // get git origin of the cwd\n      try {\n        repository = {\n          type: 'git',\n          url: yield (_child || _load_child()).spawn('git', ['config', 'remote.origin.url'], { cwd: config.cwd })\n        };\n      } catch (ex) {\n        // Ignore - Git repo may not have an origin URL yet (eg. if it only exists locally)\n      }\n\n      if (author.name === undefined) {\n        author.name = yield getGitConfigInfo('user.name');\n      }\n\n      if (author.email === undefined) {\n        author.email = yield getGitConfigInfo('user.email');\n      }\n    }\n\n    const keys = [{\n      key: 'name',\n      question: 'name',\n      default: path.basename(config.cwd),\n      validation: (_validate || _load_validate()).isValidPackageName,\n      validationError: 'invalidPackageName'\n    }, {\n      key: 'version',\n      question: 'version',\n      default: String(config.getOption('init-version'))\n    }, {\n      key: 'description',\n      question: 'description',\n      default: ''\n    }, {\n      key: 'main',\n      question: 'entry point',\n      default: 'index.js'\n    }, {\n      key: 'repository',\n      question: 'repository url',\n      default: (0, (_util || _load_util()).extractRepositoryUrl)(repository)\n    }, {\n      key: 'author',\n      question: 'author',\n      default: (0, (_util || _load_util()).stringifyPerson)(author)\n    }, {\n      key: 'license',\n      question: 'license',\n      default: String(config.getOption('init-license'))\n    }];\n\n    // get answers\n    const pkg = {};\n    for (const entry of keys) {\n      const yes = flags.yes;\n      const manifestKey = entry.key;\n      let question = entry.question,\n          def = entry.default;\n\n\n      for (const registryName of (_index || _load_index()).registryNames) {\n        const object = manifests[registryName].object;\n\n        let val = objectPath.get(object, manifestKey);\n        if (!val) {\n          break;\n        }\n        if (typeof val === 'object') {\n          if (manifestKey === 'author') {\n            val = (0, (_util || _load_util()).stringifyPerson)(val);\n          } else if (manifestKey === 'repository') {\n            val = (0, (_util || _load_util()).extractRepositoryUrl)(val);\n          }\n        }\n        def = val;\n      }\n\n      if (def) {\n        question += ` (${def})`;\n      }\n\n      let answer;\n      let validAnswer = false;\n\n      if (yes) {\n        answer = def;\n      } else {\n        // loop until a valid answer is provided, if validation is on entry\n        if (entry.validation) {\n          while (!validAnswer) {\n            answer = (yield reporter.question(question)) || def;\n            // validate answer\n            if (entry.validation(String(answer))) {\n              validAnswer = true;\n            } else {\n              reporter.error(reporter.lang('invalidPackageName'));\n            }\n          }\n        } else {\n          answer = (yield reporter.question(question)) || def;\n        }\n      }\n\n      if (answer) {\n        objectPath.set(pkg, manifestKey, answer);\n      }\n    }\n\n    // save answers\n    const targetManifests = [];\n    for (const registryName of (_index || _load_index()).registryNames) {\n      const info = manifests[registryName];\n      if (info.exists) {\n        targetManifests.push(info);\n      }\n    }\n    if (!targetManifests.length) {\n      targetManifests.push(manifests.npm);\n    }\n    for (const targetManifest of targetManifests) {\n      Object.assign(targetManifest.object, pkg);\n      reporter.success(`Saved ${path.basename(targetManifest.loc)}`);\n    }\n\n    yield config.saveRootManifests(manifests);\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet getGitConfigInfo = exports.getGitConfigInfo = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (credential) {\n    let spawn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_child || _load_child()).spawn;\n\n    try {\n      // try to get author default based on git config\n      return yield spawn('git', ['config', credential]);\n    } catch (e) {\n      return '';\n    }\n  });\n\n  return function getGitConfigInfo(_x5) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('../../util/normalize-manifest/util.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _child;\n\nfunction _load_child() {\n  return _child = _interopRequireWildcard(require('../../util/child.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = _interopRequireWildcard(require('../../util/normalize-manifest/validate.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst objectPath = require('object-path');\n\nconst path = require('path');\n\nfunction setFlags(commander) {\n  commander.option('-y, --yes', 'use default options');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/licenses.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet getManifests = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, flags) {\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const install = new (_install || _load_install()).Install((0, (_extends2 || _load_extends()).default)({ skipIntegrity: true }, flags), config, new (_baseReporter || _load_baseReporter()).default(), lockfile);\n    yield install.hydrate(true);\n\n    let manifests = install.resolver.getManifests();\n\n    // sort by name\n    manifests = manifests.sort(function (a, b) {\n      if (!a.name && !b.name) {\n        return 0;\n      }\n\n      if (!a.name) {\n        return 1;\n      }\n\n      if (!b.name) {\n        return -1;\n      }\n\n      return a.name.localeCompare(b.name);\n    });\n\n    // filter ignored manifests\n    manifests = manifests.filter(function (manifest) {\n      const ref = manifest._reference;\n      return !!ref && !ref.ignore;\n    });\n\n    return manifests;\n  });\n\n  return function getManifests(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nexports.hasWrapper = hasWrapper;\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('../../reporters/base-reporter.js'));\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nfunction hasWrapper(flags, args) {\n  return args[0] != 'generate-disclaimer';\n}\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('licenses', {\n  ls(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifests = yield getManifests(config, flags);\n\n      if (flags.json) {\n        const body = [];\n\n        for (const _ref2 of manifests) {\n          const name = _ref2.name,\n                version = _ref2.version,\n                license = _ref2.license,\n                repository = _ref2.repository,\n                homepage = _ref2.homepage;\n\n          const url = repository ? repository.url : homepage;\n          body.push([name, version, license || 'Unknown', url || 'Unknown']);\n        }\n\n        reporter.table(['Name', 'Version', 'License', 'URL'], body);\n      } else {\n        const trees = [];\n\n        for (const _ref3 of manifests) {\n          const name = _ref3.name,\n                version = _ref3.version,\n                license = _ref3.license,\n                repository = _ref3.repository,\n                homepage = _ref3.homepage;\n\n          const children = [];\n          children.push({ name: `${reporter.format.bold('License:')} ${license || reporter.format.red('UNKNOWN')}` });\n\n          const url = repository ? repository.url : homepage;\n          if (url) {\n            children.push({ name: `${reporter.format.bold('URL:')} ${url}` });\n          }\n\n          trees.push({\n            name: `${name}@${version}`,\n            children\n          });\n        }\n\n        reporter.tree('licenses', trees);\n      }\n    })();\n  },\n\n  generateDisclaimer(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifests = yield getManifests(config, flags);\n      const manifest = yield config.readRootManifest();\n\n      // Create a map of license text to manifest so that packages with exactly\n      // the same license text are grouped together.\n      const manifestsByLicense = new Map();\n      for (const manifest of manifests) {\n        const licenseText = manifest.licenseText;\n\n        if (!licenseText) {\n          continue;\n        }\n\n        if (!manifestsByLicense.has(licenseText)) {\n          manifestsByLicense.set(licenseText, new Map());\n        }\n\n        const byLicense = manifestsByLicense.get(licenseText);\n        invariant(byLicense, 'expected value');\n        byLicense.set(manifest.name, manifest);\n      }\n\n      console.log('THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED ' + `IN PORTIONS OF THE ${String(manifest.name).toUpperCase().replace(/-/g, ' ')} PRODUCT.`);\n      console.log();\n\n      for (const _ref4 of manifestsByLicense) {\n        var _ref5 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref4, 2);\n\n        const licenseText = _ref5[0];\n        const manifests = _ref5[1];\n\n        console.log('-----');\n        console.log();\n\n        const names = [];\n        const urls = [];\n        for (const _ref6 of manifests) {\n          var _ref7 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref6, 2);\n\n          const name = _ref7[0];\n          const repository = _ref7[1].repository;\n\n          names.push(name);\n          if (repository && repository.url) {\n            urls.push(manifests.size === 1 ? repository.url : `${repository.url} (${name})`);\n          }\n        }\n\n        const heading = [];\n        heading.push(`The following software may be included in this product: ${names.join(', ')}.`);\n        if (urls.length > 0) {\n          heading.push(`A copy of the source code may be downloaded from ${urls.join(', ')}.`);\n        }\n        heading.push('This software contains the following license and notice below:');\n\n        console.log(heading.join(' '));\n        console.log();\n\n        if (licenseText) {\n          console.log(licenseText.trim());\n        } else {\n          // what do we do here? base it on `license`?\n        }\n\n        console.log();\n      }\n    })();\n  }\n});\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/link.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.getRegistryFolder = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet getRegistryFolder = exports.getRegistryFolder = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, name) {\n    if (config.modulesFolder) {\n      return config.modulesFolder;\n    }\n\n    const src = path.join(config.linkFolder, name);\n\n    var _ref2 = yield config.readManifest(src);\n\n    const _registry = _ref2._registry;\n\n    invariant(_registry, 'expected registry');\n\n    const registryFolder = config.registries[_registry].folder;\n    return path.join(config.cwd, registryFolder);\n  });\n\n  return function getRegistryFolder(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (args.length) {\n      for (const name of args) {\n        const src = path.join(config.linkFolder, name);\n\n        if (yield (_fs || _load_fs()).exists(src)) {\n          const folder = yield getRegistryFolder(config, name);\n          const dest = path.join(folder, name);\n\n          yield (_fs || _load_fs()).unlink(dest);\n          yield (_fs || _load_fs()).mkdirp(path.dirname(dest));\n          yield (_fs || _load_fs()).symlink(src, dest);\n          reporter.success(reporter.lang('linkRegistered', name));\n        } else {\n          throw new (_errors || _load_errors()).MessageError(reporter.lang('linkMissing', name));\n        }\n      }\n    } else {\n      // add cwd module to the global registry\n      const manifest = yield config.readRootManifest();\n      const name = manifest.name;\n      if (!name) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('unknownPackageName'));\n      }\n\n      const linkLoc = path.join(config.linkFolder, name);\n      if (yield (_fs || _load_fs()).exists(linkLoc)) {\n        reporter.warn(reporter.lang('linkCollision', name));\n      } else {\n        yield (_fs || _load_fs()).mkdirp(path.dirname(linkLoc));\n        yield (_fs || _load_fs()).symlink(config.cwd, linkLoc);\n\n        // If there is a `bin` defined in the package.json,\n        // link each bin to the global bin\n        if (manifest.bin) {\n          const globalBinFolder = (0, (_global || _load_global()).getBinFolder)(config, flags);\n          for (const binName in manifest.bin) {\n            const binSrc = manifest.bin[binName];\n            const binSrcLoc = path.join(linkLoc, binSrc);\n            const binDestLoc = path.join(globalBinFolder, binName);\n            if (yield (_fs || _load_fs()).exists(binDestLoc)) {\n              reporter.warn(reporter.lang('binLinkCollision', binName));\n            } else {\n              yield (_fs || _load_fs()).symlink(binSrcLoc, binDestLoc);\n            }\n          }\n        }\n\n        reporter.success(reporter.lang('linkRegistered', name));\n        reporter.info(reporter.lang('linkInstallMessage', name));\n      }\n    }\n  });\n\n  return function run(_x3, _x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _global;\n\nfunction _load_global() {\n  return _global = require('./global');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst path = require('path');","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/login.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.getToken = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet getCredentials = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter) {\n    var _config$registries$ya = config.registries.yarn.config;\n    let username = _config$registries$ya.username,\n        email = _config$registries$ya.email;\n\n\n    if (username) {\n      reporter.info(`${reporter.lang('npmUsername')}: ${username}`);\n    } else {\n      username = yield reporter.question(reporter.lang('npmUsername'));\n      if (!username) {\n        return null;\n      }\n    }\n\n    if (email) {\n      reporter.info(`${reporter.lang('npmUsername')}: ${email}`);\n    } else {\n      email = yield reporter.question(reporter.lang('npmEmail'));\n      if (!email) {\n        return null;\n      }\n    }\n\n    yield config.registries.yarn.saveHomeConfig({ username, email });\n\n    return { username, email };\n  });\n\n  return function getCredentials(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet getToken = exports.getToken = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter) {\n    let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    const auth = config.registries.npm.getAuth(name);\n    if (auth) {\n      config.registries.npm.setToken(auth);\n      return function revoke() {\n        reporter.info(reporter.lang('notRevokingConfigToken'));\n        return Promise.resolve();\n      };\n    }\n\n    const env = process.env.YARN_AUTH_TOKEN || process.env.NPM_AUTH_TOKEN;\n    if (env) {\n      config.registries.npm.setToken(`Bearer ${env}`);\n      return function revoke() {\n        reporter.info(reporter.lang('notRevokingEnvToken'));\n        return Promise.resolve();\n      };\n    }\n\n    //\n    const creds = yield getCredentials(config, reporter);\n    if (!creds) {\n      reporter.warn(reporter.lang('loginAsPublic'));\n      return function revoke() {\n        reporter.info(reporter.lang('noTokenToRevoke'));\n        return Promise.resolve();\n      };\n    }\n\n    const username = creds.username,\n          email = creds.email;\n\n    const password = yield reporter.question(reporter.lang('npmPassword'), { password: true, required: true });\n\n    //\n    const userobj = {\n      _id: `org.couchdb.user:${username}`,\n      name: username,\n      password,\n      email,\n      type: 'user',\n      roles: [],\n      date: new Date().toISOString()\n    };\n\n    //\n    const res = yield config.registries.npm.request(`-/user/org.couchdb.user:${encodeURIComponent(username)}`, {\n      method: 'PUT',\n      body: userobj,\n      auth: { username, password, email }\n    });\n\n    if (res && res.ok) {\n      reporter.success(reporter.lang('loggedIn'));\n\n      const token = res.token;\n      config.registries.npm.setToken(`Bearer ${token}`);\n\n      return (() => {\n        var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n          reporter.success(reporter.lang('revokedToken'));\n          yield config.registries.npm.request(`-/user/token/${token}`, {\n            method: 'DELETE'\n          });\n        });\n\n        function revoke() {\n          return _ref3.apply(this, arguments);\n        }\n\n        return revoke;\n      })();\n    } else {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('incorrectCredentials'));\n    }\n  });\n\n  return function getToken(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    yield getCredentials(config, reporter);\n  });\n\n  return function run(_x6, _x7, _x8, _x9) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/logout.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    yield config.registries.yarn.saveHomeConfig({\n      username: undefined,\n      email: undefined\n    });\n\n    reporter.success(reporter.lang('clearedCredentials'));\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/list.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.buildTree = exports.requireLockfile = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet buildTree = exports.buildTree = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (resolver, linker, patterns, opts, onlyFresh, ignoreHoisted) {\n    const treesByKey = {};\n    const trees = [];\n    const hoisted = yield linker.getFlatHoistedTree(patterns);\n\n    const hoistedByKey = {};\n    for (const _ref2 of hoisted) {\n      var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 2);\n\n      const key = _ref3[0];\n      const info = _ref3[1];\n\n      hoistedByKey[key] = info;\n    }\n\n    // build initial trees\n    for (const _ref4 of hoisted) {\n      var _ref5 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref4, 2);\n\n      const info = _ref5[1];\n\n      const ref = info.pkg._reference;\n      const hint = null;\n      const parent = getParent(info.key, treesByKey);\n      const children = [];\n      let depth = 0;\n      let color = 'bold';\n      invariant(ref, 'expected reference');\n\n      if (onlyFresh) {\n        let isFresh = false;\n        for (const pattern of ref.patterns) {\n          if (resolver.isNewPattern(pattern)) {\n            isFresh = true;\n            break;\n          }\n        }\n        if (!isFresh) {\n          continue;\n        }\n      }\n\n      if (info.originalKey !== info.key || opts.reqDepth === 0) {\n        // was hoisted\n        color = null;\n      }\n      // check parent to obtain next depth\n      if (parent && parent.depth > 0) {\n        depth = parent.depth + 1;\n      } else {\n        depth = 0;\n      }\n\n      const topLevel = opts.reqDepth === 0 && !parent;\n      const showAll = opts.reqDepth === -1;\n      const nextDepthIsValid = depth + 1 <= Number(opts.reqDepth);\n\n      if (topLevel || nextDepthIsValid || showAll) {\n        treesByKey[info.key] = {\n          name: `${info.pkg.name}@${info.pkg.version}`,\n          children,\n          hint,\n          color,\n          depth\n        };\n      }\n\n      // add in dummy children for hoisted dependencies\n      const nextChildDepthIsValid = depth + 1 < Number(opts.reqDepth);\n      invariant(ref, 'expected reference');\n      if (!ignoreHoisted && nextDepthIsValid || showAll) {\n        for (const pattern of resolver.dedupePatterns(ref.dependencies)) {\n          const pkg = resolver.getStrictResolvedPattern(pattern);\n\n          if (!hoistedByKey[`${info.key}#${pkg.name}`] && (nextChildDepthIsValid || showAll)) {\n            children.push({\n              name: pattern,\n              color: 'dim',\n              shadow: true\n            });\n          }\n        }\n      }\n    }\n\n    // add children\n    for (const _ref6 of hoisted) {\n      var _ref7 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref6, 2);\n\n      const info = _ref7[1];\n\n      const tree = treesByKey[info.key];\n      const parent = getParent(info.key, treesByKey);\n      if (!tree) {\n        continue;\n      }\n\n      if (info.key.split('#').length === 1) {\n        trees.push(tree);\n        continue;\n      }\n\n      if (parent) {\n        parent.children.push(tree);\n      }\n    }\n\n    return { trees, count: buildCount(trees) };\n  });\n\n  return function buildTree(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd, reporter);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n\n    var _ref9 = yield install.fetchRequestFromCwd();\n\n    const depRequests = _ref9.requests,\n          patterns = _ref9.patterns;\n\n    yield install.resolver.init(depRequests, install.flags.flat);\n\n    const opts = {\n      reqDepth: getReqDepth(flags.depth)\n    };\n\n    var _ref10 = yield buildTree(install.resolver, install.linker, patterns, opts);\n\n    let trees = _ref10.trees;\n\n\n    if (args.length) {\n      trees = trees.filter(function (tree) {\n        return filterTree(tree, args);\n      });\n    }\n\n    reporter.tree('list', trees);\n  });\n\n  return function run(_x7, _x8, _x9, _x10) {\n    return _ref8.apply(this, arguments);\n  };\n})();\n\nexports.getParent = getParent;\nexports.setFlags = setFlags;\nexports.getReqDepth = getReqDepth;\nexports.filterTree = filterTree;\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst requireLockfile = exports.requireLockfile = true;\n\nfunction buildCount(trees) {\n  if (!trees || !trees.length) {\n    return 0;\n  }\n\n  let count = 0;\n\n  for (const tree of trees) {\n    if (tree.shadow) {\n      continue;\n    }\n\n    count++;\n    count += buildCount(tree.children);\n  }\n\n  return count;\n}\n\nfunction getParent(key, treesByKey) {\n  const parentKey = key.split('#').slice(0, -1).join('#');\n  return treesByKey[parentKey];\n}\n\nfunction setFlags(commander) {\n  commander.option('--depth [depth]', 'Limit the depth of the shown dependencies');\n}\n\nfunction getReqDepth(inputDepth) {\n  return inputDepth && /^\\d+$/.test(inputDepth) ? Number(inputDepth) : -1;\n}\n\nfunction filterTree(tree, filters) {\n  if (tree.children) {\n    tree.children = tree.children.filter(child => filterTree(child, filters));\n  }\n\n  const notDim = tree.color !== 'dim';\n  const found = filters.indexOf(tree.name.slice(0, tree.name.lastIndexOf('@'))) > -1;\n  const hasChildren = tree.children == null ? false : tree.children.length > 0;\n\n  return notDim && (found || hasChildren);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/outdated.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.requireLockfile = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n    let deps = yield (_packageRequest || _load_packageRequest()).default.getOutdatedPackages(lockfile, install, config, reporter);\n\n    if (args.length) {\n      const requested = new Set(args);\n\n      deps = deps.filter(function (_ref2) {\n        let name = _ref2.name;\n        return requested.has(name);\n      });\n    }\n\n    const getNameFromHint = function (hint) {\n      return hint ? `${hint}Dependencies` : 'dependencies';\n    };\n    const getColorFromVersion = function (_ref3) {\n      let current = _ref3.current,\n          wanted = _ref3.wanted,\n          name = _ref3.name;\n      return current === wanted ? reporter.format.yellow(name) : reporter.format.red(name);\n    };\n\n    if (deps.length) {\n      const body = deps.map(function (info) {\n        return [getColorFromVersion(info), info.current, reporter.format.green(info.wanted), reporter.format.magenta(info.latest), getNameFromHint(info.hint), reporter.format.cyan(info.url)];\n      });\n\n      reporter.table(['Package', 'Current', 'Wanted', 'Latest', 'Package Type', 'URL'], body);\n    }\n\n    return Promise.resolve();\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst requireLockfile = exports.requireLockfile = true;\n\nfunction setFlags(commander) {\n  commander.usage('outdated [packages ...]');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/owner.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = exports.mutate = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet mutate = exports.mutate = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (args, config, reporter, buildMessages, mutator) {\n    if (args.length !== 2 && args.length !== 1) {\n      return false;\n    }\n\n    const username = args.shift();\n    const name = yield (0, (_tag || _load_tag()).getName)(args, config);\n    if (!(0, (_validate || _load_validate()).isValidPackageName)(name)) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidPackageName'));\n    }\n\n    const msgs = buildMessages(username, name);\n    reporter.step(1, 3, reporter.lang('loggingIn'));\n    const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, name);\n\n    reporter.step(2, 3, msgs.info);\n    const user = yield config.registries.npm.request(`-/user/org.couchdb.user:${username}`);\n    let error = false;\n    if (user) {\n      // get package\n      const pkg = yield config.registries.npm.request((_npmRegistry || _load_npmRegistry()).default.escapeName(name));\n      if (pkg) {\n        pkg.maintainers = pkg.maintainers || [];\n        error = mutator({ name: user.name, email: user.email }, pkg);\n      } else {\n        error = true;\n        reporter.error(reporter.lang('unknownPackage', name));\n      }\n\n      // update package\n      if (pkg && !error) {\n        const res = yield config.registries.npm.request(`${(_npmRegistry || _load_npmRegistry()).default.escapeName(name)}/-rev/${pkg._rev}`, {\n          method: 'PUT',\n          body: {\n            _id: pkg._id,\n            _rev: pkg._rev,\n            maintainers: pkg.maintainers\n          }\n        });\n\n        if (res != null && res.success) {\n          reporter.success(msgs.success);\n        } else {\n          error = true;\n          reporter.error(msgs.error);\n        }\n      }\n    } else {\n      error = true;\n      reporter.error(reporter.lang('unknownUser', username));\n    }\n\n    reporter.step(3, 3, reporter.lang('revokingToken'));\n    yield revoke();\n\n    if (error) {\n      throw new Error();\n    } else {\n      return true;\n    }\n  });\n\n  return function mutate(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = require('../../util/normalize-manifest/validate.js');\n}\n\nvar _tag;\n\nfunction _load_tag() {\n  return _tag = require('./tag.js');\n}\n\nvar _login;\n\nfunction _load_login() {\n  return _login = require('./login.js');\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('owner', {\n  add(config, reporter, flags, args) {\n    return mutate(args, config, reporter, (username, name) => ({\n      info: reporter.lang('ownerAdding', username, name),\n      success: reporter.lang('ownerAdded'),\n      error: reporter.lang('ownerAddingFailed')\n    }), (user, pkg) => {\n      for (const owner of pkg.maintainers) {\n        if (owner.name === user) {\n          reporter.error(reporter.lang('ownerAlready'));\n          return true;\n        }\n      }\n\n      pkg.maintainers.push(user);\n\n      return false;\n    });\n  },\n\n  rm(config, reporter, flags, args) {\n    return mutate(args, config, reporter, (username, name) => ({\n      info: reporter.lang('ownerRemoving', username, name),\n      success: reporter.lang('ownerRemoved'),\n      error: reporter.lang('ownerRemoveError')\n    }), (user, pkg) => {\n      let found = false;\n\n      pkg.maintainers = pkg.maintainers.filter(o => {\n        const match = o.name === user.name;\n        found = found || match;\n        return !match;\n      });\n\n      if (!found) {\n        reporter.error(reporter.lang('userNotAnOwner', user.name));\n      }\n\n      return found;\n    });\n  },\n\n  ls(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (args.length > 1) {\n        return false;\n      }\n\n      const name = yield (0, (_tag || _load_tag()).getName)(args, config);\n\n      reporter.step(1, 3, reporter.lang('loggingIn'));\n      const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, name);\n\n      reporter.step(2, 3, reporter.lang('ownerGetting', name));\n      const pkg = yield config.registries.npm.request(name);\n      if (pkg) {\n        const owners = pkg.maintainers;\n        if (!owners || !owners.length) {\n          reporter.warn(reporter.lang('ownerNone'));\n        } else {\n          for (const owner of owners) {\n            reporter.info(`${owner.name} <${owner.email}>`);\n          }\n        }\n      } else {\n        reporter.error(reporter.lang('ownerGettingFailed'));\n      }\n\n      reporter.step(3, 3, reporter.lang('revokingToken'));\n      yield revoke();\n\n      if (pkg) {\n        return true;\n      } else {\n        throw new Error();\n      }\n    })();\n  }\n}, ['add <user> [[<@scope>/]<pkg>]', 'rm <user> [[<@scope>/]<pkg>]', 'ls [<@scope>/]<pkg>']);\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/pack.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.pack = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet pack = exports.pack = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, dir) {\n    const pkg = yield config.readRootManifest();\n    const bundledDependencies = pkg.bundledDependencies,\n          onlyFiles = pkg.files;\n\n    // inlude required files\n\n    let filters = NEVER_IGNORE.slice();\n    // include default filters unless `files` is used\n    if (!onlyFiles) {\n      filters = filters.concat(DEFAULT_IGNORE);\n    }\n\n    // include bundledDependencies\n    if (bundledDependencies) {\n      const folder = config.getFolder(pkg);\n      filters = (0, (_filter || _load_filter()).ignoreLinesToRegex)(bundledDependencies.map(function (name) {\n        return `!${folder}/${name}`;\n      }), '.');\n    }\n\n    // `files` field\n    if (onlyFiles) {\n      let lines = ['*', // ignore all files except those that are explicitly included with a negation filter\n      '.*'];\n      lines = lines.concat(onlyFiles.map(function (filename) {\n        return `!${filename}`;\n      }));\n      const regexes = (0, (_filter || _load_filter()).ignoreLinesToRegex)(lines, '.');\n      filters = filters.concat(regexes);\n    }\n\n    //\n    const files = yield (_fs || _load_fs()).walk(config.cwd, null, new Set(FOLDERS_IGNORE));\n\n    // create ignores\n    for (const file of files) {\n      if (IGNORE_FILENAMES.indexOf(path.basename(file.relative)) >= 0) {\n        const raw = yield (_fs || _load_fs()).readFile(file.absolute);\n        const lines = raw.split('\\n');\n\n        const regexes = (0, (_filter || _load_filter()).ignoreLinesToRegex)(lines, path.dirname(file.relative));\n        filters = filters.concat(regexes);\n      }\n    }\n\n    // files to definently keep, takes precedence over ignore filter\n    const keepFiles = new Set();\n\n    // files to definently ignore\n    const ignoredFiles = new Set();\n\n    // list of files that didn't match any of our patterns, if a directory in the chain above was matched\n    // then we should inherit it\n    const possibleKeepFiles = new Set();\n\n    // apply filters\n    (0, (_filter || _load_filter()).sortFilter)(files, filters, keepFiles, possibleKeepFiles, ignoredFiles);\n\n    const packer = tar.pack();\n    const compressor = packer.pipe(new zlib.Gzip());\n\n    yield addEntry(packer, {\n      name: 'package',\n      type: 'directory'\n    });\n\n    for (const name of keepFiles) {\n      const loc = path.join(config.cwd, name);\n      const stat = yield (_fs || _load_fs()).lstat(loc);\n\n      let type;\n      let buffer;\n      let linkname;\n      if (stat.isDirectory()) {\n        type = 'directory';\n      } else if (stat.isFile()) {\n        buffer = yield (_fs || _load_fs()).readFileRaw(loc);\n        type = 'file';\n      } else if (stat.isSymbolicLink()) {\n        type = 'symlink';\n        linkname = yield (_fs || _load_fs()).readlink(loc);\n      } else {\n        throw new Error();\n      }\n\n      const entry = {\n        name: `package/${name}`,\n        size: stat.size,\n        mode: stat.mode,\n        mtime: stat.mtime,\n        type,\n        linkname\n      };\n\n      yield addEntry(packer, entry, buffer);\n    }\n\n    packer.finalize();\n\n    return compressor;\n  });\n\n  return function pack(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const pkg = yield config.readRootManifest();\n    if (!pkg.name) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('noName'));\n    }\n    if (!pkg.version) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('noVersion'));\n    }\n\n    const normaliseScope = function (name) {\n      return name[0] === '@' ? name.substr(1).replace('/', '-') : name;\n    };\n    const filename = flags.filename || path.join(config.cwd, `${normaliseScope(pkg.name)}-v${pkg.version}.tgz`);\n\n    const stream = yield pack(config, config.cwd);\n\n    yield new Promise(function (resolve, reject) {\n      stream.pipe(fs2.createWriteStream(filename));\n      stream.on('error', reject);\n      stream.on('close', resolve);\n    });\n\n    reporter.success(reporter.lang('packWroteTarball', filename));\n  });\n\n  return function run(_x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _filter;\n\nfunction _load_filter() {\n  return _filter = require('../../util/filter.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst zlib = require('zlib');\nconst path = require('path');\nconst tar = require('tar-stream');\nconst fs2 = require('fs');\n\nconst IGNORE_FILENAMES = ['.yarnignore', '.npmignore', '.gitignore'];\n\nconst FOLDERS_IGNORE = [\n// never allow version control folders\n'.git', 'CVS', '.svn', '.hg', 'node_modules'];\n\nconst DEFAULT_IGNORE = (0, (_filter || _load_filter()).ignoreLinesToRegex)([...FOLDERS_IGNORE,\n\n// ignore cruft\n'yarn.lock', '.lock-wscript', '.wafpickle-{0..9}', '*.swp', '._*', 'npm-debug.log', 'yarn-error.log', '.npmrc', '.yarnrc', '.npmignore', '.gitignore', '.DS_Store']);\n\nconst NEVER_IGNORE = (0, (_filter || _load_filter()).ignoreLinesToRegex)([\n// never ignore these files\n'!/package.json', '!/readme*', '!/+(license|licence)*', '!/+(changes|changelog|history)*']);\n\nfunction addEntry(packer, entry, buffer) {\n  return new Promise((resolve, reject) => {\n    packer.entry(entry, buffer, function (err) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction setFlags(commander) {\n  commander.option('-f, --filename <filename>', 'filename');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/filter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortFilter = sortFilter;\nexports.matchesFilter = matchesFilter;\nexports.ignoreLinesToRegex = ignoreLinesToRegex;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./misc.js');\n}\n\nconst minimatch = require('minimatch');\nconst path = require('path');\n\nconst WHITESPACE_RE = /^\\s+$/;\n\nfunction sortFilter(files, filters) {\n  let keepFiles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  let possibleKeepFiles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n  let ignoreFiles = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Set();\n\n  for (const file of files) {\n    let keep = false;\n\n    // always keep a file if a ! pattern matches it\n    for (const filter of filters) {\n      if (filter.isNegation && matchesFilter(filter, file.basename, file.relative)) {\n        keep = true;\n        break;\n      }\n    }\n\n    //\n    if (keep) {\n      keepFiles.add(file.relative);\n      continue;\n    }\n\n    // otherwise don't keep it if a pattern matches it\n    keep = true;\n    for (const filter of filters) {\n      if (!filter.isNegation && matchesFilter(filter, file.basename, file.relative)) {\n        keep = false;\n        break;\n      }\n    }\n\n    if (keep) {\n      possibleKeepFiles.add(file.relative);\n    } else {\n      ignoreFiles.add(file.relative);\n    }\n  }\n\n  // exclude file\n  for (const file of possibleKeepFiles) {\n    const parts = path.dirname(file).split(path.sep);\n\n    while (parts.length) {\n      const folder = parts.join(path.sep);\n      if (ignoreFiles.has(folder)) {\n        ignoreFiles.add(file);\n        break;\n      }\n      parts.pop();\n    }\n  }\n\n  //\n  for (const file of possibleKeepFiles) {\n    if (!ignoreFiles.has(file)) {\n      keepFiles.add(file);\n    }\n  }\n\n  //\n  for (const file of keepFiles) {\n    const parts = path.dirname(file).split(path.sep);\n\n    while (parts.length) {\n      // deregister this folder from being ignored, any files inside\n      // will still be marked as ignored\n      ignoreFiles.delete(parts.join(path.sep));\n      parts.pop();\n    }\n  }\n\n  return { keepFiles, ignoreFiles };\n}\n\nfunction matchesFilter(filter, basename, loc) {\n  if (filter.base && filter.base !== '.') {\n    loc = path.relative(filter.base, loc);\n  }\n  return filter.regex.test(loc) || filter.regex.test(`/${loc}`) || filter.regex.test(basename);\n}\n\nfunction ignoreLinesToRegex(lines) {\n  let base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n\n  return lines\n  // create regex\n  .map(line => {\n    // remove empty lines, comments, etc\n    if (line === '' || line === '!' || line[0] === '#' || WHITESPACE_RE.test(line)) {\n      return null;\n    }\n\n    let pattern = line;\n    let isNegation = false;\n\n    // hide the fact that it's a negation from minimatch since we'll handle this specifally\n    // ourselves\n    if (pattern[0] === '!') {\n      isNegation = true;\n      pattern = pattern.slice(1);\n    }\n\n    // remove trailing slash\n    pattern = (0, (_misc || _load_misc()).removeSuffix)(pattern, '/');\n\n    const regex = minimatch.makeRe(pattern, { nocase: true });\n\n    if (regex) {\n      return {\n        base,\n        isNegation,\n        regex\n      };\n    } else {\n      return null;\n    }\n  }).filter(Boolean);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/publish.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet publish = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, pkg, flags, dir) {\n    // validate access argument\n    const access = flags.access;\n    if (access && access !== 'public' && access !== 'restricted') {\n      throw new (_errors || _load_errors()).MessageError(config.reporter.lang('invalidAccess'));\n    }\n\n    // get tarball stream\n    const stat = yield (_fs || _load_fs()).lstat(dir);\n    let stream;\n    if (stat.isDirectory()) {\n      stream = yield (0, (_pack || _load_pack()).pack)(config, dir);\n    } else if (stat.isFile()) {\n      stream = fs2.createReadStream(dir);\n    } else {\n      throw new Error(\"Don't know how to handle this file type\");\n    }\n    invariant(stream, 'expected stream');\n    const buffer = yield new Promise(function (resolve, reject) {\n      stream.pipe(new (_stream || _load_stream()).ConcatStream(resolve)).on('error', reject);\n    });\n\n    // copy normalized package and remove internal keys as they may be sensitive or yarn specific\n    pkg = Object.assign({}, pkg);\n    for (const key in pkg) {\n      if (key[0] === '_') {\n        delete pkg[key];\n      }\n    }\n\n    const tag = flags.tag || 'latest';\n    const tbName = `${pkg.name}-${pkg.version}.tgz`;\n    const tbURI = `${pkg.name}/-/${tbName}`;\n\n    // TODO this might modify package.json, do we need to reload it?\n    yield config.executeLifecycleScript('prepublish');\n\n    // create body\n    const root = {\n      _id: pkg.name,\n      access: flags.access,\n      name: pkg.name,\n      description: pkg.description,\n      'dist-tags': {\n        [tag]: pkg.version\n      },\n      versions: {\n        [pkg.version]: pkg\n      },\n      readme: pkg.readme || '',\n      _attachments: {\n        [tbName]: {\n          'content_type': 'application/octet-stream',\n          data: buffer.toString('base64'),\n          length: buffer.length\n        }\n      }\n    };\n\n    pkg._id = `${pkg.name}@${pkg.version}`;\n    pkg.dist = pkg.dist || {};\n    pkg.dist.shasum = crypto.createHash('sha1').update(buffer).digest('hex');\n\n    const registry = String(config.getOption('registry'));\n    pkg.dist.tarball = url.resolve(registry, tbURI).replace(/^https:\\/\\//, 'http://');\n\n    // publish package\n    const res = yield config.registries.npm.request((_npmRegistry || _load_npmRegistry()).default.escapeName(pkg.name), {\n      method: 'PUT',\n      body: root\n    });\n\n    if (res != null && res.success) {\n      yield config.executeLifecycleScript('publish');\n      yield config.executeLifecycleScript('postpublish');\n    } else {\n      throw new (_errors || _load_errors()).MessageError(config.reporter.lang('publishFail'));\n    }\n  });\n\n  return function publish(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    // validate package fields that are required for publishing\n    const pkg = yield config.readRootManifest();\n    if (pkg.private) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('publishPrivate'));\n    }\n    if (!pkg.name) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('noName'));\n    }\n\n    // validate arguments\n    const dir = args[0] || config.cwd;\n    if (args.length > 1) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('tooManyArguments', 1));\n    }\n    if (!(yield (_fs || _load_fs()).exists(dir))) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('unknownFolderOrTarball'));\n    }\n\n    //\n    reporter.step(1, 4, reporter.lang('bumpingVersion'));\n    const commitVersion = yield (0, (_version || _load_version()).setVersion)(config, reporter, flags, args, false);\n\n    //\n    reporter.step(2, 4, reporter.lang('loggingIn'));\n    const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, pkg.name);\n\n    //\n    reporter.step(3, 4, reporter.lang('publishing'));\n    yield publish(config, pkg, flags, dir);\n    yield commitVersion();\n    reporter.success(reporter.lang('published'));\n\n    //\n    reporter.step(4, 4, reporter.lang('revokingToken'));\n    yield revoke();\n  });\n\n  return function run(_x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nvar _stream;\n\nfunction _load_stream() {\n  return _stream = require('../../util/stream.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = require('./version.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _pack;\n\nfunction _load_pack() {\n  return _pack = require('./pack.js');\n}\n\nvar _login;\n\nfunction _load_login() {\n  return _login = require('./login.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst crypto = require('crypto');\nconst url = require('url');\nconst fs2 = require('fs');\n\nfunction setFlags(commander) {\n  (0, (_version || _load_version()).setFlags)(commander);\n  commander.usage('publish [<tarball>|<folder>] [--tag <tag>] [--access <public|restricted>]');\n  commander.option('--access [access]', 'access');\n  commander.option('--tag [tag]', 'tag');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/remove.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.requireLockfile = undefined;\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (!args.length) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('tooFewArguments', 1));\n    }\n\n    const totalSteps = args.length + 1;\n    let step = 0;\n\n    // load manifests\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const rootManifests = yield config.getRootManifests();\n    const manifests = [];\n\n    for (const name of args) {\n      reporter.step(++step, totalSteps, `Removing module ${name}`);\n\n      let found = false;\n\n      for (const registryName of Object.keys((_index || _load_index()).registries)) {\n        const registry = config.registries[registryName];\n        const object = rootManifests[registryName].object;\n\n        for (const type of (_constants || _load_constants()).DEPENDENCY_TYPES) {\n          const deps = object[type];\n          if (deps && deps[name]) {\n            found = true;\n            delete deps[name];\n          }\n        }\n\n        const possibleManifestLoc = path.join(config.cwd, registry.folder, name);\n        if (yield (_fs || _load_fs()).exists(possibleManifestLoc)) {\n          manifests.push([possibleManifestLoc, yield config.readManifest(possibleManifestLoc, registryName)]);\n        }\n      }\n\n      if (!found) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('moduleNotInManifest'));\n      }\n    }\n\n    // save manifests\n    yield config.saveRootManifests(rootManifests);\n\n    // run hooks - npm runs these one after another\n    for (const action of ['preuninstall', 'uninstall', 'postuninstall']) {\n      for (const _ref2 of manifests) {\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 1);\n\n        const loc = _ref3[0];\n\n        yield config.executeLifecycleScript(action, loc);\n      }\n    }\n\n    // reinstall so we can get the updated lockfile\n    reporter.step(++step, totalSteps, reporter.lang('uninstallRegenerate'));\n    const reinstall = new (_install || _load_install()).Install((0, (_extends2 || _load_extends()).default)({ force: true }, flags), config, new (_index2 || _load_index2()).NoopReporter(), lockfile);\n    yield reinstall.init();\n\n    //\n    reporter.success(reporter.lang('uninstalledPackages'));\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('../../reporters/index.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../../constants.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst requireLockfile = exports.requireLockfile = true;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/run.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    let runCommand = (() => {\n      var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (args) {\n        const action = args.shift();\n        const actions = [`pre${action}`, action, `post${action}`];\n\n        // build up list of commands\n        const cmds = [];\n        for (const action of actions) {\n          const cmd = scripts[action];\n          if (cmd) {\n            cmds.push([action, cmd]);\n          }\n        }\n\n        if (cmds.length) {\n          for (const _ref3 of cmds) {\n            var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 2);\n\n            const stage = _ref4[0];\n            const cmd = _ref4[1];\n\n            // only tack on trailing arguments for default script, ignore for pre and post - #1595\n            const defaultScriptCmd = `${cmd} ${sanitizedArgs(args).join(' ')}`;\n            const cmdWithArgs = stage === action ? defaultScriptCmd : cmd;\n            yield (0, (_executeLifecycleScript || _load_executeLifecycleScript()).execCommand)(stage, config, cmdWithArgs, config.cwd);\n          }\n        } else {\n          let suggestion;\n\n          for (const commandName in scripts) {\n            const steps = leven(commandName, action);\n            if (steps < 2) {\n              suggestion = commandName;\n            }\n          }\n\n          let msg = `Command ${JSON.stringify(action)} not found.`;\n          if (suggestion) {\n            msg += ` Did you mean ${JSON.stringify(suggestion)}?`;\n          }\n          throw new (_errors || _load_errors()).MessageError(msg);\n        }\n      });\n\n      return function runCommand(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    })();\n\n    // list possible scripts if none specified\n\n\n    // build up a list of possible scripts\n    const pkg = yield config.readManifest(config.cwd);\n    const scripts = (0, (_map || _load_map()).default)();\n    const binCommands = [];\n    const visitedBinFolders = new Set();\n    let pkgCommands = [];\n    for (const registry of Object.keys((_index || _load_index()).registries)) {\n      const binFolder = path.join(config.cwd, config.registries[registry].folder, '.bin');\n      if (!visitedBinFolders.has(binFolder)) {\n        if (yield (_fs || _load_fs()).exists(binFolder)) {\n          for (const name of yield (_fs || _load_fs()).readdir(binFolder)) {\n            binCommands.push(name);\n            scripts[name] = `\"${path.join(binFolder, name)}\"`;\n          }\n        }\n        visitedBinFolders.add(binFolder);\n      }\n    }\n    const pkgScripts = pkg.scripts;\n    const cmdHints = {};\n    if (pkgScripts) {\n      // inherit `scripts` from manifest\n      pkgCommands = Object.keys(pkgScripts).sort();\n\n      // add command hints (what the actual yarn command will do)\n      for (const cmd of pkgCommands) {\n        cmdHints[cmd] = pkgScripts[cmd] || '';\n      }\n\n      Object.assign(scripts, pkg.scripts);\n    }\n\n    if (args.length === 0) {\n      reporter.error(reporter.lang('commandNotSpecified'));\n      reporter.info(`${reporter.lang('binCommands') + binCommands.join(', ')}`);\n      reporter.info(`${reporter.lang('possibleCommands')}`);\n      reporter.list('possibleCommands', pkgCommands, cmdHints);\n      yield reporter.question(reporter.lang('commandQuestion')).then(function (answer) {\n        return runCommand(answer.split(' '));\n      }, function () {\n        return reporter.error(reporter.lang('commandNotSpecified'));\n      });\n      return Promise.resolve();\n    } else {\n      return yield runCommand(args);\n    }\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = require('../../util/execute-lifecycle-script.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../resolvers/index.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../../util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst leven = require('leven');\n\nconst path = require('path');\n\nfunction sanitizedArgs(args) {\n  const newArgs = [];\n  for (let arg of args) {\n    if (/\\s/.test(arg)) {\n      arg = `\"${arg}\"`;\n    }\n    newArgs.push(arg);\n  }\n  return newArgs;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/tag.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.examples = exports.setFlags = exports.run = exports.getName = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet getName = exports.getName = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (args, config) {\n    let name = args.shift();\n\n    if (!name) {\n      const pkg = yield config.readRootManifest();\n      name = pkg.name;\n    }\n\n    if (name) {\n      if (!(0, (_validate || _load_validate()).isValidPackageName)(name)) {\n        throw new (_errors || _load_errors()).MessageError(config.reporter.lang('invalidPackageName'));\n      }\n\n      return (_npmRegistry || _load_npmRegistry()).default.escapeName(name);\n    } else {\n      throw new (_errors || _load_errors()).MessageError(config.reporter.lang('unknownPackageName'));\n    }\n  });\n\n  return function getName(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nvar _login;\n\nfunction _load_login() {\n  return _login = require('./login.js');\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = require('../../util/normalize-manifest/validate.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('tag', {\n  add(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (args.length !== 2) {\n        return false;\n      }\n\n      var _PackageRequest$norma = (_packageRequest || _load_packageRequest()).default.normalizePattern(args.shift());\n\n      const name = _PackageRequest$norma.name,\n            range = _PackageRequest$norma.range,\n            hasVersion = _PackageRequest$norma.hasVersion;\n\n      if (!hasVersion) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('requiredVersionInRange'));\n      }\n      if (!(0, (_validate || _load_validate()).isValidPackageName)(name)) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidPackageName'));\n      }\n\n      const tag = args.shift();\n\n      reporter.step(1, 3, reporter.lang('loggingIn'));\n      const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, name);\n\n      reporter.step(2, 3, reporter.lang('creatingTag', tag, range));\n      const result = yield config.registries.npm.request(`-/package/${(_npmRegistry || _load_npmRegistry()).default.escapeName(name)}/dist-tags/${encodeURI(tag)}`, {\n        method: 'PUT',\n        body: range\n      });\n\n      if (result != null && result.ok) {\n        reporter.success(reporter.lang('createdTag'));\n      } else {\n        reporter.error(reporter.lang('createdTagFail'));\n      }\n\n      reporter.step(3, 3, reporter.lang('revokingToken'));\n      yield revoke();\n\n      if (result != null && result.ok) {\n        return true;\n      } else {\n        throw new Error();\n      }\n    })();\n  },\n\n  rm(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (args.length !== 2) {\n        return false;\n      }\n\n      const name = yield getName(args, config);\n      const tag = args.shift();\n\n      reporter.step(1, 3, reporter.lang('loggingIn'));\n      const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, name);\n\n      reporter.step(2, 3, reporter.lang('deletingTags'));\n      const result = yield config.registries.npm.request(`-/package/${name}/dist-tags/${encodeURI(tag)}`, {\n        method: 'DELETE'\n      });\n\n      if (result === false) {\n        reporter.error(reporter.lang('deletedTagFail'));\n      } else {\n        reporter.success(reporter.lang('deletedTag'));\n      }\n\n      reporter.step(3, 3, reporter.lang('revokingToken'));\n      yield revoke();\n\n      if (result === false) {\n        throw new Error();\n      } else {\n        return true;\n      }\n    })();\n  },\n\n  ls(config, reporter, flags, args) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const name = yield getName(args, config);\n\n      reporter.step(1, 3, reporter.lang('loggingIn'));\n      const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter, name);\n\n      reporter.step(2, 3, reporter.lang('gettingTags'));\n      const tags = yield config.registries.npm.request(`-/package/${name}/dist-tags`);\n\n      if (tags) {\n        reporter.info(`Package ${name}`);\n        for (const name in tags) {\n          reporter.info(`${name}: ${tags[name]}`);\n        }\n      }\n\n      reporter.step(3, 3, reporter.lang('revokingToken'));\n      yield revoke();\n\n      if (!tags) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('packageNotFoundRegistry', name, 'npm'));\n      }\n    })();\n  }\n}, ['add <pkg>@<version> [<tag>]', 'rm <pkg> <tag>', 'ls [<pkg>]']);\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags,\n      examples = _buildSubCommands.examples;\nexports.run = run;\nexports.setFlags = setFlags;\nexports.examples = examples;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/team.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFlags = exports.run = undefined;\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _toArray2;\n\nfunction _load_toArray() {\n  return _toArray2 = _interopRequireDefault(require('babel-runtime/helpers/toArray'));\n}\n\nvar _buildSubCommands2;\n\nfunction _load_buildSubCommands() {\n  return _buildSubCommands2 = _interopRequireDefault(require('./_build-sub-commands.js'));\n}\n\nvar _login;\n\nfunction _load_login() {\n  return _login = require('./login.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction explodeScopeTeam(arg, requireTeam, reporter) {\n  var _arg$split = arg.split(':'),\n      _arg$split2 = (0, (_toArray2 || _load_toArray()).default)(_arg$split);\n\n  const scope = _arg$split2[0],\n        team = _arg$split2[1],\n        parts = _arg$split2.slice(2);\n\n  if (parts.length) {\n    return false;\n  }\n\n  if (requireTeam && !team) {\n    return false;\n  }\n\n  return {\n    scope: scope || '',\n    team: team || '',\n    user: ''\n  };\n}\n\nfunction wrapRequired(callback, requireTeam) {\n  return (() => {\n    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n      if (!args.length) {\n        return false;\n      }\n\n      const parts = explodeScopeTeam(args[0], requireTeam, reporter);\n      if (!parts) {\n        return false;\n      }\n\n      reporter.step(1, 3, reporter.lang('loggingIn'));\n      const revoke = yield (0, (_login || _load_login()).getToken)(config, reporter);\n\n      const res = yield callback(parts, config, reporter, flags, args);\n      if (!res) {\n        return res;\n      }\n\n      reporter.step(3, 3, reporter.lang('revokingToken'));\n      yield revoke();\n      return true;\n    });\n\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  })();\n}\n\nfunction wrapRequiredTeam(callback) {\n  let requireTeam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  return wrapRequired(function (parts, config, reporter, flags, args) {\n    if (args.length === 1) {\n      return callback(parts, config, reporter, flags, args);\n    } else {\n      return false;\n    }\n  }, requireTeam);\n}\n\nfunction wrapRequiredUser(callback) {\n  return wrapRequired(function (parts, config, reporter, flags, args) {\n    if (args.length === 2) {\n      return callback((0, (_extends2 || _load_extends()).default)({\n        user: args[1]\n      }, parts), config, reporter, flags, args);\n    } else {\n      return false;\n    }\n  }, true);\n}\n\nvar _buildSubCommands = (0, (_buildSubCommands2 || _load_buildSubCommands()).default)('team', {\n  create: wrapRequiredTeam((() => {\n    var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (parts, config, reporter, flags, args) {\n      reporter.step(2, 3, reporter.lang('teamCreating'));\n      reporter.inspect((yield config.registries.npm.request(`team/${parts.scope}`, {\n        method: 'PUT',\n        body: {\n          team: parts.team\n        }\n      })));\n      return true;\n    });\n\n    return function (_x6, _x7, _x8, _x9, _x10) {\n      return _ref2.apply(this, arguments);\n    };\n  })()),\n\n  destroy: wrapRequiredTeam((() => {\n    var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (parts, config, reporter, flags, args) {\n      reporter.step(2, 3, reporter.lang('teamRemoving'));\n      reporter.inspect((yield config.registries.npm.request(`team/${parts.scope}/${parts.team}`, {\n        method: 'DELETE'\n      })));\n      return true;\n    });\n\n    return function (_x11, _x12, _x13, _x14, _x15) {\n      return _ref3.apply(this, arguments);\n    };\n  })()),\n\n  add: wrapRequiredUser((() => {\n    var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (parts, config, reporter, flags, args) {\n      reporter.step(2, 3, reporter.lang('teamAddingUser'));\n      reporter.inspect((yield config.registries.npm.request(`team/${parts.scope}/${parts.team}/user`, {\n        method: 'PUT',\n        body: {\n          user: parts.user\n        }\n      })));\n      return true;\n    });\n\n    return function (_x16, _x17, _x18, _x19, _x20) {\n      return _ref4.apply(this, arguments);\n    };\n  })()),\n\n  rm: wrapRequiredUser((() => {\n    var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (parts, config, reporter, flags, args) {\n      reporter.step(2, 3, reporter.lang('teamRemovingUser'));\n      reporter.inspect((yield config.registries.npm.request(`team/${parts.scope}/${parts.team}/user`, {\n        method: 'DELETE',\n        body: {\n          user: parts.user\n        }\n      })));\n      return true;\n    });\n\n    return function (_x21, _x22, _x23, _x24, _x25) {\n      return _ref5.apply(this, arguments);\n    };\n  })()),\n\n  ls: wrapRequiredTeam((() => {\n    var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (parts, config, reporter, flags, args) {\n      reporter.step(2, 3, reporter.lang('teamListing'));\n      const uriParams = '?format=cli';\n      if (parts.team) {\n        reporter.inspect((yield config.registries.npm.request(`team/${parts.scope}/${parts.team}/user${uriParams}`)));\n      } else {\n        reporter.inspect((yield config.registries.npm.request(`org/${parts.scope}/team${uriParams}`)));\n      }\n      return true;\n    });\n\n    return function (_x26, _x27, _x28, _x29, _x30) {\n      return _ref6.apply(this, arguments);\n    };\n  })(), false)\n}, ['create <scope:team>', 'destroy <scope:team>', 'add <scope:team> <user>', 'rm <scope:team> <user>', 'ls <scope>|<scope:team>']);\n\nconst run = _buildSubCommands.run,\n      setFlags = _buildSubCommands.setFlags;\nexports.run = run;\nexports.setFlags = setFlags;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/unlink.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (args.length) {\n      for (const name of args) {\n        const linkLoc = path.join(config.linkFolder, name);\n        if (yield (_fs || _load_fs()).exists(linkLoc)) {\n          yield (_fs || _load_fs()).unlink(path.join((yield (0, (_link || _load_link()).getRegistryFolder)(config, name)), name));\n          reporter.success(reporter.lang('linkUnregistered', name));\n        } else {\n          throw new (_errors || _load_errors()).MessageError(reporter.lang('linkMissing', name));\n        }\n      }\n    } else {\n      // remove from registry\n      const manifest = yield config.readRootManifest();\n      const name = manifest.name;\n      if (!name) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('unknownPackageName'));\n      }\n\n      const linkLoc = path.join(config.linkFolder, name);\n      if (yield (_fs || _load_fs()).exists(linkLoc)) {\n        // If there is a `bin` defined in the package.json,\n        // link each bin to the global bin\n        if (manifest.bin) {\n          const globalBinFolder = (0, (_global || _load_global()).getBinFolder)(config, flags);\n          for (const binName in manifest.bin) {\n            const binDestLoc = path.join(globalBinFolder, binName);\n            if (yield (_fs || _load_fs()).exists(binDestLoc)) {\n              yield (_fs || _load_fs()).unlink(binDestLoc);\n            }\n          }\n        }\n\n        yield (_fs || _load_fs()).unlink(linkLoc);\n\n        reporter.success(reporter.lang('linkUnregistered', name));\n      } else {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('linkMissing', name));\n      }\n    }\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _link;\n\nfunction _load_link() {\n  return _link = require('./link.js');\n}\n\nvar _global;\n\nfunction _load_global() {\n  return _global = require('./global');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/upgrade.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.requireLockfile = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const lockfile = args.length ? yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd, reporter) : new (_wrapper || _load_wrapper()).default();\n    const manifest = (yield config.readRootManifest()) || {};\n    const dependencies = manifest.dependencies || {};\n\n    const addArgs = args.map(function (dependency) {\n      const remoteSource = dependencies[dependency];\n\n      if (remoteSource && (_packageRequest || _load_packageRequest()).default.getExoticResolver(remoteSource)) {\n        return remoteSource;\n      }\n\n      return dependency;\n    });\n\n    const addFlags = Object.assign({}, flags, { force: true });\n\n    const install = new (_add || _load_add()).Add(addArgs, addFlags, config, reporter, lockfile);\n    yield install.init();\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _add;\n\nfunction _load_add() {\n  return _add = require('./add.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction setFlags(commander) {\n  // TODO: support some flags that install command has\n  commander.usage('upgrade [flags]');\n}\n\nconst requireLockfile = exports.requireLockfile = true;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/version.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.setVersion = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet setVersion = exports.setVersion = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args, required) {\n    let runLifecycle = (() => {\n      var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (lifecycle) {\n        if (scripts[lifecycle]) {\n          return yield (0, (_executeLifecycleScript || _load_executeLifecycleScript()).execCommand)(lifecycle, config, scripts[lifecycle], config.cwd);\n        }\n\n        return Promise.resolve();\n      });\n\n      return function runLifecycle(_x6) {\n        return _ref2.apply(this, arguments);\n      };\n    })();\n\n    const pkg = yield config.readRootManifest();\n    const pkgLoc = pkg._loc;\n    const scripts = (0, (_map || _load_map()).default)();\n    let newVersion = flags.newVersion;\n    invariant(pkgLoc, 'expected package location');\n\n    if (args.length && !newVersion) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidVersionArgument', NEW_VERSION_FLAG));\n    }\n\n    if (pkg.scripts) {\n      // inherit `scripts` from manifest\n      Object.assign(scripts, pkg.scripts);\n    }\n\n    // get old version\n    let oldVersion = pkg.version;\n    if (oldVersion) {\n      reporter.info(`${reporter.lang('currentVersion')}: ${oldVersion}`);\n    } else {\n      oldVersion = '0.0.0';\n    }\n\n    // get new version\n    if (newVersion && !isValidNewVersion(oldVersion, newVersion, config.looseSemver)) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidVersion'));\n    }\n\n    // wasn't passed a version arg so ask interactively\n    while (!newVersion) {\n      newVersion = yield reporter.question(reporter.lang('newVersion'));\n\n      if (!required && !newVersion) {\n        return function () {\n          return Promise.resolve();\n        };\n      }\n\n      if (isValidNewVersion(oldVersion, newVersion, config.looseSemver)) {\n        break;\n      } else {\n        newVersion = null;\n        reporter.error(reporter.lang('invalidSemver'));\n      }\n    }\n    if (newVersion) {\n      newVersion = semver.inc(oldVersion, newVersion, config.looseSemver) || newVersion;\n    }\n    invariant(newVersion, 'expected new version');\n\n    if (newVersion === pkg.version) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('publishSame'));\n    }\n\n    yield runLifecycle('preversion');\n\n    // update version\n    reporter.info(`${reporter.lang('newVersion')}: ${newVersion}`);\n    pkg.version = newVersion;\n\n    // update versions in manifests\n    const manifests = yield config.getRootManifests();\n    for (const registryName of (_index || _load_index()).registryNames) {\n      const manifest = manifests[registryName];\n      if (manifest.exists) {\n        manifest.object.version = newVersion;\n      }\n    }\n    yield config.saveRootManifests(manifests);\n\n    // check if committing the new version to git is overriden\n    if (!flags.gitTagVersion || !config.getOption('version-git-tag')) {\n      // Don't tag the version in Git\n      return function () {\n        return Promise.resolve();\n      };\n    }\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      invariant(newVersion, 'expected version');\n\n      // add git commit and tag\n      let isGit = false;\n      const parts = config.cwd.split(path.sep);\n      while (parts.length) {\n        isGit = yield (_fs || _load_fs()).exists(path.join(parts.join(path.sep), '.git'));\n        if (isGit) {\n          break;\n        } else {\n          parts.pop();\n        }\n      }\n\n      yield runLifecycle('version');\n\n      if (isGit) {\n        const message = (flags.message || String(config.getOption('version-git-message'))).replace(/%s/g, newVersion);\n        const sign = Boolean(config.getOption('version-sign-git-tag'));\n        const flag = sign ? '-sm' : '-am';\n        const prefix = String(config.getOption('version-tag-prefix'));\n\n        // add manifest\n        yield (0, (_child || _load_child()).spawn)('git', ['add', pkgLoc]);\n\n        // create git commit\n        yield (0, (_child || _load_child()).spawn)('git', ['commit', '-m', message]);\n\n        // create git tag\n        yield (0, (_child || _load_child()).spawn)('git', ['tag', `${prefix}${newVersion}`, flag, message]);\n      }\n\n      yield runLifecycle('postversion');\n    });\n  });\n\n  return function setVersion(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const commit = yield setVersion(config, reporter, flags, args, true);\n    yield commit();\n  });\n\n  return function run(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = require('../../util/execute-lifecycle-script.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _child;\n\nfunction _load_child() {\n  return _child = require('../../util/child.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../../util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst semver = require('semver');\nconst path = require('path');\n\nconst NEW_VERSION_FLAG = '--new-version [version]';\nfunction isValidNewVersion(oldVersion, newVersion, looseSemver) {\n  return !!(semver.valid(newVersion, looseSemver) || semver.inc(oldVersion, newVersion, looseSemver));\n}\n\nfunction setFlags(commander) {\n  commander.option(NEW_VERSION_FLAG, 'new version');\n  commander.option('--message [message]', 'message');\n  commander.option('--no-git-tag-version', 'no git tag version');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/versions.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet run = exports.run = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const versions = { yarn: YARN_VERSION };\n\n    const pkg = yield config.maybeReadManifest(config.cwd);\n    if (pkg && pkg.name && pkg.version) {\n      versions[pkg.name] = pkg.version;\n    }\n\n    Object.assign(versions, process.versions);\n\n    reporter.inspect(versions);\n  });\n\n  return function run(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst YARN_VERSION = require('../../../package.json').version;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/why.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.requireLockfile = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet cleanQuery = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, query) {\n    // if a location was passed then turn it into a hash query\n    if (path.isAbsolute(query) && (yield (_fs || _load_fs()).exists(query))) {\n      // absolute path\n      query = path.relative(config.cwd, query);\n    }\n\n    // remove references to node_modules with hashes\n    query = query.replace(/([\\\\/]|^)node_modules[\\\\/]/g, '#');\n\n    // remove trailing hashes\n    query = query.replace(/^#+/g, '');\n\n    // remove trailing paths from each part of the query, skip second part of path for scoped packages\n    let queryParts = query.split('#');\n    queryParts = queryParts.map(function (part) {\n      let parts = part.split(/[\\\\/]/g);\n\n      if (part[0] === '@') {\n        parts = parts.slice(0, 2);\n      } else {\n        parts = parts.slice(0, 1);\n      }\n\n      return parts.join('/');\n    });\n    query = queryParts.join('#');\n\n    return query;\n  });\n\n  return function cleanQuery(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet getPackageSize = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (tuple) {\n    var _tuple = (0, (_slicedToArray2 || _load_slicedToArray()).default)(tuple, 1);\n\n    const loc = _tuple[0];\n\n\n    const files = yield (_fs || _load_fs()).walk(loc, null, new Set([(_constants || _load_constants()).METADATA_FILENAME, (_constants || _load_constants()).TARBALL_FILENAME]));\n\n    const sizes = yield Promise.all(files.map(function (walkFile) {\n      return (_fs || _load_fs()).getFileSizeOnDisk(walkFile.absolute);\n    }));\n\n    return sum(sizes);\n  });\n\n  return function getPackageSize(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    if (!args.length) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('missingWhyDependency'));\n    }\n    if (args.length > 1) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('tooManyArguments', 1));\n    }\n\n    const query = yield cleanQuery(config, args[0]);\n\n    reporter.step(1, 4, reporter.lang('whyStart', args[0]), emoji.get('thinking_face'));\n\n    // init\n    reporter.step(2, 4, reporter.lang('whyInitGraph'), emoji.get('truck'));\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd, reporter);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n\n    var _ref7 = yield install.fetchRequestFromCwd();\n\n    const depRequests = _ref7.requests,\n          patterns = _ref7.patterns;\n\n    yield install.resolver.init(depRequests, install.flags.flat);\n    const hoisted = yield install.linker.getFlatHoistedTree(patterns);\n\n    // finding\n    reporter.step(3, 4, reporter.lang('whyFinding'), emoji.get('mag'));\n\n    let match;\n    for (const _ref8 of hoisted) {\n      var _ref9 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref8, 2);\n\n      const loc = _ref9[0];\n      const info = _ref9[1];\n\n      if (info.key === query || info.previousKeys.indexOf(query) >= 0) {\n        match = [loc, info];\n        break;\n      }\n    }\n\n    if (!match) {\n      reporter.error(reporter.lang('whyUnknownMatch'));\n      return;\n    }\n\n    var _match = match,\n        _match2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_match, 2);\n\n    const matchInfo = _match2[1];\n\n    const matchRef = matchInfo.pkg._reference;\n    invariant(matchRef, 'expected reference');\n\n    const matchPatterns = matchRef.patterns;\n    const matchRequests = matchRef.requests;\n\n    const reasons = [];\n    // reason: dependency of these modules\n    for (const request of matchRequests) {\n      const parentRequest = request.parentRequest;\n      if (!parentRequest) {\n        continue;\n      }\n\n      const dependent = install.resolver.getResolvedPattern(parentRequest.pattern);\n      if (!dependent) {\n        continue;\n      }\n\n      const chain = [];\n\n      let delegator = parentRequest;\n      do {\n        chain.push(install.resolver.getStrictResolvedPattern(delegator.pattern).name);\n      } while (delegator = delegator.parentRequest);\n\n      reasons.push({\n        type: 'whyDependedOn',\n        typeSimple: 'whyDependedOnSimple',\n        value: chain.reverse().join('#')\n      });\n    }\n\n    // reason: exists in manifest\n    let rootType;\n    for (const pattern of matchPatterns) {\n      rootType = install.rootPatternsToOrigin[pattern];\n      if (rootType) {\n        reasons.push({\n          type: 'whySpecified',\n          typeSimple: 'whySpecifiedSimple',\n          value: rootType\n        });\n      }\n    }\n\n    // reason: this is hoisted from these modules\n    for (const pattern of matchInfo.previousKeys) {\n      if (pattern !== matchInfo.key) {\n        reasons.push({\n          type: 'whyHoistedFrom',\n          typeSimple: 'whyHoistedFromSimple',\n          value: pattern\n        });\n      }\n    }\n\n    // package sizes\n    reporter.step(4, 4, reporter.lang('whyCalculating'), emoji.get('aerial_tramway'));\n\n    let packageSize = 0;\n    let directSizes = [];\n    let transitiveSizes = [];\n    try {\n      packageSize = yield getPackageSize(match);\n    } catch (e) {}\n\n    const dependencies = Array.from(collect(hoisted, new Set(), match));\n    const transitiveDependencies = Array.from(collect(hoisted, new Set(), match, { recursive: true }));\n\n    try {\n      directSizes = yield Promise.all(dependencies.map(getPackageSize));\n      transitiveSizes = yield Promise.all(transitiveDependencies.map(getPackageSize));\n    } catch (e) {}\n\n    const transitiveKeys = new Set(transitiveDependencies.map(function (_ref10) {\n      var _ref11 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref10, 2);\n\n      let info = _ref11[1];\n      return info.key;\n    }));\n    const sharedDependencies = getSharedDependencies(hoisted, transitiveKeys);\n\n    //\n    // reason: hoisted\n    if (query === matchInfo.originalKey) {\n      reporter.info(reporter.lang('whyHoistedTo', matchInfo.key));\n    }\n\n    if (reasons.length === 1) {\n      reporter.info(reporter.lang(reasons[0].typeSimple, reasons[0].value));\n    } else if (reasons.length > 1) {\n      reporter.info(reporter.lang('whyReasons'));\n      reporter.list('reasons', reasons.map(function (reason) {\n        return reporter.lang(reason.type, reason.value);\n      }));\n    } else {\n      reporter.error(reporter.lang('whyWhoKnows'));\n    }\n\n    if (packageSize) {\n      // stats: file size of this dependency without any dependencies\n      reporter.info(reporter.lang('whyDiskSizeWithout', bytes(packageSize)));\n\n      // stats: file size of this dependency including dependencies that aren't shared\n      reporter.info(reporter.lang('whyDiskSizeUnique', bytes(packageSize + sum(directSizes))));\n\n      // stats: file size of this dependency including dependencies\n      reporter.info(reporter.lang('whyDiskSizeTransitive', bytes(packageSize + sum(transitiveSizes))));\n\n      // stats: shared transitive dependencies\n      reporter.info(reporter.lang('whySharedDependencies', sharedDependencies.size));\n    }\n  });\n\n  return function run(_x5, _x6, _x7, _x8) {\n    return _ref6.apply(this, arguments);\n  };\n})();\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst requireLockfile = exports.requireLockfile = true;\n\nconst invariant = require('invariant');\nconst bytes = require('bytes');\nconst emoji = require('node-emoji');\nconst path = require('path');\n\nfunction sum(array) {\n  return array.length ? array.reduce((a, b) => a + b, 0) : 0;\n}\n\nfunction collect(hoistManifests, allDependencies, dependency) {\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { recursive: false };\n\n  let recursive = _ref3.recursive;\n\n  var _dependency = (0, (_slicedToArray2 || _load_slicedToArray()).default)(dependency, 2);\n\n  const depInfo = _dependency[1];\n\n  const deps = depInfo.pkg.dependencies;\n\n  if (!deps) {\n    return allDependencies;\n  }\n\n  const dependencyKeys = new Set(Object.keys(deps));\n  const directDependencies = [];\n\n  for (const dep of hoistManifests) {\n    var _dep = (0, (_slicedToArray2 || _load_slicedToArray()).default)(dep, 2);\n\n    const info = _dep[1];\n\n\n    if (!allDependencies.has(dep) && dependencyKeys.has(info.key)) {\n      allDependencies.add(dep);\n      directDependencies.push(dep);\n    }\n  }\n\n  if (recursive) {\n    directDependencies.forEach(dependency => collect(hoistManifests, allDependencies, dependency, { recursive: true }));\n  }\n\n  return allDependencies;\n}\n\nfunction getSharedDependencies(hoistManifests, transitiveKeys) {\n  const sharedDependencies = new Set();\n  for (const _ref4 of hoistManifests) {\n    var _ref5 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref4, 2);\n\n    const info = _ref5[1];\n\n    if (!transitiveKeys.has(info.key) && info.pkg.dependencies) {\n      Object.keys(info.pkg.dependencies).forEach(dependency => {\n        if (transitiveKeys.has(dependency) && !sharedDependencies.has(dependency)) {\n          sharedDependencies.add(dependency);\n        }\n      });\n    }\n  }\n  return sharedDependencies;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/upgrade-interactive.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = exports.requireLockfile = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\n// Prompt user with Inquirer\nlet prompt = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (choices) {\n    let pageSize;\n    if (process.stdout instanceof tty.WriteStream) {\n      pageSize = process.stdout.rows - 2;\n    }\n    const answers = yield (_inquirer || _load_inquirer()).default.prompt([{\n      name: 'packages',\n      type: 'checkbox',\n      message: 'Choose which packages to update.',\n      choices,\n      pageSize,\n      validate: function (answer) {\n        return !!answer.length || 'You must choose at least one package.';\n      }\n    }]);\n    return answers.packages;\n  });\n\n  return function prompt(_x) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet run = exports.run = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, reporter, flags, args) {\n    const lockfile = yield (_wrapper || _load_wrapper()).default.fromDirectory(config.cwd);\n    const install = new (_install || _load_install()).Install(flags, config, reporter, lockfile);\n    const deps = yield (_packageRequest || _load_packageRequest()).default.getOutdatedPackages(lockfile, install, config, reporter);\n\n    if (!deps.length) {\n      reporter.success(reporter.lang('allDependenciesUpToDate'));\n      return;\n    }\n\n    const getNameFromHint = function (hint) {\n      return hint ? `${hint}Dependencies` : 'dependencies';\n    };\n\n    const maxLengthArr = { name: 0, current: 0, latest: 0 };\n    deps.forEach(function (dep) {\n      return ['name', 'current', 'latest'].forEach(function (key) {\n        maxLengthArr[key] = Math.max(maxLengthArr[key], dep[key].length);\n      });\n    });\n\n    // Depends on maxLengthArr\n    const addPadding = function (dep) {\n      return function (key) {\n        return `${dep[key]}${' '.repeat(maxLengthArr[key] - dep[key].length)}`;\n      };\n    };\n\n    const colorizeName = function (_ref3) {\n      let current = _ref3.current,\n          wanted = _ref3.wanted;\n      return current === wanted ? reporter.format.yellow : reporter.format.red;\n    };\n\n    const colorizeDiff = function (from, to) {\n      const parts = to.split('.');\n      const fromParts = from.split('.');\n\n      const index = parts.findIndex(function (part, i) {\n        return part !== fromParts[i];\n      });\n      const splitIndex = index >= 0 ? index : parts.length;\n\n      const colorized = reporter.format.green(parts.slice(splitIndex).join('.'));\n      return parts.slice(0, splitIndex).concat(colorized).join('.');\n    };\n\n    const makeRow = function (dep) {\n      const padding = addPadding(dep);\n      const name = colorizeName(dep)(padding('name'));\n      const current = reporter.format.blue(padding('current'));\n      const latest = colorizeDiff(dep.current, padding('latest'));\n      const url = reporter.format.cyan(dep.url);\n      return `${name}  ${current}  ❯  ${latest}  ${url}`;\n    };\n\n    const groupedDeps = deps.reduce(function (acc, dep) {\n      const hint = dep.hint,\n            name = dep.name,\n            latest = dep.latest;\n\n      const key = getNameFromHint(hint);\n      const xs = acc[key] || [];\n      acc[key] = xs.concat({\n        name: makeRow(dep),\n        value: dep,\n        short: `${name}@${latest}`\n      });\n      return acc;\n    }, {});\n\n    const flatten = function (xs) {\n      return xs.reduce(function (ys, y) {\n        return ys.concat(Array.isArray(y) ? flatten(y) : y);\n      }, []);\n    };\n\n    const choices = Object.keys(groupedDeps).map(function (key) {\n      return [new (_inquirer || _load_inquirer()).default.Separator(reporter.format.bold.underline.green(key)), groupedDeps[key], new (_inquirer || _load_inquirer()).default.Separator(' ')];\n    });\n\n    const answers = yield prompt(flatten(choices));\n\n    const getName = function (_ref4) {\n      let name = _ref4.name;\n      return name;\n    };\n    const isHint = function (x) {\n      return function (_ref5) {\n        let hint = _ref5.hint;\n        return hint === x;\n      };\n    };\n\n    yield [null, 'dev', 'optional', 'peer'].reduce((() => {\n      var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (promise, hint) {\n        // Wait for previous promise to resolve\n        yield promise;\n        // Reset dependency flags\n        flags.dev = hint === 'dev';\n        flags.peer = hint === 'peer';\n        flags.optional = hint === 'optional';\n\n        const deps = answers.filter(isHint(hint)).map(getName);\n        if (deps.length) {\n          reporter.info(reporter.lang('updateInstalling', getNameFromHint(hint)));\n          const add = new (_add || _load_add()).Add(deps, flags, config, reporter, lockfile);\n          return yield add.init();\n        }\n        return Promise.resolve();\n      });\n\n      return function (_x6, _x7) {\n        return _ref6.apply(this, arguments);\n      };\n    })(), Promise.resolve());\n  });\n\n  return function run(_x2, _x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nexports.setFlags = setFlags;\n\nvar _inquirer;\n\nfunction _load_inquirer() {\n  return _inquirer = _interopRequireDefault(require('inquirer'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../../package-request.js'));\n}\n\nvar _add;\n\nfunction _load_add() {\n  return _add = require('./add.js');\n}\n\nvar _install;\n\nfunction _load_install() {\n  return _install = require('./install.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('../../lockfile/wrapper.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst tty = require('tty');\n\nconst requireLockfile = exports.requireLockfile = true;\n\nfunction setFlags(commander) {\n  commander.usage('upgrade-interactive');\n  commander.option('-E, --exact', 'install exact version');\n  commander.option('-T, --tilde', 'install most recent release with the same minor version');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/cli/commands/_useless.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (message) {\n  return {\n    useless: true,\n    run() {\n      throw new (_errors || _load_errors()).MessageError(message);\n    }\n  };\n};\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _consoleReporter;\n\nfunction _load_consoleReporter() {\n  return _consoleReporter = require('./console/console-reporter.js');\n}\n\nObject.defineProperty(exports, 'ConsoleReporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_consoleReporter || _load_consoleReporter()).default;\n  }\n});\n\nvar _bufferReporter;\n\nfunction _load_bufferReporter() {\n  return _bufferReporter = require('./buffer-reporter.js');\n}\n\nObject.defineProperty(exports, 'BufferReporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_bufferReporter || _load_bufferReporter()).default;\n  }\n});\n\nvar _eventReporter;\n\nfunction _load_eventReporter() {\n  return _eventReporter = require('./event-reporter.js');\n}\n\nObject.defineProperty(exports, 'EventReporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_eventReporter || _load_eventReporter()).default;\n  }\n});\n\nvar _jsonReporter;\n\nfunction _load_jsonReporter() {\n  return _jsonReporter = require('./json-reporter.js');\n}\n\nObject.defineProperty(exports, 'JSONReporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_jsonReporter || _load_jsonReporter()).default;\n  }\n});\n\nvar _noopReporter;\n\nfunction _load_noopReporter() {\n  return _noopReporter = require('./noop-reporter.js');\n}\n\nObject.defineProperty(exports, 'NoopReporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_noopReporter || _load_noopReporter()).default;\n  }\n});\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = require('./base-reporter.js');\n}\n\nObject.defineProperty(exports, 'Reporter', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_baseReporter || _load_baseReporter()).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/console/console-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('../base-reporter.js'));\n}\n\nvar _progressBar;\n\nfunction _load_progressBar() {\n  return _progressBar = _interopRequireDefault(require('./progress-bar.js'));\n}\n\nvar _spinnerProgress;\n\nfunction _load_spinnerProgress() {\n  return _spinnerProgress = _interopRequireDefault(require('./spinner-progress.js'));\n}\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nvar _treeHelper;\n\nfunction _load_treeHelper() {\n  return _treeHelper = require('./helpers/tree-helper.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _require = require('util');\n\nconst inspect = _require.inspect;\n\nconst readline = require('readline');\nconst chalk = require('chalk');\nconst read = require('read');\n\nclass ConsoleReporter extends (_baseReporter || _load_baseReporter()).default {\n  constructor(opts) {\n    super(opts);\n    this._lastCategorySize = 0;\n\n    this.format = chalk;\n  }\n\n  _prependEmoji(msg, emoji) {\n    if (this.emoji && emoji && this.isTTY) {\n      msg = `${emoji}  ${msg}`;\n    }\n    return msg;\n  }\n\n  _logCategory(category, color, msg) {\n    this._lastCategorySize = category.length;\n    this._log(`${this.format[color](category)} ${msg}`);\n  }\n\n  _verbose(msg) {\n    this._logCategory('verbose', 'grey', `${process.uptime()} ${msg}`);\n  }\n\n  _verboseInspect(obj) {\n    this.inspect(obj);\n  }\n\n  table(head, body) {\n    //\n    head = head.map(field => this.format.underline(field));\n\n    //\n    const rows = [head].concat(body);\n\n    // get column widths\n    const cols = [];\n    for (let i = 0; i < head.length; i++) {\n      const widths = rows.map(row => this.format.stripColor(row[i]).length);\n      cols[i] = Math.max(...widths);\n    }\n\n    //\n    const builtRows = rows.map(row => {\n      for (let i = 0; i < row.length; i++) {\n        const field = row[i];\n        const padding = cols[i] - this.format.stripColor(field).length;\n\n        row[i] = field + ' '.repeat(padding);\n      }\n      return row.join(' ');\n    });\n\n    this.log(builtRows.join('\\n'));\n  }\n\n  step(current, total, msg, emoji) {\n    msg = this._prependEmoji(msg, emoji);\n\n    if (msg.endsWith('?')) {\n      msg = `${(0, (_misc || _load_misc()).removeSuffix)(msg, '?')}...?`;\n    } else {\n      msg += '...';\n    }\n\n    this.log(`${this.format.dim(`[${current}/${total}]`)} ${msg}`);\n  }\n\n  inspect(value) {\n    if (typeof value !== 'number' && typeof value !== 'string') {\n      value = inspect(value, {\n        breakLength: 0,\n        colors: true,\n        depth: null,\n        maxArrayLength: null\n      });\n    }\n\n    this.log('' + value);\n  }\n\n  list(key, items, hints) {\n    const gutterWidth = (this._lastCategorySize || 2) - 1;\n\n    if (hints) {\n      for (const item of items) {\n        this._log(`${' '.repeat(gutterWidth)}- ${item}`);\n        this._log(`  ${' '.repeat(gutterWidth)} ${hints[item]}`);\n      }\n    } else {\n      for (const item of items) {\n        this._log(`${' '.repeat(gutterWidth)}- ${item}`);\n      }\n    }\n  }\n\n  header(command, pkg) {\n    this.log(this.format.bold(`${pkg.name} ${command} v${pkg.version}`));\n  }\n\n  footer(showPeakMemory) {\n    const totalTime = (this.getTotalTime() / 1000).toFixed(2);\n    let msg = `Done in ${totalTime}s.`;\n    if (showPeakMemory) {\n      const peakMemory = (this.peakMemory / 1024 / 1024).toFixed(2);\n      msg += ` Peak memory usage ${peakMemory}MB.`;\n    }\n    this.log(this._prependEmoji(msg, '✨'));\n  }\n\n  log(msg) {\n    this._lastCategorySize = 0;\n    this._log(msg);\n  }\n\n  _log(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stdout);\n    this.stdout.write(`${msg}\\n`);\n  }\n\n  success(msg) {\n    this._logCategory('success', 'green', msg);\n  }\n\n  error(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stderr);\n    this.stderr.write(`${this.format.red('error')} ${msg}\\n`);\n  }\n\n  info(msg) {\n    this._logCategory('info', 'blue', msg);\n  }\n\n  command(command) {\n    this.log(this.format.dim(`$ ${command}`));\n  }\n\n  warn(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stderr);\n    this.stderr.write(`${this.format.yellow('warning')} ${msg}\\n`);\n  }\n\n  question(question) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!process.stdout.isTTY) {\n      return Promise.reject(new Error(\"Can't answer a question unless a user TTY\"));\n    }\n\n    return new Promise((resolve, reject) => {\n      read({\n        prompt: `${this.format.dim('question')} ${question}: `,\n        silent: !!options.password,\n        output: this.stdout,\n        input: this.stdin\n      }, (err, answer) => {\n        if (err) {\n          if (err.message === 'canceled') {\n            process.exit(1);\n          } else {\n            reject(err);\n          }\n        } else {\n          if (!answer && options.required) {\n            this.error(this.lang('answerRequired'));\n            resolve(this.question(question, options));\n          } else {\n            resolve(answer);\n          }\n        }\n      });\n    });\n  }\n  // handles basic tree output to console\n  tree(key, trees) {\n    //\n    const output = (_ref, level, end) => {\n      let name = _ref.name,\n          children = _ref.children,\n          hint = _ref.hint,\n          color = _ref.color;\n\n      const formatter = this.format;\n      const out = (0, (_treeHelper || _load_treeHelper()).getFormattedOutput)({ end, level, hint, color, name, formatter });\n      this.stdout.write(out);\n\n      if (children && children.length) {\n        (0, (_treeHelper || _load_treeHelper()).recurseTree)((0, (_treeHelper || _load_treeHelper()).sortTrees)(children), level, output);\n      }\n    };\n    (0, (_treeHelper || _load_treeHelper()).recurseTree)((0, (_treeHelper || _load_treeHelper()).sortTrees)(trees), -1, output);\n  }\n\n  activitySet(total, workers) {\n    if (!this.isTTY || this.noProgress) {\n      return super.activitySet(total, workers);\n    }\n\n    const spinners = [];\n\n    for (let i = 1; i < workers; i++) {\n      this.log('');\n    }\n\n    for (let i = 0; i < workers; i++) {\n      const spinner = new (_spinnerProgress || _load_spinnerProgress()).default(this.stderr, i);\n      spinner.start();\n\n      let prefix = null;\n      let current = 0;\n      const updatePrefix = () => {\n        spinner.setPrefix(`${this.format.dim(`[${current === 0 ? '-' : current}/${total}]`)} `);\n      };\n      const clear = () => {\n        prefix = null;\n        current = 0;\n        updatePrefix();\n        spinner.setText('waiting...');\n      };\n      clear();\n\n      spinners.unshift({\n        clear,\n\n        setPrefix(_current, _prefix) {\n          current = _current;\n          prefix = _prefix;\n          spinner.setText(prefix);\n          updatePrefix();\n        },\n\n        tick(msg) {\n          if (prefix) {\n            msg = `${prefix}: ${msg}`;\n          }\n          spinner.setText(msg);\n        },\n\n        end() {\n          spinner.stop();\n        }\n      });\n    }\n\n    return {\n      spinners,\n      end: () => {\n        for (const spinner of spinners) {\n          spinner.end();\n        }\n        readline.moveCursor(this.stdout, 0, -workers + 1);\n      }\n    };\n  }\n\n  activity() {\n    if (!this.isTTY) {\n      return {\n        tick() {},\n        end() {}\n      };\n    }\n\n    const spinner = new (_spinnerProgress || _load_spinnerProgress()).default(this.stderr);\n    spinner.start();\n\n    return {\n      tick(name) {\n        spinner.setText(name);\n      },\n\n      end() {\n        spinner.stop();\n      }\n    };\n  }\n\n  select(header, question, options) {\n    if (!this.isTTY) {\n      return Promise.reject(new Error(\"Can't answer a question unless a user TTY\"));\n    }\n\n    const rl = readline.createInterface({\n      input: this.stdin,\n      output: this.stdout,\n      terminal: true\n    });\n\n    const questions = options.map(opt => opt.name);\n    const answers = options.map(opt => opt.value);\n\n    function toIndex(input) {\n      const index = answers.indexOf(input);\n\n      if (index >= 0) {\n        return index;\n      } else {\n        return +input;\n      }\n    }\n\n    return new Promise(resolve => {\n      this.info(header);\n\n      for (let i = 0; i < questions.length; i++) {\n        this.log(`  ${this.format.dim(`${i + 1})`)} ${questions[i]}`);\n      }\n\n      const ask = () => {\n        rl.question(`${question}: `, input => {\n          let index = toIndex(input);\n\n          if (isNaN(index)) {\n            this.log('Not a number');\n            ask();\n            return;\n          }\n\n          if (index <= 0 || index > options.length) {\n            this.log('Outside answer range');\n            ask();\n            return;\n          }\n\n          // get index\n          index--;\n          rl.close();\n          resolve(answers[index]);\n        });\n      };\n\n      ask();\n    });\n  }\n\n  progress(count) {\n    if (this.noProgress || count <= 0) {\n      return function () {\n        // noop\n      };\n    }\n\n    if (!this.isTTY) {\n      return function () {\n        // TODO what should the behaviour here be? we could buffer progress messages maybe\n      };\n    }\n\n    const bar = new (_progressBar || _load_progressBar()).default(count, this.stderr);\n\n    bar.render();\n\n    return function () {\n      bar.tick();\n    };\n  }\n}\nexports.default = ConsoleReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/base-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.stringifyLangArgs = stringifyLangArgs;\n\nvar _format;\n\nfunction _load_format() {\n  return _format = require('./format.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./lang/index.js'));\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n  return _isCi = _interopRequireDefault(require('is-ci'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\nconst util = require('util');\nconst EventEmitter = require('events').EventEmitter;\n\nfunction stringifyLangArgs(args) {\n  return args.map(function (val) {\n    if (val != null && val.inspect) {\n      return val.inspect();\n    } else {\n      try {\n        const str = JSON.stringify(val) || val + '';\n        // should match all \"u001b\" that follow an odd number of backslashes and convert them to ESC\n        // we do this because the JSON.stringify process has escaped these characters\n        return str.replace(/((?:^|[^\\\\])(?:\\\\{2})*)\\\\u001[bB]/g, '$1\\u001b');\n      } catch (e) {\n        return util.inspect(val);\n      }\n    }\n  });\n}\n\nclass BaseReporter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const lang = 'en';\n    this.language = lang;\n\n    this.stdout = opts.stdout || process.stdout;\n    this.stderr = opts.stderr || process.stderr;\n    this.stdin = opts.stdin || this._getStandardInput();\n    this.emoji = !!opts.emoji;\n    this.noProgress = !!opts.noProgress || (_isCi || _load_isCi()).default;\n    this.isVerbose = !!opts.verbose;\n\n    // $FlowFixMe: this is valid!\n    this.isTTY = this.stdout.isTTY;\n\n    this.peakMemory = 0;\n    this.startTime = Date.now();\n    this.format = (_format || _load_format()).defaultFormatter;\n  }\n\n  lang(key) {\n    const msg = (_index || _load_index())[this.language][key] || (_index || _load_index()).en[key];\n    if (!msg) {\n      throw new ReferenceError(`Unknown language key ${key}`);\n    }\n\n    // stringify args\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    const stringifiedArgs = stringifyLangArgs(args);\n\n    // replace $0 placeholders with args\n    return msg.replace(/\\$(\\d+)/g, (str, i) => {\n      return stringifiedArgs[i];\n    });\n  }\n\n  verbose(msg) {\n    if (this.isVerbose) {\n      this._verbose(msg);\n    }\n  }\n\n  verboseInspect(val) {\n    if (this.isVerbose) {\n      this._verboseInspect(val);\n    }\n  }\n\n  _verbose(msg) {}\n  _verboseInspect(val) {}\n\n  _getStandardInput() {\n    let standardInput;\n\n    try {\n      standardInput = process.stdin;\n    } catch (e) {\n      delete process.stdin;\n      // $FlowFixMe: this is valid!\n      process.stdin = new EventEmitter();\n      standardInput = process.stdin;\n    }\n\n    return standardInput;\n  }\n\n  initPeakMemoryCounter() {\n    this.checkPeakMemory();\n    this.peakMemoryInterval = setInterval(() => {\n      this.checkPeakMemory();\n    }, 1000);\n  }\n\n  checkPeakMemory() {\n    var _process$memoryUsage = process.memoryUsage();\n\n    const heapTotal = _process$memoryUsage.heapTotal;\n\n    if (heapTotal > this.peakMemory) {\n      this.peakMemory = heapTotal;\n    }\n  }\n\n  close() {\n    if (this.peakMemoryInterval) {\n      clearInterval(this.peakMemoryInterval);\n      this.peakMemoryInterval = null;\n    }\n  }\n\n  getTotalTime() {\n    return Date.now() - this.startTime;\n  }\n\n  // TODO\n  list(key, items, hints) {}\n\n  // Outputs basic tree structure to console\n  tree(key, obj) {}\n\n  // called whenever we begin a step in the CLI.\n  step(current, total, message, emoji) {}\n\n  // a error message has been triggered. this however does not always meant an abrupt\n  // program end.\n  error(message) {}\n\n  // an info message has been triggered. this provides things like stats and diagnostics.\n  info(message) {}\n\n  // a warning message has been triggered.\n  warn(message) {}\n\n  // a success message has been triggered.\n  success(message) {}\n\n  // a simple log message\n  log(message) {}\n\n  // a shell command has been executed\n  command(command) {}\n\n  // inspect and pretty-print any value\n  inspect(value) {}\n\n  // the screen shown at the very start of the CLI\n  header(command, pkg) {}\n\n  // the screen shown at the very end of the CLI\n  footer(showPeakMemory) {}\n\n  //\n  table(head, body) {}\n\n  // render an activity spinner and return a function that will trigger an update\n  activity() {\n    return {\n      tick(name) {},\n      end() {}\n    };\n  }\n\n  //\n  activitySet(total, workers) {\n    return {\n      spinners: Array(workers).fill({\n        clear() {},\n        setPrefix() {},\n        tick() {},\n        end() {}\n      }),\n      end() {}\n    };\n  }\n\n  //\n  question(question) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  //\n  questionAffirm(question) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const condition = true; // trick eslint\n\n      while (condition) {\n        let answer = yield _this.question(question);\n        answer = answer.toLowerCase();\n\n        if (answer === 'y' || answer === 'yes') {\n          return true;\n        }\n        if (answer === 'n' || answer === 'no') {\n          return false;\n        }\n\n        _this.error('Invalid answer for question');\n      }\n\n      return false;\n    })();\n  }\n\n  // prompt the user to select an option from an array\n  select(header, question, options) {\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  // render a progress bar and return a function which when called will trigger an update\n  progress(total) {\n    return function () {};\n  }\n\n  // utility function to disable progress bar\n  disableProgress() {\n    this.noProgress = true;\n  }\n}\nexports.default = BaseReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/format.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction formatFunction() {\n  for (var _len = arguments.length, strs = Array(_len), _key = 0; _key < _len; _key++) {\n    strs[_key] = arguments[_key];\n  }\n\n  return strs.join(' ');\n}\n\nconst defaultFormatter = exports.defaultFormatter = {\n  bold: formatFunction,\n  dim: formatFunction,\n  italic: formatFunction,\n  underline: formatFunction,\n  inverse: formatFunction,\n  strikethrough: formatFunction,\n  black: formatFunction,\n  red: formatFunction,\n  green: formatFunction,\n  yellow: formatFunction,\n  blue: formatFunction,\n  magenta: formatFunction,\n  cyan: formatFunction,\n  white: formatFunction,\n  gray: formatFunction,\n  grey: formatFunction,\n  stripColor: formatFunction\n};","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/config.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = require('./util/execute-lifecycle-script.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireDefault(require('./util/normalize-manifest/index.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _packageConstraintResolver;\n\nfunction _load_packageConstraintResolver() {\n  return _packageConstraintResolver = _interopRequireDefault(require('./package-constraint-resolver.js'));\n}\n\nvar _requestManager;\n\nfunction _load_requestManager() {\n  return _requestManager = _interopRequireDefault(require('./util/request-manager.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('./registries/index.js');\n}\n\nvar _index3;\n\nfunction _load_index3() {\n  return _index3 = require('./reporters/index.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst detectIndent = require('detect-indent');\nconst invariant = require('invariant');\nconst path = require('path');\n\nfunction sortObject(object) {\n  const sortedObject = {};\n  Object.keys(object).sort().forEach(item => {\n    sortedObject[item] = object[item];\n  });\n  return sortedObject;\n}\n\nclass Config {\n  constructor(reporter) {\n    this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).default(this, reporter);\n    this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);\n    this.reporter = reporter;\n    this._init({});\n  }\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  // Whether we should ignore executing lifecycle scripts\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  /**\n   * Execute a promise produced by factory if it doesn't exist in our cache with\n   * the associated key.\n   */\n\n  getCache(key, factory) {\n    const cached = this.cache[key];\n    if (cached) {\n      return cached;\n    }\n\n    return this.cache[key] = factory().catch(err => {\n      this.cache[key] = null;\n      throw err;\n    });\n  }\n\n  /**\n   * Get a config option from our yarn config.\n   */\n\n  getOption(key) {\n    return this.registries.yarn.getOption(key);\n  }\n\n  /**\n   * Reduce a list of versions to a single one based on an input range.\n   */\n\n  resolveConstraints(versions, range) {\n    return this.constraintResolver.reduce(versions, range);\n  }\n\n  /**\n   * Initialise config. Fetch registry options, find package roots.\n   */\n\n  init() {\n    var _this = this;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this._init(opts);\n\n      yield (_fs || _load_fs()).mkdirp(_this.globalFolder);\n      yield (_fs || _load_fs()).mkdirp(_this.linkFolder);\n\n      _this.linkedModules = [];\n\n      const linkedModules = yield (_fs || _load_fs()).readdir(_this.linkFolder);\n\n      for (const dir of linkedModules) {\n        const linkedPath = path.join(_this.linkFolder, dir);\n\n        if (dir[0] === '@') {\n          // it's a scope, not a package\n          const scopedLinked = yield (_fs || _load_fs()).readdir(linkedPath);\n          _this.linkedModules.push(...scopedLinked.map(function (scopedDir) {\n            return path.join(dir, scopedDir);\n          }));\n        } else {\n          _this.linkedModules.push(dir);\n        }\n      }\n\n      for (const key of Object.keys((_index2 || _load_index2()).registries)) {\n        const Registry = (_index2 || _load_index2()).registries[key];\n\n        // instantiate registry\n        const registry = new Registry(_this.cwd, _this.registries, _this.requestManager);\n        yield registry.init();\n\n        _this.registries[key] = registry;\n        _this.registryFolders.push(registry.folder);\n        const rootModuleFolder = path.join(_this.cwd, registry.folder);\n        if (_this.rootModuleFolders.indexOf(rootModuleFolder) < 0) {\n          _this.rootModuleFolders.push(rootModuleFolder);\n        }\n      }\n\n      _this.networkConcurrency = opts.networkConcurrency || Number(_this.getOption('network-concurrency')) || (_constants || _load_constants()).NETWORK_CONCURRENCY;\n\n      _this.requestManager.setOptions({\n        userAgent: String(_this.getOption('user-agent')),\n        httpProxy: String(opts.httpProxy || _this.getOption('proxy') || ''),\n        httpsProxy: String(opts.httpsProxy || _this.getOption('https-proxy') || ''),\n        strictSSL: Boolean(_this.getOption('strict-ssl')),\n        ca: Array.prototype.concat(opts.ca || _this.getOption('ca') || []).map(String),\n        cafile: String(opts.cafile || _this.getOption('cafile') || ''),\n        cert: String(opts.cert || _this.getOption('cert') || ''),\n        key: String(opts.key || _this.getOption('key') || ''),\n        networkConcurrency: _this.networkConcurrency\n      });\n      _this._cacheRootFolder = String(opts.cacheFolder || _this.getOption('cache-folder') || (_constants || _load_constants()).MODULE_CACHE_DIRECTORY);\n\n      //init & create cacheFolder, tempFolder\n      _this.cacheFolder = path.join(_this._cacheRootFolder, 'v' + String((_constants || _load_constants()).CACHE_VERSION));\n      _this.tempFolder = opts.tempFolder || path.join(_this.cacheFolder, '.tmp');\n      yield (_fs || _load_fs()).mkdirp(_this.cacheFolder);\n      yield (_fs || _load_fs()).mkdirp(_this.tempFolder);\n\n      if (opts.production === 'false') {\n        _this.production = false;\n      } else if (_this.getOption('production') || process.env.NODE_ENV === 'production' && process.env.NPM_CONFIG_PRODUCTION !== 'false' && process.env.YARN_PRODUCTION !== 'false') {\n        _this.production = true;\n      } else {\n        _this.production = !!opts.production;\n      }\n    })();\n  }\n\n  _init(opts) {\n    this.rootModuleFolders = [];\n    this.registryFolders = [];\n    this.linkedModules = [];\n\n    this.registries = (0, (_map || _load_map()).default)();\n    this.cache = (0, (_map || _load_map()).default)();\n    this.cwd = opts.cwd || this.cwd || process.cwd();\n\n    this.looseSemver = opts.looseSemver == undefined ? true : opts.looseSemver;\n\n    this.commandName = opts.commandName || '';\n\n    this.preferOffline = !!opts.preferOffline;\n    this.modulesFolder = opts.modulesFolder;\n    this.globalFolder = opts.globalFolder || (_constants || _load_constants()).GLOBAL_MODULE_DIRECTORY;\n    this.linkFolder = opts.linkFolder || (_constants || _load_constants()).LINK_REGISTRY_DIRECTORY;\n    this.offline = !!opts.offline;\n    this.binLinks = !!opts.binLinks;\n\n    this.ignorePlatform = !!opts.ignorePlatform;\n    this.ignoreScripts = !!opts.ignoreScripts;\n\n    this.nonInteractive = !!opts.nonInteractive;\n\n    this.requestManager.setOptions({\n      offline: !!opts.offline && !opts.preferOffline,\n      captureHar: !!opts.captureHar\n    });\n\n    if (this.modulesFolder) {\n      this.rootModuleFolders.push(this.modulesFolder);\n    }\n  }\n\n  /**\n   * Generate an absolute module path.\n   */\n\n  generateHardModulePath(pkg, ignoreLocation) {\n    invariant(this.cacheFolder, 'No package root');\n    invariant(pkg, 'Undefined package');\n\n    if (pkg.location && !ignoreLocation) {\n      return pkg.location;\n    }\n\n    let name = pkg.name;\n    let uid = pkg.uid;\n    if (pkg.registry) {\n      name = `${pkg.registry}-${name}`;\n    }\n\n    const hash = pkg.remote.hash;\n\n\n    if (pkg.version && pkg.version !== pkg.uid) {\n      uid = `${pkg.version}-${uid}`;\n    } else if (hash) {\n      uid += `-${hash}`;\n    }\n\n    return path.join(this.cacheFolder, `${name}-${uid}`);\n  }\n\n  /**\n   * Execute lifecycle scripts in the specified directory. Ignoring when the --ignore-scripts flag has been\n   * passed.\n   */\n\n  executeLifecycleScript(commandName, cwd) {\n    if (this.ignoreScripts) {\n      return Promise.resolve();\n    } else {\n      return (0, (_executeLifecycleScript || _load_executeLifecycleScript()).execFromManifest)(this, commandName, cwd || this.cwd);\n    }\n  }\n\n  /**\n   * Generate an absolute temporary filename location based on the input filename.\n   */\n\n  getTemp(filename) {\n    invariant(this.tempFolder, 'No temp folder');\n    return path.join(this.tempFolder, filename);\n  }\n\n  /**\n   * Remote packages may be cached in a file system to be available for offline installation.\n   * Second time the same package needs to be installed it will be loaded from there.\n   * Given a package's filename, return a path in the offline mirror location.\n   */\n\n  getOfflineMirrorPath(packageFilename) {\n    let mirrorPath;\n\n    for (const key of ['npm', 'yarn']) {\n      const registry = this.registries[key];\n\n      if (registry == null) {\n        continue;\n      }\n\n      const registryMirrorPath = registry.config['yarn-offline-mirror'];\n\n      if (registryMirrorPath == null) {\n        continue;\n      }\n\n      mirrorPath = registryMirrorPath;\n    }\n\n    if (mirrorPath == null) {\n      return null;\n    }\n\n    if (packageFilename == null) {\n      return mirrorPath;\n    }\n\n    return path.join(mirrorPath, path.basename(packageFilename));\n  }\n\n  /**\n   * Checker whether the folder input is a valid module folder. We output a yarn metadata\n   * file when we've successfully setup a folder so use this as a marker.\n   */\n\n  isValidModuleDest(dest) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (!(yield (_fs || _load_fs()).exists(dest))) {\n        return false;\n      }\n\n      if (!(yield (_fs || _load_fs()).exists(path.join(dest, (_constants || _load_constants()).METADATA_FILENAME)))) {\n        return false;\n      }\n\n      return true;\n    })();\n  }\n\n  /**\n   * Read package metadata and normalized package info.\n   */\n\n  readPackageMetadata(dir) {\n    var _this2 = this;\n\n    return this.getCache(`metadata-${dir}`, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const metadata = yield _this2.readJson(path.join(dir, (_constants || _load_constants()).METADATA_FILENAME));\n      const pkg = yield _this2.readManifest(dir, metadata.registry);\n\n      return {\n        package: pkg,\n        artifacts: metadata.artifacts || [],\n        hash: metadata.hash,\n        remote: metadata.remote,\n        registry: metadata.registry\n      };\n    }));\n  }\n\n  /**\n   * Read normalized package info according yarn-metadata.json\n   * throw an error if package.json was not found\n   */\n\n  readManifest(dir, priorityRegistry) {\n    var _this3 = this;\n\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifest = yield _this3.maybeReadManifest(dir, priorityRegistry, isRoot);\n\n      if (manifest) {\n        return manifest;\n      } else {\n        throw new (_errors || _load_errors()).MessageError(_this3.reporter.lang('couldntFindPackagejson', dir), 'ENOENT');\n      }\n    })();\n  }\n\n  /**\n  * try get the manifest file by looking\n  * 1. mainfest file in cache\n  * 2. manifest file in registry\n  */\n  maybeReadManifest(dir, priorityRegistry) {\n    var _this4 = this;\n\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return this.getCache(`manifest-${dir}`, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const metadataLoc = path.join(dir, (_constants || _load_constants()).METADATA_FILENAME);\n      if (!priorityRegistry && (yield (_fs || _load_fs()).exists(metadataLoc))) {\n        var _ref3 = yield _this4.readJson(metadataLoc);\n\n        priorityRegistry = _ref3.registry;\n      }\n\n      if (priorityRegistry) {\n        const file = yield _this4.tryManifest(dir, priorityRegistry, isRoot);\n        if (file) {\n          return file;\n        }\n      }\n\n      for (const registry of Object.keys((_index2 || _load_index2()).registries)) {\n        if (priorityRegistry === registry) {\n          continue;\n        }\n\n        const file = yield _this4.tryManifest(dir, registry, isRoot);\n        if (file) {\n          return file;\n        }\n      }\n\n      return null;\n    }));\n  }\n\n  /**\n   * Read the root manifest.\n   */\n\n  readRootManifest() {\n    return this.readManifest(this.cwd, 'npm', true);\n  }\n\n  /**\n   * Try and find package info with the input directory and registry.\n   */\n\n  tryManifest(dir, registry, isRoot) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const filename = (_index2 || _load_index2()).registries[registry].filename;\n\n      const loc = path.join(dir, filename);\n      if (yield (_fs || _load_fs()).exists(loc)) {\n        const data = yield _this5.readJson(loc);\n        data._registry = registry;\n        data._loc = loc;\n        return (0, (_index || _load_index()).default)(data, dir, _this5, isRoot);\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  /**\n   * Description\n   */\n\n  getFolder(pkg) {\n    let registryName = pkg._registry;\n    if (!registryName) {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      registryName = ref.registry;\n    }\n    return this.registries[registryName].folder;\n  }\n\n  /**\n   * Get root manifests.\n   */\n\n  getRootManifests() {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifests = {};\n      for (const registryName of (_index2 || _load_index2()).registryNames) {\n        const registry = (_index2 || _load_index2()).registries[registryName];\n        const jsonLoc = path.join(_this6.cwd, registry.filename);\n\n        let object = {};\n        let exists = false;\n        let indent;\n        if (yield (_fs || _load_fs()).exists(jsonLoc)) {\n          exists = true;\n\n          const info = yield _this6.readJson(jsonLoc, (_fs || _load_fs()).readJsonAndFile);\n          object = info.object;\n          indent = detectIndent(info.content).indent || undefined;\n        }\n        manifests[registryName] = { loc: jsonLoc, object, exists, indent };\n      }\n      return manifests;\n    })();\n  }\n\n  /**\n   * Save root manifests.\n   */\n\n  saveRootManifests(manifests) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      for (const registryName of (_index2 || _load_index2()).registryNames) {\n        var _manifests$registryNa = manifests[registryName];\n        const loc = _manifests$registryNa.loc,\n              object = _manifests$registryNa.object,\n              exists = _manifests$registryNa.exists,\n              indent = _manifests$registryNa.indent;\n\n        if (!exists && !Object.keys(object).length) {\n          continue;\n        }\n\n        for (const field of (_constants || _load_constants()).DEPENDENCY_TYPES) {\n          if (object[field]) {\n            object[field] = sortObject(object[field]);\n          }\n        }\n\n        yield (_fs || _load_fs()).writeFilePreservingEol(loc, JSON.stringify(object, null, indent || (_constants || _load_constants()).DEFAULT_INDENT) + '\\n');\n      }\n    })();\n  }\n\n  /**\n   * Call the passed factory (defaults to fs.readJson) and rethrow a pretty error message if it was the result\n   * of a syntax error.\n   */\n\n  readJson(loc) {\n    var _this7 = this;\n\n    let factory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_fs || _load_fs()).readJson;\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield factory(loc);\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          throw new (_errors || _load_errors()).MessageError(_this7.reporter.lang('jsonError', loc, err.message));\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  static create() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let reporter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_index3 || _load_index3()).NoopReporter();\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const config = new Config(reporter);\n      yield config.init(opts);\n      return config;\n    })();\n  }\n}\nexports.default = Config;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-constraint-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst semver = require('semver');\n\n// This isn't really a \"proper\" constraint resolver. We just return the highest semver\n// version in the versions passed that satisfies the input range. This vastly reduces\n// the complexity and is very efficient for package resolution.\n\nclass PackageConstraintResolver {\n  constructor(config, reporter) {\n    this.reporter = reporter;\n    this.config = config;\n  }\n\n  reduce(versions, range) {\n    if (range === 'latest') {\n      // Usually versions are already ordered and the last one is the latest\n      return Promise.resolve(versions[versions.length - 1]);\n    } else {\n      return Promise.resolve(semver.maxSatisfying(versions, range, this.config.looseSemver));\n    }\n  }\n}\nexports.default = PackageConstraintResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/request-manager.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _network;\n\nfunction _load_network() {\n  return _network = _interopRequireWildcard(require('./network.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst RequestCaptureHar = require('request-capture-har');\nconst invariant = require('invariant');\nconst url = require('url');\nconst fs = require('fs');\n\nconst successHosts = (0, (_map || _load_map()).default)();\nconst controlOffline = (_network || _load_network()).isOffline();\n\nclass RequestManager {\n  constructor(reporter) {\n    this.offlineNoRequests = false;\n    this._requestCaptureHar = null;\n    this._requestModule = null;\n    this.offlineQueue = [];\n    this.captureHar = false;\n    this.httpsProxy = null;\n    this.ca = null;\n    this.httpProxy = null;\n    this.strictSSL = true;\n    this.userAgent = '';\n    this.reporter = reporter;\n    this.running = 0;\n    this.queue = [];\n    this.cache = {};\n    this.max = (_constants || _load_constants()).NETWORK_CONCURRENCY;\n  }\n\n  setOptions(opts) {\n    if (opts.userAgent != null) {\n      this.userAgent = opts.userAgent;\n    }\n\n    if (opts.offline != null) {\n      this.offlineNoRequests = opts.offline;\n    }\n\n    if (opts.captureHar != null) {\n      this.captureHar = opts.captureHar;\n    }\n\n    if (opts.httpProxy != null) {\n      this.httpProxy = opts.httpProxy;\n    }\n\n    if (opts.httpsProxy != null) {\n      this.httpsProxy = opts.httpsProxy;\n    }\n\n    if (opts.strictSSL !== null && typeof opts.strictSSL !== 'undefined') {\n      this.strictSSL = opts.strictSSL;\n    }\n\n    if (opts.ca != null && opts.ca.length > 0) {\n      this.ca = opts.ca;\n    }\n\n    if (opts.networkConcurrency != null) {\n      this.max = opts.networkConcurrency;\n    }\n\n    if (opts.cafile != null && opts.cafile != '') {\n      // The CA bundle file can contain one or more certificates with comments/text between each PEM block.\n      // tls.connect wants an array of certificates without any comments/text, so we need to split the string\n      // and strip out any text in between the certificates\n      try {\n        const bundle = fs.readFileSync(opts.cafile).toString();\n        const hasPemPrefix = block => block.startsWith('-----BEGIN ');\n        // opts.cafile overrides opts.ca, this matches with npm behavior\n        this.ca = bundle.split(/(-----BEGIN .*\\r?\\n[^-]+\\r?\\n--.*)/).filter(hasPemPrefix);\n      } catch (err) {\n        this.reporter.error(`Could not open cafile: ${err.message}`);\n      }\n    }\n\n    if (opts.cert != null) {\n      this.cert = opts.cert;\n    }\n\n    if (opts.key != null) {\n      this.key = opts.key;\n    }\n  }\n\n  /**\n   * Lazy load `request` since it is exceptionally expensive to load and is\n   * often not needed at all.\n   */\n\n  _getRequestModule() {\n    if (!this._requestModule) {\n      const request = require('request');\n      if (this.captureHar) {\n        this._requestCaptureHar = new RequestCaptureHar(request);\n        this._requestModule = this._requestCaptureHar.request.bind(this._requestCaptureHar);\n      } else {\n        this._requestModule = request;\n      }\n    }\n    return this._requestModule;\n  }\n\n  /**\n   * Queue up a request.\n   */\n\n  request(params) {\n    if (this.offlineNoRequests) {\n      return Promise.reject(new (_errors || _load_errors()).MessageError(this.reporter.lang('cantRequestOffline')));\n    }\n\n    const cached = this.cache[params.url];\n    if (cached) {\n      return cached;\n    }\n\n    params.method = params.method || 'GET';\n    params.forever = true;\n    params.retryAttempts = 0;\n    params.strictSSL = this.strictSSL;\n    params.headers = Object.assign({\n      'User-Agent': this.userAgent\n    }, params.headers);\n\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({ params, resolve, reject });\n      this.shiftQueue();\n    });\n\n    // we can't cache a request with a processor\n    if (!params.process) {\n      this.cache[params.url] = promise;\n    }\n\n    return promise;\n  }\n\n  /**\n   * Clear the request cache. This is important as we cache all HTTP requests so you'll\n   * want to do this as soon as you can.\n   */\n\n  clearCache() {\n    this.cache = {};\n    if (this._requestCaptureHar != null) {\n      this._requestCaptureHar.clear();\n    }\n  }\n\n  /**\n   * Check if an error is possibly due to lost or poor network connectivity.\n   */\n\n  isPossibleOfflineError(err) {\n    const code = err.code,\n          hostname = err.hostname;\n\n    if (!code) {\n      return false;\n    }\n\n    // network was previously online but now we're offline\n    const possibleOfflineChange = !controlOffline && !(_network || _load_network()).isOffline();\n    if (code === 'ENOTFOUND' && possibleOfflineChange) {\n      // can't resolve a domain\n      return true;\n    }\n\n    // used to be able to resolve this domain! something is wrong\n    if (code === 'ENOTFOUND' && hostname && successHosts[hostname]) {\n      // can't resolve this domain but we've successfully resolved it before\n      return true;\n    }\n\n    // network was previously offline and we can't resolve the domain\n    if (code === 'ENOTFOUND' && controlOffline) {\n      return true;\n    }\n\n    // connection was reset or dropped\n    if (code === 'ECONNRESET') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Queue up request arguments to be retried. Start a network connectivity timer if there\n   * isn't already one.\n   */\n\n  queueForOffline(opts) {\n    if (!this.offlineQueue.length) {\n      this.reporter.warn(this.reporter.lang('offlineRetrying'));\n      this.initOfflineRetry();\n    }\n\n    this.offlineQueue.push(opts);\n  }\n\n  /**\n   * Begin timers to retry failed requests when we possibly establish network connectivity\n   * again.\n   */\n\n  initOfflineRetry() {\n    setTimeout(() => {\n      const queue = this.offlineQueue;\n      this.offlineQueue = [];\n      for (const opts of queue) {\n        this.execute(opts);\n      }\n    }, 3000);\n  }\n\n  /**\n   * Execute a request.\n   */\n\n  execute(opts) {\n    const params = opts.params;\n    const reporter = this.reporter;\n\n\n    const buildNext = fn => data => {\n      fn(data);\n      this.running--;\n      this.shiftQueue();\n    };\n\n    const resolve = buildNext(opts.resolve);\n\n    const rejectNext = buildNext(opts.reject);\n    const reject = function (err) {\n      err.message = `${params.url}: ${err.message}`;\n      rejectNext(err);\n    };\n\n    //\n    let calledOnError = false;\n    const onError = err => {\n      if (calledOnError) {\n        return;\n      }\n      calledOnError = true;\n\n      const attempts = params.retryAttempts || 0;\n      if (attempts < 5 && this.isPossibleOfflineError(err)) {\n        params.retryAttempts = attempts + 1;\n        if (typeof params.cleanup === 'function') {\n          params.cleanup();\n        }\n        this.queueForOffline(opts);\n      } else {\n        reject(err);\n      }\n    };\n\n    if (!params.process) {\n      const parts = url.parse(params.url);\n\n      params.callback = (err, res, body) => {\n        if (err) {\n          onError(err);\n          return;\n        }\n\n        successHosts[parts.hostname] = true;\n\n        this.reporter.verbose(this.reporter.lang('verboseRequestFinish', params.url, res.statusCode));\n\n        if (body && typeof body.error === 'string') {\n          reject(new Error(body.error));\n          return;\n        }\n\n        if (res.statusCode === 403) {\n          const errMsg = body && body.message || reporter.lang('requestError', params.url, res.statusCode);\n          reject(new Error(errMsg));\n        } else {\n          if (res.statusCode === 400 || res.statusCode === 404 || res.statusCode === 401) {\n            body = false;\n          }\n          resolve(body);\n        }\n      };\n    }\n\n    if (params.buffer) {\n      params.encoding = null;\n    }\n\n    let proxy = this.httpProxy;\n    if (params.url.startsWith('https:')) {\n      proxy = this.httpsProxy || proxy;\n    }\n    if (proxy) {\n      params.proxy = proxy;\n    }\n\n    if (this.ca != null) {\n      params.ca = this.ca;\n    }\n\n    if (this.cert != null) {\n      params.cert = this.cert;\n    }\n\n    if (this.key != null) {\n      params.key = this.key;\n    }\n\n    const request = this._getRequestModule();\n    const req = request(params);\n    this.reporter.verbose(this.reporter.lang('verboseRequestStart', params.method, params.url));\n\n    req.on('error', onError);\n\n    const queue = params.queue;\n    if (queue) {\n      req.on('data', queue.stillActive.bind(queue));\n    }\n\n    if (params.process) {\n      params.process(req, resolve, reject);\n    }\n  }\n\n  /**\n   * Remove an item from the queue. Create it's request options and execute it.\n   */\n\n  shiftQueue() {\n    if (this.running >= this.max || !this.queue.length) {\n      return;\n    }\n\n    const opts = this.queue.shift();\n\n    this.running++;\n    this.execute(opts);\n  }\n\n  saveHar(filename) {\n    if (!this.captureHar) {\n      throw new Error(this.reporter.lang('requestManagerNotSetupHAR'));\n    }\n    // No request may have occurred at all.\n    this._getRequestModule();\n    invariant(this._requestCaptureHar != null, 'request-capture-har not setup');\n    this._requestCaptureHar.saveHar(filename);\n  }\n}\nexports.default = RequestManager;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/map.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = nullify;\nfunction nullify() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (Array.isArray(obj)) {\n    for (const item of obj) {\n      nullify(item);\n    }\n  } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {\n    Object.setPrototypeOf(obj, null);\n\n    // for..in can only be applied to 'object', not 'function'\n    if (typeof obj === 'object') {\n      for (const key in obj) {\n        nullify(obj[key]);\n      }\n    }\n  }\n\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/network.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOffline = isOffline;\nconst os = require('os');\n\nconst IGNORE_INTERFACES = ['lo0', 'awdl0', 'bridge0'];\nconst LOCAL_IPS = ['127.0.0.1', '::1'];\n\nfunction isOffline() {\n  let interfaces;\n\n  try {\n    interfaces = os.networkInterfaces();\n  } catch (e) {\n    // As of October 2016, Windows Subsystem for Linux (WSL) does not support\n    // the os.networkInterfaces() call and throws instead. For this platform,\n    // assume we are online.\n    if (e.syscall === 'uv_interface_addresses') {\n      return false;\n    } else {\n      throw e;\n    }\n  }\n\n  for (const name in interfaces) {\n    if (IGNORE_INTERFACES.indexOf(name) >= 0) {\n      continue;\n    }\n\n    const addrs = interfaces[name];\n    for (const addr of addrs) {\n      if (LOCAL_IPS.indexOf(addr.address) < 0) {\n        // found a possible remote ip\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/constants.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathKey = getPathKey;\nexports.isRootUser = isRootUser;\nconst path = require('path');\nconst userHome = require('./util/user-home-dir').default;\n\nconst DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];\n\nconst YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';\n\nconst YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';\nconst YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';\nconst YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';\n\nconst SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version';\nconst SELF_UPDATE_TARBALL_URL = exports.SELF_UPDATE_TARBALL_URL = 'https://yarnpkg.com/latest.tar.gz';\nconst SELF_UPDATE_DOWNLOAD_FOLDER = exports.SELF_UPDATE_DOWNLOAD_FOLDER = 'updates';\n\n// cache version, bump whenever we make backwards incompatible changes\nconst CACHE_VERSION = exports.CACHE_VERSION = 1;\n\n// lockfile version, bump whenever we make backwards incompatible changes\nconst LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1;\n\n// max amount of network requests to perform concurrently\nconst NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8;\n\n// max amount of child processes to execute concurrently\nconst CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;\n\nconst REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];\n\nfunction getDirectory(category) {\n  // use %LOCALAPPDATA%/Yarn on Windows\n  if (process.platform === 'win32' && process.env.LOCALAPPDATA) {\n    return path.join(process.env.LOCALAPPDATA, 'Yarn', category);\n  }\n\n  // otherwise use ~/.{category}/yarn\n  return path.join(userHome, `.${category}`, 'yarn');\n}\n\nfunction getCacheDirectory() {\n  if (process.platform === 'darwin') {\n    return path.join(userHome, 'Library', 'Caches', 'Yarn');\n  }\n\n  return getDirectory('cache');\n}\n\nconst MODULE_CACHE_DIRECTORY = exports.MODULE_CACHE_DIRECTORY = getCacheDirectory();\nconst CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getDirectory('config');\nconst LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(CONFIG_DIRECTORY, 'link');\nconst GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(CONFIG_DIRECTORY, 'global');\nconst CACHE_FILENAME = exports.CACHE_FILENAME = path.join(MODULE_CACHE_DIRECTORY, '.roadrunner.json');\n\nconst INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';\nconst LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';\nconst METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';\nconst TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';\nconst CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';\n\nconst DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';\nconst SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;\nconst SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';\n\nconst ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);\n\nfunction getPathKey(platform, env) {\n  let pathKey = 'PATH';\n\n  // windows calls its path \"Path\" usually, but this is not guaranteed.\n  if (platform === 'win32') {\n    pathKey = 'Path';\n\n    for (const key in env) {\n      if (key.toLowerCase() === 'path') {\n        pathKey = key;\n      }\n    }\n  }\n\n  return pathKey;\n}\n\nfunction getUid() {\n  if (process.platform !== 'win32' && process.getuid) {\n    return process.getuid();\n  }\n  return null;\n}\n\nconst ROOT_USER = exports.ROOT_USER = isRootUser(getUid());\n\nfunction isRootUser(uid) {\n  return uid === 0;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/user-home-dir.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst path = require('path');\n\nvar _require = require('../constants');\n\nconst ROOT_USER = _require.ROOT_USER;\n\n\nconst userHomeDir = process.platform === 'linux' && ROOT_USER ? path.resolve('/usr/local/share') : require('os').homedir();\n\nexports.default = userHomeDir;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/console/util.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearLine = clearLine;\nexports.toStartOfLine = toStartOfLine;\nexports.writeOnNthLine = writeOnNthLine;\nexports.clearNthLine = clearNthLine;\n\n\nconst readline = require('readline');\n\nvar _require = require('chalk');\n\nconst supportsColor = _require.supportsColor;\n\n\nconst CLEAR_WHOLE_LINE = 0;\nconst CLEAR_RIGHT_OF_CURSOR = 1;\n\nfunction clearLine(stdout) {\n  if (!supportsColor) {\n    return;\n  }\n\n  readline.clearLine(stdout, CLEAR_WHOLE_LINE);\n  readline.cursorTo(stdout, 0);\n}\n\nfunction toStartOfLine(stdout) {\n  if (!supportsColor) {\n    return;\n  }\n\n  readline.cursorTo(stdout, 0);\n}\n\nfunction writeOnNthLine(stdout, n, msg) {\n  if (!supportsColor) {\n    return;\n  }\n\n  if (n == 0) {\n    readline.cursorTo(stdout, 0);\n    stdout.write(msg);\n    readline.clearLine(stdout, CLEAR_RIGHT_OF_CURSOR);\n    return;\n  }\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, -n);\n  stdout.write(msg);\n  readline.clearLine(stdout, CLEAR_RIGHT_OF_CURSOR);\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, n);\n}\n\nfunction clearNthLine(stdout, n) {\n  if (!supportsColor) {\n    return;\n  }\n\n  if (n == 0) {\n    clearLine(stdout);\n    return;\n  }\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, -n);\n  readline.clearLine(stdout, CLEAR_WHOLE_LINE);\n  readline.moveCursor(stdout, 0, n);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/fs.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeTempDir = exports.hardlinksWork = exports.writeFilePreservingEol = exports.getFileSizeOnDisk = exports.walk = exports.symlink = exports.find = exports.readJsonAndFile = exports.readJson = exports.readFileAny = exports.hardlinkBulk = exports.copyBulk = exports.link = exports.chmod = exports.lstat = exports.exists = exports.mkdirp = exports.unlink = exports.stat = exports.access = exports.rename = exports.readdir = exports.realpath = exports.readlink = exports.writeFile = exports.readFileBuffer = exports.lockQueue = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet buildActionsForCopy = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n        files.add(dest);\n\n        if (events.ignoreBasenames.indexOf(path.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        if (yield exists(dest)) {\n          const destStat = yield lstat(dest);\n\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          if (srcStat.mode !== destStat.mode) {\n            try {\n              yield access(dest, srcStat.mode);\n            } catch (err) {\n              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n              // us modes that aren't valid. investigate this, it's generally safe to proceed.\n            }\n          }\n\n          if (bothFiles && srcStat.size === destStat.size && +srcStat.mtime === +destStat.mtime) {\n            // we can safely assume this is the same file\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.size, +srcStat.mtime));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (const file of destFiles) {\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = path.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (const file of yield readdir(loc)) {\n                    possibleExtraneous.add(path.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.push({\n            type: 'symlink',\n            dest,\n            linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          reporter.verbose(reporter.lang('verboseFileFolder', dest));\n          yield mkdirp(dest);\n\n          const destParts = dest.split(path.sep);\n          while (destParts.length) {\n            files.add(destParts.join(path.sep));\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (const file of srcFiles) {\n            queue.push({\n              onFresh,\n              src: path.join(src, file),\n              dest: path.join(dest, file),\n              onDone: function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              }\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.push({\n            type: 'file',\n            src,\n            dest,\n            atime: srcStat.atime,\n            mtime: srcStat.mtime,\n            mode: srcStat.mode\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new Set(events.artifactFiles || []);\n    const files = new Set();\n\n    // initialise events\n    for (const item of queue) {\n      const onDone = item.onDone;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        if (onDone) {\n          onDone();\n        }\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = [];\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield Promise.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraenous\n    for (const file of artifactFiles) {\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (const loc of possibleExtraneous) {\n      if (files.has(loc)) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForCopy(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet buildActionsForHardlink = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n        files.add(dest);\n\n        if (events.ignoreBasenames.indexOf(path.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        const destExists = yield exists(dest);\n        if (destExists) {\n          const destStat = yield lstat(dest);\n\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          if (srcStat.mode !== destStat.mode) {\n            try {\n              yield access(dest, srcStat.mode);\n            } catch (err) {\n              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n              // us modes that aren't valid. investigate this, it's generally safe to proceed.\n              reporter.verbose(err);\n            }\n          }\n\n          // correct hardlink\n          if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.ino));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (const file of destFiles) {\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = path.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (const file of yield readdir(loc)) {\n                    possibleExtraneous.add(path.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.push({\n            type: 'symlink',\n            dest,\n            linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          reporter.verbose(reporter.lang('verboseFileFolder', dest));\n          yield mkdirp(dest);\n\n          const destParts = dest.split(path.sep);\n          while (destParts.length) {\n            files.add(destParts.join(path.sep));\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (const file of srcFiles) {\n            queue.push({\n              onFresh,\n              src: path.join(src, file),\n              dest: path.join(dest, file),\n              onDone: function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              }\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.push({\n            type: 'link',\n            src,\n            dest,\n            removeDest: destExists\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x10) {\n        return _ref4.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new Set(events.artifactFiles || []);\n    const files = new Set();\n\n    // initialise events\n    for (const item of queue) {\n      const onDone = item.onDone;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        if (onDone) {\n          onDone();\n        }\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = [];\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield Promise.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraenous\n    for (const file of artifactFiles) {\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (const loc of possibleExtraneous) {\n      if (files.has(loc)) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForHardlink(_x6, _x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nlet copyBulk = exports.copyBulk = (() => {\n  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n      ignoreBasenames: _events && _events.ignoreBasenames || [],\n      artifactFiles: _events && _events.artifactFiles || []\n    };\n\n    const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.length);\n\n    const fileActions = actions.filter(function (action) {\n      return action.type === 'file';\n    });\n\n    const currentlyWriting = {};\n\n    yield (_promise || _load_promise()).queue(fileActions, (() => {\n      var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        let writePromise;\n        while (writePromise = currentlyWriting[data.dest]) {\n          yield writePromise;\n        }\n\n        const cleanup = function () {\n          return delete currentlyWriting[data.dest];\n        };\n        return currentlyWriting[data.dest] = new Promise(function (resolve, reject) {\n          const readStream = fs.createReadStream(data.src);\n          const writeStream = fs.createWriteStream(data.dest, { mode: data.mode });\n\n          reporter.verbose(reporter.lang('verboseFileCopy', data.src, data.dest));\n\n          readStream.on('error', reject);\n          writeStream.on('error', reject);\n\n          writeStream.on('open', function () {\n            readStream.pipe(writeStream);\n          });\n\n          writeStream.once('finish', function () {\n            fs.utimes(data.dest, data.atime, data.mtime, function (err) {\n              if (err) {\n                reject(err);\n              } else {\n                events.onProgress(data.dest);\n                cleanup();\n                resolve();\n              }\n            });\n          });\n        }).then(function (arg) {\n          cleanup();\n          return arg;\n        }).catch(function (arg) {\n          cleanup();\n          throw arg;\n        });\n      });\n\n      return function (_x14) {\n        return _ref6.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.filter(function (action) {\n      return action.type === 'symlink';\n    });\n    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n      const linkname = path.resolve(path.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function copyBulk(_x11, _x12, _x13) {\n    return _ref5.apply(this, arguments);\n  };\n})();\n\nlet hardlinkBulk = exports.hardlinkBulk = (() => {\n  var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n      artifactFiles: _events && _events.artifactFiles || [],\n      ignoreBasenames: []\n    };\n\n    const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.length);\n\n    const fileActions = actions.filter(function (action) {\n      return action.type === 'link';\n    });\n\n    yield (_promise || _load_promise()).queue(fileActions, (() => {\n      var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        reporter.verbose(reporter.lang('verboseFileLink', data.src, data.dest));\n        if (data.removeDest) {\n          yield unlink(data.dest);\n        }\n        yield link(data.src, data.dest);\n      });\n\n      return function (_x18) {\n        return _ref8.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.filter(function (action) {\n      return action.type === 'symlink';\n    });\n    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n      const linkname = path.resolve(path.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function hardlinkBulk(_x15, _x16, _x17) {\n    return _ref7.apply(this, arguments);\n  };\n})();\n\nlet readFileAny = exports.readFileAny = (() => {\n  var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {\n    for (const file of files) {\n      if (yield exists(file)) {\n        return readFile(file);\n      }\n    }\n    return null;\n  });\n\n  return function readFileAny(_x19) {\n    return _ref9.apply(this, arguments);\n  };\n})();\n\nlet readJson = exports.readJson = (() => {\n  var _ref10 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    return (yield readJsonAndFile(loc)).object;\n  });\n\n  return function readJson(_x20) {\n    return _ref10.apply(this, arguments);\n  };\n})();\n\nlet readJsonAndFile = exports.readJsonAndFile = (() => {\n  var _ref11 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const file = yield readFile(loc);\n    try {\n      return {\n        object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),\n        content: file\n      };\n    } catch (err) {\n      err.message = `${loc}: ${err.message}`;\n      throw err;\n    }\n  });\n\n  return function readJsonAndFile(_x21) {\n    return _ref11.apply(this, arguments);\n  };\n})();\n\nlet find = exports.find = (() => {\n  var _ref12 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {\n    const parts = dir.split(path.sep);\n\n    while (parts.length) {\n      const loc = parts.concat(filename).join(path.sep);\n\n      if (yield exists(loc)) {\n        return loc;\n      } else {\n        parts.pop();\n      }\n    }\n\n    return false;\n  });\n\n  return function find(_x22, _x23) {\n    return _ref12.apply(this, arguments);\n  };\n})();\n\nlet symlink = exports.symlink = (() => {\n  var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    try {\n      const stats = yield lstat(dest);\n\n      if (stats.isSymbolicLink() && (yield exists(dest))) {\n        const resolved = yield realpath(dest);\n        if (resolved === src) {\n          return;\n        }\n      }\n\n      yield unlink(dest);\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n\n    try {\n      if (process.platform === 'win32') {\n        // use directory junctions if possible on win32, this requires absolute paths\n        yield fsSymlink(src, dest, 'junction');\n      } else {\n        // use relative paths otherwise which will be retained if the directory is moved\n        let relative;\n        if (yield exists(src)) {\n          relative = path.relative(fs.realpathSync(path.dirname(dest)), fs.realpathSync(src));\n        } else {\n          relative = path.relative(path.dirname(dest), src);\n        }\n        yield fsSymlink(relative, dest);\n      }\n    } catch (err) {\n      if (err.code === 'EEXIST') {\n        // race condition\n        yield symlink(src, dest);\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  return function symlink(_x24, _x25) {\n    return _ref13.apply(this, arguments);\n  };\n})();\n\nlet walk = exports.walk = (() => {\n  var _ref14 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir) {\n    let ignoreBasenames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n\n    let files = [];\n\n    let filenames = yield readdir(dir);\n    if (ignoreBasenames.size) {\n      filenames = filenames.filter(function (name) {\n        return !ignoreBasenames.has(name);\n      });\n    }\n\n    for (const name of filenames) {\n      const relative = relativeDir ? path.join(relativeDir, name) : name;\n      const loc = path.join(dir, name);\n      const stat = yield lstat(loc);\n\n      files.push({\n        relative,\n        basename: name,\n        absolute: loc,\n        mtime: +stat.mtime\n      });\n\n      if (stat.isDirectory()) {\n        files = files.concat((yield walk(loc, relative, ignoreBasenames)));\n      }\n    }\n\n    return files;\n  });\n\n  return function walk(_x26, _x27) {\n    return _ref14.apply(this, arguments);\n  };\n})();\n\nlet getFileSizeOnDisk = exports.getFileSizeOnDisk = (() => {\n  var _ref15 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const stat = yield lstat(loc);\n    const size = stat.size,\n          blockSize = stat.blksize;\n\n\n    return Math.ceil(size / blockSize) * blockSize;\n  });\n\n  return function getFileSizeOnDisk(_x29) {\n    return _ref15.apply(this, arguments);\n  };\n})();\n\nlet getEolFromFile = (() => {\n  var _ref16 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {\n    if (!(yield exists(path))) {\n      return undefined;\n    }\n\n    const buffer = yield readFileBuffer(path);\n\n    for (let i = 0; i < buffer.length; ++i) {\n      if (buffer[i] === cr) {\n        return '\\r\\n';\n      }\n      if (buffer[i] === lf) {\n        return '\\n';\n      }\n    }\n    return undefined;\n  });\n\n  return function getEolFromFile(_x30) {\n    return _ref16.apply(this, arguments);\n  };\n})();\n\nlet writeFilePreservingEol = exports.writeFilePreservingEol = (() => {\n  var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {\n    const eol = (yield getEolFromFile(path)) || os.EOL;\n    if (eol !== '\\n') {\n      data = data.replace(/\\n/g, eol);\n    }\n    yield (0, (_promise2 || _load_promise2()).promisify)(fs.writeFile)(path, data);\n  });\n\n  return function writeFilePreservingEol(_x31, _x32) {\n    return _ref17.apply(this, arguments);\n  };\n})();\n\nlet hardlinksWork = exports.hardlinksWork = (() => {\n  var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {\n    const filename = 'test-file' + Math.random();\n    const file = path.join(dir, filename);\n    const fileLink = path.join(dir, filename + '-link');\n    try {\n      yield writeFile(file, 'test');\n      yield link(file, fileLink);\n    } catch (err) {\n      return false;\n    } finally {\n      yield unlink(file);\n      yield unlink(fileLink);\n    }\n    return true;\n  });\n\n  return function hardlinksWork(_x33) {\n    return _ref18.apply(this, arguments);\n  };\n})();\n\n// not a strict polyfill for Node's fs.mkdtemp\n\n\nlet makeTempDir = exports.makeTempDir = (() => {\n  var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {\n    const dir = path.join(os.tmpdir(), `yarn-${prefix || ''}-${Date.now()}-${Math.random()}`);\n    yield unlink(dir);\n    yield mkdirp(dir);\n    return dir;\n  });\n\n  return function makeTempDir(_x34) {\n    return _ref19.apply(this, arguments);\n  };\n})();\n\nexports.copy = copy;\nexports.readFile = readFile;\nexports.readFileRaw = readFileRaw;\nexports.normalizeOS = normalizeOS;\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./promise.js'));\n}\n\nvar _promise2;\n\nfunction _load_promise2() {\n  return _promise2 = require('./promise.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst fs = require('fs');\nconst os = require('os');\n\nconst lockQueue = exports.lockQueue = new (_blockingQueue || _load_blockingQueue()).default('fs lock');\n\nconst readFileBuffer = exports.readFileBuffer = (0, (_promise2 || _load_promise2()).promisify)(fs.readFile);\nconst writeFile = exports.writeFile = (0, (_promise2 || _load_promise2()).promisify)(fs.writeFile);\nconst readlink = exports.readlink = (0, (_promise2 || _load_promise2()).promisify)(fs.readlink);\nconst realpath = exports.realpath = (0, (_promise2 || _load_promise2()).promisify)(fs.realpath);\nconst readdir = exports.readdir = (0, (_promise2 || _load_promise2()).promisify)(fs.readdir);\nconst rename = exports.rename = (0, (_promise2 || _load_promise2()).promisify)(fs.rename);\nconst access = exports.access = (0, (_promise2 || _load_promise2()).promisify)(fs.access);\nconst stat = exports.stat = (0, (_promise2 || _load_promise2()).promisify)(fs.stat);\nconst unlink = exports.unlink = (0, (_promise2 || _load_promise2()).promisify)(require('rimraf'));\nconst mkdirp = exports.mkdirp = (0, (_promise2 || _load_promise2()).promisify)(require('mkdirp'));\nconst exists = exports.exists = (0, (_promise2 || _load_promise2()).promisify)(fs.exists, true);\nconst lstat = exports.lstat = (0, (_promise2 || _load_promise2()).promisify)(fs.lstat);\nconst chmod = exports.chmod = (0, (_promise2 || _load_promise2()).promisify)(fs.chmod);\nconst link = exports.link = (0, (_promise2 || _load_promise2()).promisify)(fs.link);\n\nconst CONCURRENT_QUEUE_ITEMS = 4;\n\nconst fsSymlink = (0, (_promise2 || _load_promise2()).promisify)(fs.symlink);\nconst invariant = require('invariant');\nconst stripBOM = require('strip-bom');\n\nconst noop = () => {};\n\nfunction copy(src, dest, reporter) {\n  return copyBulk([{ src, dest }], reporter);\n}\n\nfunction _readFile(loc, encoding) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(loc, encoding, function (err, content) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(content);\n      }\n    });\n  });\n}\n\nfunction readFile(loc) {\n  return _readFile(loc, 'utf8').then(normalizeOS);\n}\n\nfunction readFileRaw(loc) {\n  return _readFile(loc, 'binary');\n}\n\nfunction normalizeOS(body) {\n  return body.replace(/\\r\\n/g, '\\n');\n}\n\nconst cr = new Buffer('\\r', 'utf8')[0];\nconst lf = new Buffer('\\n', 'utf8')[0];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/blocking-queue.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = require('debug')('yarn');\n\nclass BlockingQueue {\n  constructor(alias) {\n    let maxConcurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n    this.concurrencyQueue = [];\n    this.maxConcurrency = maxConcurrency;\n    this.runningCount = 0;\n    this.warnedStuck = false;\n    this.alias = alias;\n    this.first = true;\n\n    this.running = (0, (_map || _load_map()).default)();\n    this.queue = (0, (_map || _load_map()).default)();\n\n    this.stuckTick = this.stuckTick.bind(this);\n  }\n\n  stillActive() {\n    if (this.stuckTimer) {\n      clearTimeout(this.stuckTimer);\n    }\n\n    this.stuckTimer = setTimeout(this.stuckTick, 5000);\n  }\n\n  stuckTick() {\n    if (this.runningCount === 1) {\n      this.warnedStuck = true;\n      debug(`The ${JSON.stringify(this.alias)} blocking queue may be stuck. 5 seconds ` + `without any activity with 1 worker: ${Object.keys(this.running)[0]}`);\n    }\n  }\n\n  push(key, factory) {\n    if (this.first) {\n      this.first = false;\n    } else {\n      this.stillActive();\n    }\n\n    return new Promise((resolve, reject) => {\n      // we're already running so push ourselves to the queue\n      const queue = this.queue[key] = this.queue[key] || [];\n      queue.push({ factory, resolve, reject });\n\n      if (!this.running[key]) {\n        this.shift(key);\n      }\n    });\n  }\n\n  shift(key) {\n    if (this.running[key]) {\n      delete this.running[key];\n      this.runningCount--;\n\n      if (this.warnedStuck) {\n        this.warnedStuck = false;\n        debug(`${JSON.stringify(this.alias)} blocking queue finally resolved. Nothing to worry about.`);\n      }\n    }\n\n    const queue = this.queue[key];\n    if (!queue) {\n      return;\n    }\n\n    var _queue$shift = queue.shift();\n\n    const resolve = _queue$shift.resolve,\n          reject = _queue$shift.reject,\n          factory = _queue$shift.factory;\n\n    if (!queue.length) {\n      delete this.queue[key];\n    }\n\n    const next = () => {\n      this.shift(key);\n      this.shiftConcurrencyQueue();\n    };\n\n    const run = () => {\n      this.running[key] = true;\n      this.runningCount++;\n\n      factory().then(function (val) {\n        resolve(val);\n        next();\n        return null;\n      }).catch(function (err) {\n        reject(err);\n        next();\n      });\n    };\n\n    this.maybePushConcurrencyQueue(run);\n  }\n\n  maybePushConcurrencyQueue(run) {\n    if (this.runningCount < this.maxConcurrency) {\n      run();\n    } else {\n      this.concurrencyQueue.push(run);\n    }\n  }\n\n  shiftConcurrencyQueue() {\n    if (this.runningCount < this.maxConcurrency) {\n      const fn = this.concurrencyQueue.shift();\n      if (fn) {\n        fn();\n      }\n    }\n  }\n}\nexports.default = BlockingQueue;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/promise.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wait = wait;\nexports.promisify = promisify;\nexports.promisifyObject = promisifyObject;\nexports.queue = queue;\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\nfunction promisify(fn, firstData) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise(function (resolve, reject) {\n      args.push(function (err) {\n        for (var _len2 = arguments.length, result = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          result[_key2 - 1] = arguments[_key2];\n        }\n\n        let res = result;\n\n        if (result.length <= 1) {\n          res = result[0];\n        }\n\n        if (firstData) {\n          res = err;\n          err = null;\n        }\n\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n}\n\nfunction promisifyObject(obj) {\n  const promisedObj = {};\n  for (const key in obj) {\n    promisedObj[key] = promisify(obj[key]);\n  }\n  return promisedObj;\n}\n\nfunction queue(arr, promiseProducer) {\n  let concurrency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n  concurrency = Math.min(concurrency, arr.length);\n\n  // clone\n  arr = arr.slice();\n\n  const results = [];\n  let total = arr.length;\n  if (!total) {\n    return Promise.resolve(results);\n  }\n\n  return new Promise((resolve, reject) => {\n    for (let i = 0; i < concurrency; i++) {\n      next();\n    }\n\n    function next() {\n      const item = arr.shift();\n      const promise = promiseProducer(item);\n\n      promise.then(function (result) {\n        results.push(result);\n\n        total--;\n        if (total === 0) {\n          resolve(results);\n        } else {\n          if (arr.length) {\n            next();\n          }\n        }\n      }, reject);\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/api.js":"\"use strict\";","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/errors.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MessageError extends Error {\n  constructor(msg, code) {\n    super(msg);\n    this.code = code;\n  }\n\n}\n\nexports.MessageError = MessageError;\nclass SecurityError extends MessageError {}\n\nexports.SecurityError = SecurityError;\nclass SpawnError extends MessageError {}\nexports.SpawnError = SpawnError;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-compatibility.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nexports.testEngine = testEngine;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst semver = require('semver');\n\nconst VERSIONS = (0, (_assign || _load_assign()).default)({}, process.versions, {\n  yarn: require('../package.json').version\n});\n\nfunction isValid(items, actual) {\n  let isNotWhitelist = true;\n  let isBlacklist = false;\n\n  for (const item of items) {\n    // blacklist\n    if (item[0] === '!') {\n      isBlacklist = true;\n\n      if (actual === item.slice(1)) {\n        return false;\n      }\n      // whitelist\n    } else {\n      isNotWhitelist = false;\n\n      if (item === actual) {\n        return true;\n      }\n    }\n  }\n\n  // npm allows blacklists and whitelists to be mixed. Blacklists with\n  // whitelisted items should be treated as whitelists.\n  return isBlacklist && isNotWhitelist;\n}\n\nconst aliases = (0, (_map || _load_map()).default)({\n  iojs: 'node' });\n\nconst ignore = ['npm', // we'll never satisfy this for obvious reasons\n'teleport', // a module bundler used by some modules\n'rhino'];\n\nfunction testEngine(name, range, versions, looseSemver) {\n  const actual = versions[name];\n  if (!actual) {\n    return false;\n  }\n\n  if (!semver.valid(actual, looseSemver)) {\n    return false;\n  }\n\n  if (semver.satisfies(actual, range, looseSemver)) {\n    return true;\n  }\n\n  if (name === 'node' && semver.gt(actual, '1.0.0', looseSemver)) {\n    // WARNING: this is a massive hack and is super gross but necessary for compatibility\n    // some modules have the `engines.node` field set to a caret version below semver major v1\n    // eg. ^0.12.0. this is problematic as we enforce engines checks and node is now on version >=1\n    // to allow this pattern we transform the node version to fake ones in the minor range 10-13\n    const major = semver.major(actual, looseSemver);\n    const fakes = [`0.10.${major}`, `0.11.${major}`, `0.12.${major}`, `0.13.${major}`];\n    for (const actualFake of fakes) {\n      if (semver.satisfies(actualFake, range, looseSemver)) {\n        return true;\n      }\n    }\n  }\n\n  // incompatible version\n  return false;\n}\n\nclass PackageCompatibility {\n  constructor(config, resolver, ignoreEngines) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n    this.ignoreEngines = ignoreEngines;\n  }\n\n  static isValidArch(archs) {\n    return isValid(archs, process.arch);\n  }\n\n  static isValidPlatform(platforms) {\n    return isValid(platforms, process.platform);\n  }\n\n  check(info) {\n    let didIgnore = false;\n    let didError = false;\n    const reporter = this.reporter;\n    const human = `${info.name}@${info.version}`;\n\n    const pushError = msg => {\n      const ref = info._reference;\n      invariant(ref, 'expected package reference');\n\n      if (ref.optional) {\n        ref.ignore = true;\n\n        reporter.warn(`${human}: ${msg}`);\n        if (!didIgnore) {\n          reporter.info(reporter.lang('optionalCompatibilityExcluded', human));\n          didIgnore = true;\n        }\n      } else {\n        reporter.error(`${human}: ${msg}`);\n        didError = true;\n      }\n    };\n\n    const invalidPlatform = !this.config.ignorePlatform && Array.isArray(info.os) && info.os.length > 0 && !PackageCompatibility.isValidPlatform(info.os);\n    if (invalidPlatform) {\n      pushError(this.reporter.lang('incompatibleOS', process.platform));\n    }\n\n    const invalidCpu = !this.config.ignorePlatform && Array.isArray(info.cpu) && info.cpu.length > 0 && !PackageCompatibility.isValidArch(info.cpu);\n    if (invalidCpu) {\n      pushError(this.reporter.lang('incompatibleCPU', process.arch));\n    }\n\n    if (!this.ignoreEngines && typeof info.engines === 'object') {\n      for (const entry of (0, (_misc || _load_misc()).entries)(info.engines)) {\n        let name = entry[0];\n        const range = entry[1];\n\n        if (aliases[name]) {\n          name = aliases[name];\n        }\n\n        if (VERSIONS[name]) {\n          if (!testEngine(name, range, VERSIONS, this.config.looseSemver)) {\n            pushError(this.reporter.lang('incompatibleEngine', name, range));\n          }\n        } else if (ignore.indexOf(name) < 0) {\n          this.reporter.warn(`${human}: ${this.reporter.lang('invalidEngine', name)}`);\n        }\n      }\n    }\n\n    if (didError) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundIncompatible'));\n    }\n  }\n\n  init() {\n    const infos = this.resolver.getManifests();\n    for (const info of infos) {\n      this.check(info);\n    }\n    return (_promise || _load_promise()).default.resolve();\n  }\n}\nexports.default = PackageCompatibility;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/map.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _setPrototypeOf;\n\nfunction _load_setPrototypeOf() {\n  return _setPrototypeOf = _interopRequireDefault(require('babel-runtime/core-js/object/set-prototype-of'));\n}\n\nexports.default = nullify;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction nullify() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (Array.isArray(obj)) {\n    for (const item of obj) {\n      nullify(item);\n    }\n  } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {\n    (0, (_setPrototypeOf || _load_setPrototypeOf()).default)(obj, null);\n\n    // for..in can only be applied to 'object', not 'function'\n    if (typeof obj === 'object') {\n      for (const key in obj) {\n        nullify(obj[key]);\n      }\n    }\n  }\n\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-constraint-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst semver = require('semver');\n\n// This isn't really a \"proper\" constraint resolver. We just return the highest semver\n// version in the versions passed that satisfies the input range. This vastly reduces\n// the complexity and is very efficient for package resolution.\n\nclass PackageConstraintResolver {\n  constructor(config, reporter) {\n    this.reporter = reporter;\n    this.config = config;\n  }\n\n  reduce(versions, range) {\n    if (range === 'latest') {\n      // Usually versions are already ordered and the last one is the latest\n      return (_promise || _load_promise()).default.resolve(versions[versions.length - 1]);\n    } else {\n      return (_promise || _load_promise()).default.resolve(semver.maxSatisfying(versions, range, this.config.looseSemver));\n    }\n  }\n}\nexports.default = PackageConstraintResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./fetchers/index.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageFetcher {\n  constructor(config, resolver) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n  }\n\n  fetchCache(dest, fetcher) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref = yield _this.config.readPackageMetadata(dest);\n\n      const hash = _ref.hash,\n            pkg = _ref.package;\n\n      return {\n        package: pkg,\n        resolved: yield fetcher.getResolvedFromCached(hash),\n        hash: hash,\n        dest: dest,\n        cached: true\n      };\n    })();\n  }\n\n  fetch(ref) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const dest = _this2.config.generateHardModulePath(ref);\n\n      const remote = ref.remote;\n      const Fetcher = (_index || _load_index())[remote.type];\n      if (!Fetcher) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('unknownFetcherFor', remote.type));\n      }\n\n      const fetcher = new Fetcher(dest, remote, _this2.config);\n\n      if (yield _this2.config.isValidModuleDest(dest)) {\n        return _this2.fetchCache(dest, fetcher);\n      }\n\n      // remove as the module may be invalid\n      yield (_fs || _load_fs()).unlink(dest);\n\n      try {\n        return yield fetcher.fetch();\n      } catch (err) {\n        try {\n          yield (_fs || _load_fs()).unlink(dest);\n        } catch (err2) {\n          // what do?\n        }\n        throw err;\n      }\n    })();\n  }\n\n  maybeFetch(ref) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield _this3.fetch(ref);\n      } catch (err) {\n        if (ref.optional) {\n          _this3.reporter.error(err.message);\n          return null;\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  init() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const pkgs = _this4.resolver.getPackageReferences();\n      const tick = _this4.reporter.progress(pkgs.length);\n\n      yield (_promise || _load_promise()).queue(pkgs, (() => {\n        var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (ref) {\n          const res = yield _this4.maybeFetch(ref);\n          let newPkg;\n\n          if (res) {\n            newPkg = res.package;\n\n            // update with new remote\n            // but only if there was a hash previously as the tarball fetcher does not provide a hash.\n            if (ref.remote.hash) {\n              ref.remote.hash = res.hash;\n            }\n\n            if (res.resolved) {\n              ref.remote.resolved = res.resolved;\n            }\n          }\n\n          if (newPkg) {\n            // update with fresh manifest\n            yield _this4.resolver.updateManifest(ref, newPkg);\n          }\n\n          if (tick) {\n            tick(ref.name);\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      })(), _this4.config.networkConcurrency);\n    })();\n  }\n}\nexports.default = PackageFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-hoister.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HoistManifest = undefined;\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('babel-runtime/core-js/map'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nlet historyCounter = 0;\n\nclass HoistManifest {\n  constructor(key, parts, pkg, loc, isIgnored, inheritIsIgnored) {\n    this.isIgnored = isIgnored;\n    this.inheritIsIgnored = inheritIsIgnored;\n    this.loc = loc;\n    this.pkg = pkg;\n\n    this.key = key;\n    this.parts = parts;\n    this.originalKey = key;\n    this.previousKeys = [];\n\n    this.history = [];\n    this.addHistory(`Start position = ${key}`);\n  }\n\n  addHistory(msg) {\n    this.history.push(`${++historyCounter}: ${msg}`);\n  }\n}\n\nexports.HoistManifest = HoistManifest;\nclass PackageHoister {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.config = config;\n\n    this.taintedKeys = new (_map || _load_map()).default();\n    this.levelQueue = [];\n    this.tree = new (_map || _load_map()).default();\n  }\n\n  /**\n   * Taint this key and prevent any modules from being hoisted to it.\n   */\n\n  taintKey(key, info) {\n    const existingTaint = this.taintedKeys.get(key);\n    if (existingTaint && existingTaint.loc !== info.loc) {\n      return false;\n    } else {\n      this.taintedKeys.set(key, info);\n      return true;\n    }\n  }\n\n  /**\n   * Implode an array of ancestry parts into a key.\n   */\n\n  implodeKey(parts) {\n    return parts.join('#');\n  }\n\n  /**\n   * Seed the hoister with patterns taken from the included resolver.\n   */\n\n  seed(patterns) {\n    this.prepass(patterns);\n\n    for (const pattern of this.resolver.dedupePatterns(patterns)) {\n      this._seed(pattern);\n    }\n\n    while (true) {\n      let queue = this.levelQueue;\n      if (!queue.length) {\n        this._propagateNonIgnored();\n        return;\n      }\n\n      this.levelQueue = [];\n\n      // sort queue to get determinism between runs\n      queue = queue.sort((_ref, _ref2) => {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 1);\n\n        let aPattern = _ref4[0];\n\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 1);\n\n        let bPattern = _ref3[0];\n\n        return (0, (_misc || _load_misc()).sortAlpha)(aPattern, bPattern);\n      });\n\n      //\n      const infos = [];\n      for (const _ref5 of queue) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const pattern = _ref6[0];\n        const parents = _ref6[1];\n\n        const info = this._seed(pattern, parents);\n        if (info) {\n          infos.push(info);\n        }\n      }\n\n      //\n      for (const info of infos) {\n        this.hoist(info);\n      }\n    }\n  }\n\n  /**\n   * Seed the hoister with a specific pattern.\n   */\n\n  _seed(pattern, parent) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(pattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    let parentParts = [];\n    let isIgnored = ref.ignore;\n    let inheritIsIgnored = false;\n\n    if (parent) {\n      if (!this.tree.get(parent.key)) {\n        return null;\n      }\n      // non ignored dependencies inherit parent's ignored status\n      // parent may transition from ignored to non ignored when hoisted if it is used in another non ignored branch\n      if (!isIgnored && parent.isIgnored) {\n        isIgnored = parent.isIgnored;\n        inheritIsIgnored = true;\n      }\n      parentParts = parent.parts;\n    }\n\n    //\n    const loc = this.config.generateHardModulePath(ref);\n    const parts = parentParts.concat(pkg.name);\n    const key = this.implodeKey(parts);\n    const info = new HoistManifest(key, parts, pkg, loc, isIgnored, inheritIsIgnored);\n\n    //\n    this.tree.set(key, info);\n    this.taintKey(key, info);\n\n    //\n    for (const depPattern of ref.dependencies) {\n      this.levelQueue.push([depPattern, info]);\n    }\n\n    return info;\n  }\n\n  /**\n   * Propagate inherited ignore statuses from non-ignored to ignored packages\n  */\n\n  _propagateNonIgnored() {\n    //\n    const toVisit = [];\n\n    // enumerate all non-ignored packages\n    for (const entry of this.tree.entries()) {\n      if (!entry[1].isIgnored) {\n        toVisit.push(entry[1]);\n      }\n    }\n\n    // visit them\n    while (toVisit.length) {\n      const info = toVisit.shift();\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      for (const depPattern of ref.dependencies) {\n        const depinfo = this._lookupDependency(info, depPattern);\n        if (depinfo && depinfo.isIgnored && depinfo.inheritIsIgnored) {\n          depinfo.isIgnored = false;\n          info.addHistory(`Mark as non-ignored because of usage by ${info.key}`);\n          toVisit.push(depinfo);\n        }\n      }\n    }\n  }\n\n  /**\n   * Looks up the package a dependency resolves to\n  */\n\n  _lookupDependency(info, depPattern) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(depPattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    for (let i = info.parts.length; i >= 0; i--) {\n      const checkParts = info.parts.slice(0, i).concat(pkg.name);\n      const checkKey = this.implodeKey(checkParts);\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the highest position we can hoist this module to.\n   */\n\n  getNewParts(key, info, parts) {\n    let stepUp = false;\n\n    const fullKey = this.implodeKey(parts);\n    const stack = []; // stack of removed parts\n    const name = parts.pop();\n\n    //\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const checkParts = parts.slice(0, i).concat(name);\n      const checkKey = this.implodeKey(checkParts);\n      info.addHistory(`Looked at ${checkKey} for a match`);\n\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        if (existing.loc === info.loc) {\n          // switch to non ignored if earlier deduped version was ignored\n          if (existing.isIgnored && !info.isIgnored) {\n            existing.isIgnored = info.isIgnored;\n          }\n\n          existing.addHistory(`Deduped ${fullKey} to this item`);\n          return { parts: checkParts, duplicate: true };\n        } else {\n          // everything above will be shadowed and this is a conflict\n          info.addHistory(`Found a collision at ${checkKey}`);\n          break;\n        }\n      }\n\n      const existingTaint = this.taintedKeys.get(checkKey);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        info.addHistory(`Broken by ${checkKey}`);\n        break;\n      }\n    }\n\n    // remove redundant parts that wont collide\n    while (parts.length) {\n      const checkParts = parts.concat(name);\n      const checkKey = this.implodeKey(checkParts);\n\n      //\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        stepUp = true;\n        break;\n      }\n\n      // check if we're trying to hoist ourselves to a previously unflattened module key,\n      // this will result in a conflict and we'll need to move ourselves up\n      if (key !== checkKey && this.taintedKeys.has(checkKey)) {\n        stepUp = true;\n        break;\n      }\n\n      //\n      stack.push(parts.pop());\n    }\n\n    //\n    parts.push(name);\n\n    //\n    const isValidPosition = parts => {\n      const key = this.implodeKey(parts);\n      const existing = this.tree.get(key);\n      if (existing && existing.loc === info.loc) {\n        return true;\n      }\n\n      // ensure there's no taint or the taint is us\n      const existingTaint = this.taintedKeys.get(key);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        return false;\n      }\n\n      return true;\n    };\n\n    // we need to special case when we attempt to hoist to the top level as the `existing` logic\n    // wont be hit in the above `while` loop and we could conflict\n    if (!isValidPosition(parts)) {\n      stepUp = true;\n    }\n\n    // sometimes we need to step up to a parent module to install ourselves\n    while (stepUp && stack.length) {\n      info.addHistory(`Stepping up from ${this.implodeKey(parts)}`);\n\n      parts.pop(); // remove `name`\n      parts.push(stack.pop(), name);\n\n      if (isValidPosition(parts)) {\n        info.addHistory(`Found valid position ${this.implodeKey(parts)}`);\n        stepUp = false;\n      }\n    }\n\n    return { parts: parts, duplicate: false };\n  }\n\n  /**\n   * Hoist all seeded patterns to their highest positions.\n   */\n\n  hoist(info) {\n    const key = info.key,\n          rawParts = info.parts;\n\n    // remove this item from the `tree` map so we can ignore it\n\n    this.tree.delete(key);\n\n    var _getNewParts = this.getNewParts(key, info, rawParts.slice());\n\n    const parts = _getNewParts.parts,\n          duplicate = _getNewParts.duplicate;\n\n    const newKey = this.implodeKey(parts);\n    const oldKey = key;\n    if (duplicate) {\n      info.addHistory(`Satisfied from above by ${newKey}`);\n      this.declareRename(info, rawParts, parts);\n      return;\n    }\n\n    // update to the new key\n    if (oldKey === newKey) {\n      info.addHistory(\"Didn't hoist - conflicts above\");\n      this.setKey(info, oldKey, parts);\n      return;\n    }\n\n    //\n    this.declareRename(info, rawParts, parts);\n    this.setKey(info, newKey, parts);\n  }\n\n  /**\n   * Declare that a module has been hoisted and update our internal references.\n   */\n\n  declareRename(info, oldParts, newParts) {\n    // go down the tree from our new position reserving our name\n    this.taintParents(info, oldParts.slice(0, -1), newParts.length - 1);\n  }\n\n  /**\n   * Crawl upwards through a list of ancestry parts and taint a package name.\n   */\n\n  taintParents(info, processParts, start) {\n    for (let i = start; i < processParts.length; i++) {\n      const parts = processParts.slice(0, i).concat(info.pkg.name);\n      const key = this.implodeKey(parts);\n\n      if (this.taintKey(key, info)) {\n        info.addHistory(`Tainted ${key} to prevent collisions`);\n      }\n    }\n  }\n\n  /**\n   * Update the key of a module and update our references.\n   */\n\n  setKey(info, newKey, parts) {\n    const oldKey = info.key;\n\n    info.key = newKey;\n    info.parts = parts;\n    this.tree.set(newKey, info);\n\n    if (oldKey === newKey) {\n      return;\n    }\n\n    info.previousKeys.push(newKey);\n    info.addHistory(`New position = ${newKey}`);\n  }\n\n  /**\n   * Perform a prepass and if there's multiple versions of the same package, hoist the one with\n   * the most dependents to the top.\n   */\n\n  prepass(patterns) {\n    patterns = this.resolver.dedupePatterns(patterns).sort();\n\n    const occurences = {};\n\n    // add an occuring package to the above data structure\n    const add = (pattern, ancestry) => {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      if (ancestry.indexOf(pkg) >= 0) {\n        // prevent recursive dependencies\n        return;\n      }\n\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n\n      const versions = occurences[pkg.name] = occurences[pkg.name] || {};\n      const version = versions[pkg.version] = versions[pkg.version] || { occurences: new (_set || _load_set()).default(), pattern: pattern };\n      version.occurences.add(ancestry[ancestry.length - 1]);\n\n      for (const depPattern of ref.dependencies) {\n        add(depPattern, ancestry.concat(pkg));\n      }\n    };\n\n    // get a list of root package names since we can't hoist other dependencies to these spots!\n    const rootPackageNames = new (_set || _load_set()).default();\n    for (const pattern of patterns) {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      rootPackageNames.add(pkg.name);\n    }\n\n    // seed occurences\n    for (const pattern of patterns) {\n      add(pattern, []);\n    }\n\n    for (const packageName of (0, (_keys || _load_keys()).default)(occurences).sort()) {\n      const versionOccurences = occurences[packageName];\n      const versions = (0, (_keys || _load_keys()).default)(versionOccurences);\n\n      if (versions.length === 1) {\n        // only one package type so we'll hoist this to the top anyway\n        continue;\n      }\n\n      if (this.tree.get(packageName)) {\n        // a transitive dependency of a previously hoisted dependency exists\n        continue;\n      }\n\n      if (rootPackageNames.has(packageName)) {\n        // can't replace top level packages\n        continue;\n      }\n\n      let mostOccurenceCount;\n      let mostOccurencePattern;\n      for (const version of (0, (_keys || _load_keys()).default)(versionOccurences).sort()) {\n        var _versionOccurences$ve = versionOccurences[version];\n        const occurences = _versionOccurences$ve.occurences,\n              pattern = _versionOccurences$ve.pattern;\n\n        const occurenceCount = occurences.size;\n\n        if (!mostOccurenceCount || occurenceCount > mostOccurenceCount) {\n          mostOccurenceCount = occurenceCount;\n          mostOccurencePattern = pattern;\n        }\n      }\n      invariant(mostOccurencePattern, 'expected most occuring pattern');\n      invariant(mostOccurenceCount, 'expected most occuring count');\n\n      // only hoist this module if it occured more than once\n      if (mostOccurenceCount > 1) {\n        this._seed(mostOccurencePattern);\n      }\n    }\n  }\n\n  /**\n   * Produce a flattened list of module locations and manifests.\n   */\n\n  init() {\n    const flatTree = [];\n\n    //\n    for (const _ref7 of this.tree.entries()) {\n      var _ref8 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref7, 2);\n\n      const key = _ref8[0];\n      const info = _ref8[1];\n\n      // decompress the location and push it to the flat tree. this path could be made\n      const parts = [];\n      const keyParts = key.split('#');\n      for (let i = 0; i < keyParts.length; i++) {\n        const key = keyParts.slice(0, i + 1).join('#');\n        const hoisted = this.tree.get(key);\n        invariant(hoisted, 'expected hoisted manifest');\n        parts.push(this.config.getFolder(hoisted.pkg));\n        parts.push(keyParts[i]);\n      }\n\n      if (this.config.modulesFolder) {\n        // remove the first part which will be the folder name and replace it with a\n        // hardcoded modules folder\n        parts.shift();\n        const modulesFolder = this.config.modulesFolder == null ? '' : this.config.modulesFolder;\n        parts.unshift(modulesFolder);\n      } else {\n        // first part will be the registry-specific module folder\n        const cwd = this.config.cwd == null ? '' : this.config.cwd;\n        parts.unshift(cwd);\n      }\n\n      const loc = path.join.apply(path, parts);\n      flatTree.push([loc, info]);\n    }\n\n    // remove ignored modules from the tree\n    const visibleFlatTree = [];\n    for (const _ref9 of flatTree) {\n      var _ref10 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref9, 2);\n\n      const loc = _ref10[0];\n      const info = _ref10[1];\n\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      if (info.isIgnored) {\n        info.addHistory('Deleted as this module was ignored');\n      } else {\n        visibleFlatTree.push([loc, info]);\n      }\n    }\n    return visibleFlatTree;\n  }\n}\n\nexports.default = PackageHoister;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-install-scripts.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('babel-runtime/core-js/map'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = _interopRequireDefault(require('./util/execute-lifecycle-script.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst INSTALL_STAGES = ['preinstall', 'install', 'postinstall'];\n\nclass PackageInstallScripts {\n  constructor(config, resolver, force) {\n    this.installed = 0;\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n    this.force = force;\n  }\n\n  getInstallCommands(pkg) {\n    const scripts = pkg.scripts;\n    if (scripts) {\n      const cmds = [];\n      for (const stage of INSTALL_STAGES) {\n        const cmd = scripts[stage];\n        if (cmd) {\n          cmds.push([stage, cmd]);\n        }\n      }\n      return cmds;\n    } else {\n      return [];\n    }\n  }\n\n  walk(loc) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const files = yield (_fs || _load_fs()).walk(loc, null, new (_set || _load_set()).default(_this.config.registryFolders));\n      const mtimes = new (_map || _load_map()).default();\n      for (const file of files) {\n        mtimes.set(file.relative, file.mtime);\n      }\n      return mtimes;\n    })();\n  }\n\n  saveBuildArtifacts(loc, pkg, beforeFiles, spinner) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const afterFiles = yield _this2.walk(loc);\n\n      // work out what files have been created/modified\n      const buildArtifacts = [];\n      for (const _ref of afterFiles) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const file = _ref2[0];\n        const mtime = _ref2[1];\n\n        if (!beforeFiles.has(file) || beforeFiles.get(file) !== mtime) {\n          buildArtifacts.push(file);\n        }\n      }\n\n      if (!buildArtifacts.length) {\n        // nothing else to do here since we have no build artifacts\n        return;\n      }\n\n      // if the process is killed while copying over build artifacts then we'll leave\n      // the cache in a bad state. remove the metadata file and add it back once we've\n      // done our copies to ensure cache integrity.\n      const cachedLoc = _this2.config.generateHardModulePath(pkg._reference, true);\n      const metadata = yield _this2.config.readPackageMetadata(cachedLoc);\n      metadata.artifacts = buildArtifacts;\n\n      const metadataLoc = path.join(cachedLoc, (_constants || _load_constants()).METADATA_FILENAME);\n      yield (_fs || _load_fs()).writeFile(metadataLoc, (0, (_stringify || _load_stringify()).default)((0, (_extends2 || _load_extends()).default)({}, metadata, {\n\n        // config.readPackageMetadata also returns the package manifest but that's not in the original\n        // metadata json\n        package: undefined\n      }), null, '  '));\n    })();\n  }\n\n  install(cmds, pkg, spinner) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const loc = _this3.config.generateHardModulePath(ref);\n\n      try {\n        for (const _ref3 of cmds) {\n          var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 2);\n\n          const stage = _ref4[0];\n          const cmd = _ref4[1];\n\n          yield (0, (_executeLifecycleScript || _load_executeLifecycleScript()).default)(stage, _this3.config, loc, cmd, spinner);\n        }\n      } catch (err) {\n        err.message = `${loc}: ${err.message}`;\n\n        invariant(ref, 'expected reference');\n\n        if (ref.optional) {\n          ref.ignore = true;\n          _this3.reporter.warn(_this3.reporter.lang('optionalModuleScriptFail', err.message));\n          _this3.reporter.info(_this3.reporter.lang('optionalModuleFail'));\n\n          // Cleanup node_modules\n          try {\n            yield (_fs || _load_fs()).unlink(loc);\n          } catch (e) {\n            _this3.reporter.error(_this3.reporter.lang('optionalModuleCleanupFail', e.message));\n          }\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  packageCanBeInstalled(pkg) {\n    const cmds = this.getInstallCommands(pkg);\n    if (!cmds.length) {\n      return false;\n    }\n    const ref = pkg._reference;\n    invariant(ref, 'Missing package reference');\n    if (!ref.fresh && !this.force) {\n      // this package hasn't been touched\n      return false;\n    }\n\n    // we haven't actually written this module out\n    if (ref.ignore) {\n      return false;\n    }\n    return true;\n  }\n\n  runCommand(spinner, pkg) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const cmds = _this4.getInstallCommands(pkg);\n      spinner.setPrefix(++_this4.installed, pkg.name);\n      yield _this4.install(cmds, pkg, spinner);\n    })();\n  }\n\n  // detect if there is a circularDependency in the dependency tree\n  detectCircularDependencies(root, seenManifests, pkg) {\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    const deps = ref.dependencies;\n    for (const dep of deps) {\n      const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n      if (seenManifests.has(pkgDep)) {\n        // there is a cycle but not with the root\n        continue;\n      }\n      seenManifests.add(pkgDep);\n      // found a dependency pointing to root\n      if (pkgDep == root) {\n        return true;\n      }\n      if (this.detectCircularDependencies(root, seenManifests, pkgDep)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // find the next package to be installed\n  findInstallablePackage(workQueue, installed) {\n    for (const pkg of workQueue) {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const deps = ref.dependencies;\n\n      let dependenciesFullfilled = true;\n      for (const dep of deps) {\n        const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n        if (!installed.has(pkgDep)) {\n          dependenciesFullfilled = false;\n          break;\n        }\n      }\n\n      // all depedencies are installed\n      if (dependenciesFullfilled) {\n        return pkg;\n      }\n\n      // detect circular dependency, mark this pkg as installable to break the circle\n      if (this.detectCircularDependencies(pkg, new (_set || _load_set()).default(), pkg)) {\n        return pkg;\n      }\n    }\n    return null;\n  }\n\n  worker(spinner, workQueue, installed, waitQueue) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      while (true) {\n        // No more work to be done\n        if (workQueue.size == 0) {\n          break;\n        }\n\n        // find a installable package\n        const pkg = _this5.findInstallablePackage(workQueue, installed);\n\n        // can't find a package to install, register into waitQueue\n        if (pkg == null) {\n          spinner.clear();\n          yield new (_promise || _load_promise()).default(function (resolve) {\n            return waitQueue.add(resolve);\n          });\n          continue;\n        }\n\n        // found a package to install\n        workQueue.delete(pkg);\n        if (_this5.packageCanBeInstalled(pkg)) {\n          yield _this5.runCommand(spinner, pkg);\n        }\n        installed.add(pkg);\n        for (const workerResolve of waitQueue) {\n          workerResolve();\n        }\n        waitQueue.clear();\n      }\n    })();\n  }\n\n  init(seedPatterns) {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const workQueue = new (_set || _load_set()).default();\n      const installed = new (_set || _load_set()).default();\n      const pkgs = _this6.resolver.getTopologicalManifests(seedPatterns);\n      let installablePkgs = 0;\n      // A map to keep track of what files exist before installation\n      const beforeFilesMap = new (_map || _load_map()).default();\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          beforeFilesMap.set(loc, (yield _this6.walk(loc)));\n          installablePkgs += 1;\n        }\n        workQueue.add(pkg);\n      }\n\n      // waitQueue acts like a semaphore to allow workers to register to be notified\n      // when there are more work added to the work queue\n      const waitQueue = new (_set || _load_set()).default();\n      const workers = [];\n\n      const set = _this6.reporter.activitySet(installablePkgs, Math.min((_constants || _load_constants()).CHILD_CONCURRENCY, workQueue.size));\n\n      for (const spinner of set.spinners) {\n        workers.push(_this6.worker(spinner, workQueue, installed, waitQueue));\n      }\n\n      yield (_promise || _load_promise()).default.all(workers);\n\n      // cache all build artifacts\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          const beforeFiles = beforeFilesMap.get(loc);\n          invariant(beforeFiles, 'files before installation should always be recorded');\n          yield _this6.saveBuildArtifacts(loc, pkg, beforeFiles, set.spinners[0]);\n        }\n      }\n\n      set.end();\n    })();\n  }\n}\nexports.default = PackageInstallScripts;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-linker.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linkBin = undefined;\n\nvar _from;\n\nfunction _load_from() {\n  return _from = _interopRequireDefault(require('babel-runtime/core-js/array/from'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('babel-runtime/core-js/map'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet linkBin = exports.linkBin = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    if (process.platform === 'win32') {\n      const unlockMutex = yield (0, (_mutex || _load_mutex()).default)(src);\n      try {\n        yield cmdShim(src, dest);\n      } finally {\n        unlockMutex();\n      }\n    } else {\n      yield (_fs || _load_fs()).mkdirp(path.dirname(dest));\n      yield (_fs || _load_fs()).symlink(src, dest);\n      yield (_fs || _load_fs()).chmod(dest, '755');\n    }\n  });\n\n  return function linkBin(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _packageHoister;\n\nfunction _load_packageHoister() {\n  return _packageHoister = _interopRequireDefault(require('./package-hoister.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _promise2;\n\nfunction _load_promise2() {\n  return _promise2 = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _mutex;\n\nfunction _load_mutex() {\n  return _mutex = _interopRequireDefault(require('./util/mutex.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst cmdShim = (_promise2 || _load_promise2()).promisify(require('cmd-shim'));\nconst semver = require('semver');\nconst path = require('path');\n\nclass PackageLinker {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n  }\n\n  linkSelfDependencies(pkg, pkgLoc, targetBinLoc) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      targetBinLoc = yield (_fs || _load_fs()).realpath(targetBinLoc);\n      pkgLoc = yield (_fs || _load_fs()).realpath(pkgLoc);\n      for (const _ref2 of (0, (_misc || _load_misc()).entries)(pkg.bin)) {\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 2);\n\n        const scriptName = _ref3[0];\n        const scriptCmd = _ref3[1];\n\n        const dest = path.join(targetBinLoc, scriptName);\n        const src = path.join(pkgLoc, scriptCmd);\n        if (!(yield (_fs || _load_fs()).exists(src))) {\n          // TODO maybe throw an error\n          continue;\n        }\n        yield linkBin(src, dest);\n      }\n    })();\n  }\n\n  linkBinDependencies(pkg, dir) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const deps = [];\n\n      const ref = pkg._reference;\n      invariant(ref, 'Package reference is missing');\n\n      const remote = pkg._remote;\n      invariant(remote, 'Package remote is missing');\n\n      // link up `bin scripts` in `dependencies`\n      for (const pattern of ref.dependencies) {\n        const dep = _this.resolver.getStrictResolvedPattern(pattern);\n        if (dep.bin && (0, (_keys || _load_keys()).default)(dep.bin).length) {\n          deps.push({ dep: dep, loc: _this.config.generateHardModulePath(dep._reference) });\n        }\n      }\n\n      // link up the `bin` scripts in bundled dependencies\n      if (pkg.bundleDependencies) {\n        for (const depName of pkg.bundleDependencies) {\n          const loc = path.join(_this.config.generateHardModulePath(ref), _this.config.getFolder(pkg), depName);\n\n          const dep = yield _this.config.readManifest(loc, remote.registry);\n\n          if (dep.bin && (0, (_keys || _load_keys()).default)(dep.bin).length) {\n            deps.push({ dep: dep, loc: loc });\n          }\n        }\n      }\n\n      // no deps to link\n      if (!deps.length) {\n        return;\n      }\n\n      // ensure our .bin file we're writing these to exists\n      const binLoc = path.join(dir, '.bin');\n      yield (_fs || _load_fs()).mkdirp(binLoc);\n\n      // write the executables\n      for (const _ref4 of deps) {\n        const dep = _ref4.dep;\n        const loc = _ref4.loc;\n\n        yield _this.linkSelfDependencies(dep, loc, binLoc);\n      }\n    })();\n  }\n\n  getFlatHoistedTree(patterns) {\n    const hoister = new (_packageHoister || _load_packageHoister()).default(this.config, this.resolver);\n    hoister.seed(patterns);\n    return (_promise || _load_promise()).default.resolve(hoister.init());\n  }\n\n  copyModules(patterns, linkDuplicates) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let flatTree = yield _this2.getFlatHoistedTree(patterns);\n\n      // sorted tree makes file creation and copying not to interfere with each other\n      flatTree = flatTree.sort(function (dep1, dep2) {\n        return dep1[0].localeCompare(dep2[0]);\n      });\n\n      // list of artifacts in modules to remove from extraneous removal\n      const artifactFiles = [];\n\n      const copyQueue = new (_map || _load_map()).default();\n      const hardlinkQueue = new (_map || _load_map()).default();\n      const hardlinksEnabled = linkDuplicates && (yield (_fs || _load_fs()).hardlinksWork(_this2.config.cwd));\n\n      const copiedSrcs = new (_map || _load_map()).default();\n      for (const _ref5 of flatTree) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const dest = _ref6[0];\n        var _ref6$ = _ref6[1];\n        const pkg = _ref6$.pkg;\n        const src = _ref6$.loc;\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected package reference');\n        ref.setLocation(dest);\n\n        // get a list of build artifacts contained in this module so we can prevent them from being marked as\n        // extraneous\n        const metadata = yield _this2.config.readPackageMetadata(src);\n        for (const file of metadata.artifacts) {\n          artifactFiles.push(path.join(dest, file));\n        }\n\n        const copiedDest = copiedSrcs.get(src);\n        if (!copiedDest) {\n          if (hardlinksEnabled) {\n            copiedSrcs.set(src, dest);\n          }\n          copyQueue.set(dest, {\n            src: src,\n            dest: dest,\n            onFresh: function onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        } else {\n          hardlinkQueue.set(dest, {\n            src: copiedDest,\n            dest: dest,\n            onFresh: function onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        }\n      }\n\n      // keep track of all scoped paths to remove empty scopes after copy\n      const scopedPaths = new (_set || _load_set()).default();\n\n      // register root & scoped packages as being possibly extraneous\n      const possibleExtraneous = new (_set || _load_set()).default();\n      for (const folder of _this2.config.registryFolders) {\n        const loc = path.join(_this2.config.cwd, folder);\n\n        if (yield (_fs || _load_fs()).exists(loc)) {\n          const files = yield (_fs || _load_fs()).readdir(loc);\n          let filepath;\n          for (const file of files) {\n            filepath = path.join(loc, file);\n            if (file[0] === '@') {\n              // it's a scope, not a package\n              scopedPaths.add(filepath);\n              const subfiles = yield (_fs || _load_fs()).readdir(filepath);\n              for (const subfile of subfiles) {\n                possibleExtraneous.add(path.join(filepath, subfile));\n              }\n            } else {\n              possibleExtraneous.add(filepath);\n            }\n          }\n        }\n      }\n\n      // linked modules\n      for (const loc of possibleExtraneous) {\n        const stat = yield (_fs || _load_fs()).lstat(loc);\n        if (stat.isSymbolicLink()) {\n          possibleExtraneous.delete(loc);\n          copyQueue.delete(loc);\n        }\n      }\n\n      //\n      let tick;\n      yield (_fs || _load_fs()).copyBulk((0, (_from || _load_from()).default)(copyQueue.values()), _this2.reporter, {\n        possibleExtraneous: possibleExtraneous,\n        artifactFiles: artifactFiles,\n\n        ignoreBasenames: [(_constants || _load_constants()).METADATA_FILENAME, (_constants || _load_constants()).TARBALL_FILENAME],\n\n        onStart: function onStart(num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress: function onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n      yield (_fs || _load_fs()).hardlinkBulk((0, (_from || _load_from()).default)(hardlinkQueue.values()), _this2.reporter, {\n        possibleExtraneous: possibleExtraneous,\n        artifactFiles: artifactFiles,\n\n        onStart: function onStart(num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress: function onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n\n      // remove all extraneous files that weren't in the tree\n      for (const loc of possibleExtraneous) {\n        _this2.reporter.verbose(_this2.reporter.lang('verboseFileRemoveExtraneous', loc));\n        yield (_fs || _load_fs()).unlink(loc);\n      }\n\n      // remove any empty scoped directories\n      for (const scopedPath of scopedPaths) {\n        const files = yield (_fs || _load_fs()).readdir(scopedPath);\n        if (files.length === 0) {\n          yield (_fs || _load_fs()).unlink(scopedPath);\n        }\n      }\n\n      //\n      if (_this2.config.binLinks) {\n        const tickBin = _this2.reporter.progress(flatTree.length);\n        yield (_promise2 || _load_promise2()).queue(flatTree, (() => {\n          var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref7) {\n            var _ref9 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref7, 2);\n\n            let dest = _ref9[0],\n                pkg = _ref9[1].pkg;\n\n            const binLoc = path.join(dest, _this2.config.getFolder(pkg));\n            yield _this2.linkBinDependencies(pkg, binLoc);\n            tickBin(dest);\n          });\n\n          return function (_x3) {\n            return _ref8.apply(this, arguments);\n          };\n        })(), 4);\n      }\n    })();\n  }\n\n  resolvePeerModules() {\n    for (const pkg of this.resolver.getManifests()) {\n      this._resolvePeerModules(pkg);\n    }\n  }\n\n  _resolvePeerModules(pkg) {\n    const peerDeps = pkg.peerDependencies;\n    if (!peerDeps) {\n      return;\n    }\n\n    const ref = pkg._reference;\n    invariant(ref, 'Package reference is missing');\n\n    for (const name in peerDeps) {\n      const range = peerDeps[name];\n      const patterns = this.resolver.patternsByPackage[name] || [];\n      const foundPattern = patterns.find(pattern => {\n        const resolvedPattern = this.resolver.getResolvedPattern(pattern);\n        return resolvedPattern ? this._satisfiesPeerDependency(range, resolvedPattern.version) : false;\n      });\n\n      if (foundPattern) {\n        ref.addDependencies([foundPattern]);\n      } else {\n        const depError = patterns.length > 0 ? 'incorrectPeer' : 'unmetPeer';\n        const pkgHuman = `${pkg.name}@${pkg.version}`,\n              depHuman = `${name}@${range}`;\n\n        this.reporter.warn(this.reporter.lang(depError, pkgHuman, depHuman));\n      }\n    }\n  }\n\n  _satisfiesPeerDependency(range, version) {\n    return range === '*' || semver.satisfies(version, range, this.config.looseSemver);\n  }\n\n  init(patterns, linkDuplicates) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this3.resolvePeerModules();\n      yield _this3.copyModules(patterns, linkDuplicates);\n      yield _this3.saveAll(patterns);\n    })();\n  }\n\n  save(pattern) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const resolved = _this4.resolver.getResolvedPattern(pattern);\n      invariant(resolved, `Couldn't find resolved name/version for ${pattern}`);\n\n      const ref = resolved._reference;\n      invariant(ref, 'Missing reference');\n\n      //\n      const src = _this4.config.generateHardModulePath(ref);\n\n      // link bins\n      if (_this4.config.binLinks && resolved.bin && (0, (_keys || _load_keys()).default)(resolved.bin).length && !ref.ignore) {\n        const folder = _this4.config.modulesFolder || path.join(_this4.config.cwd, _this4.config.getFolder(resolved));\n        const binLoc = path.join(folder, '.bin');\n        yield (_fs || _load_fs()).mkdirp(binLoc);\n        yield _this4.linkSelfDependencies(resolved, src, binLoc);\n      }\n    })();\n  }\n\n  saveAll(deps) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      deps = _this5.resolver.dedupePatterns(deps);\n      yield (_promise2 || _load_promise2()).queue(deps, function (dep) {\n        return _this5.save(dep);\n      });\n    })();\n  }\n}\nexports.default = PackageLinker;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/promise.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require(\"babel-runtime/core-js/promise\"));\n}\n\nexports.wait = wait;\nexports.promisify = promisify;\nexports.promisifyObject = promisifyObject;\nexports.queue = queue;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction wait(delay) {\n  return new (_promise || _load_promise()).default(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\nfunction promisify(fn, firstData) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new (_promise || _load_promise()).default(function (resolve, reject) {\n      args.push(function (err) {\n        for (var _len2 = arguments.length, result = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          result[_key2 - 1] = arguments[_key2];\n        }\n\n        let res = result;\n\n        if (result.length <= 1) {\n          res = result[0];\n        }\n\n        if (firstData) {\n          res = err;\n          err = null;\n        }\n\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n}\n\nfunction promisifyObject(obj) {\n  const promisedObj = {};\n  for (const key in obj) {\n    promisedObj[key] = promisify(obj[key]);\n  }\n  return promisedObj;\n}\n\nfunction queue(arr, promiseProducer) {\n  let concurrency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n  concurrency = Math.min(concurrency, arr.length);\n\n  // clone\n  arr = arr.slice();\n\n  const results = [];\n  let total = arr.length;\n  if (!total) {\n    return (_promise || _load_promise()).default.resolve(results);\n  }\n\n  return new (_promise || _load_promise()).default((resolve, reject) => {\n    for (let i = 0; i < concurrency; i++) {\n      next();\n    }\n\n    function next() {\n      const item = arr.shift();\n      const promise = promiseProducer(item);\n\n      promise.then(function (result) {\n        results.push(result);\n\n        total--;\n        if (total === 0) {\n          resolve(results);\n        } else {\n          if (arr.length) {\n            next();\n          }\n        }\n      }, reject);\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-reference.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageReference {\n  constructor(request, info, remote) {\n    this.resolver = request.resolver;\n    this.lockfile = request.lockfile;\n    this.requests = [];\n    this.config = request.config;\n\n    this.registry = remote.registry;\n    this.version = info.version;\n    this.name = info.name;\n    this.uid = info._uid;\n\n    this.remote = remote;\n\n    this.dependencies = [];\n\n    this.permissions = {};\n    this.patterns = [];\n    this.optional = null;\n    this.root = false;\n    this.ignore = false;\n    this.fresh = false;\n    this.location = null;\n    this.addRequest(request);\n  }\n\n  setFresh(fresh) {\n    this.fresh = fresh;\n  }\n\n  setLocation(loc) {\n    return this.location = loc;\n  }\n\n  addRequest(request) {\n    this.requests.push(request);\n\n    if (!request.parentRequest) {\n      this.root = true;\n    }\n  }\n\n  prune() {\n    for (const selfPattern of this.patterns) {\n      // remove ourselves from the resolver\n      this.resolver.removePattern(selfPattern);\n    }\n  }\n\n  addDependencies(deps) {\n    this.dependencies = this.dependencies.concat(deps);\n  }\n\n  setPermission(key, val) {\n    this.permissions[key] = val;\n  }\n\n  hasPermission(key) {\n    if (key in this.permissions) {\n      return this.permissions[key];\n    } else {\n      return false;\n    }\n  }\n\n  addPattern(pattern, manifest) {\n    this.resolver.addPattern(pattern, manifest);\n\n    this.patterns.push(pattern);\n\n    const shrunk = this.lockfile.getLocked(pattern);\n    if (shrunk && shrunk.permissions) {\n      for (const _ref of (0, (_misc || _load_misc()).entries)(shrunk.permissions)) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const key = _ref2[0];\n        const perm = _ref2[1];\n\n        this.setPermission(key, perm);\n      }\n    }\n  }\n\n  addOptional(optional) {\n    if (this.optional == null) {\n      // optional is uninitialised\n      this.optional = optional;\n    } else if (!optional) {\n      // otherwise, ignore all subsequent optional assignments and only accept ones making\n      // this not optional\n      this.optional = false;\n    }\n  }\n}\nexports.default = PackageReference;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-request.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = require('./util/normalize-manifest/validate.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _packageReference;\n\nfunction _load_packageReference() {\n  return _packageReference = _interopRequireDefault(require('./package-reference.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./resolvers/index.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('./resolvers/index.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('./util/version.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageRequest {\n  constructor(req, resolver) {\n    this.parentRequest = req.parentRequest;\n    this.lockfile = resolver.lockfile;\n    this.registry = req.registry;\n    this.reporter = resolver.reporter;\n    this.resolver = resolver;\n    this.optional = req.optional;\n    this.pattern = req.pattern;\n    this.config = resolver.config;\n\n    resolver.usedRegistries.add(req.registry);\n  }\n\n  static getExoticResolver(pattern) {\n    // TODO make this type more refined\n    for (const _ref of (0, (_misc || _load_misc()).entries)((_index || _load_index()).exotics)) {\n      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n      const Resolver = _ref2[1];\n\n      if (Resolver.isVersion(pattern)) {\n        return Resolver;\n      }\n    }\n    return null;\n  }\n\n  getParentNames() {\n    const chain = [];\n\n    let request = this.parentRequest;\n    while (request) {\n      const info = this.resolver.getStrictResolvedPattern(request.pattern);\n      chain.unshift(info.name);\n\n      request = request.parentRequest;\n    }\n\n    return chain;\n  }\n\n  getLocked(remoteType) {\n    // always prioritise root lockfile\n    const shrunk = this.lockfile.getLocked(this.pattern);\n\n    if (shrunk && shrunk.resolved) {\n      const resolvedParts = (_version || _load_version()).explodeHashedUrl(shrunk.resolved);\n\n      return {\n        name: shrunk.name,\n        version: shrunk.version,\n        _uid: shrunk.uid,\n        _remote: {\n          resolved: shrunk.resolved,\n          type: remoteType,\n          reference: resolvedParts.url,\n          hash: resolvedParts.hash,\n          registry: shrunk.registry\n        },\n        optionalDependencies: shrunk.optionalDependencies,\n        dependencies: shrunk.dependencies\n      };\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * If the input pattern matches a registry one then attempt to find it on the registry.\n   * Otherwise fork off to an exotic resolver if one matches.\n   */\n\n  findVersionOnRegistry(pattern) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref3 = yield _this.normalize(pattern);\n\n      const range = _ref3.range,\n            name = _ref3.name;\n\n\n      const exoticResolver = PackageRequest.getExoticResolver(range);\n      if (exoticResolver) {\n        let data = yield _this.findExoticVersionInfo(exoticResolver, range);\n\n        // clone data as we're manipulating it in place and this could be resolved multiple\n        // times\n        data = (0, (_assign || _load_assign()).default)({}, data);\n\n        // this is so the returned package response uses the overridden name. ie. if the\n        // package's actual name is `bar`, but it's been specified in the manifest like:\n        //   \"foo\": \"http://foo.com/bar.tar.gz\"\n        // then we use the foo name\n        data.name = name;\n\n        return data;\n      }\n\n      const Resolver = _this.getRegistryResolver();\n      const resolver = new Resolver(_this, name, range);\n      return resolver.resolve();\n    })();\n  }\n\n  /**\n   * Get the registry resolver associated with this package request.\n   */\n\n  getRegistryResolver() {\n    const Resolver = (_index2 || _load_index2()).registries[this.registry];\n    if (Resolver) {\n      return Resolver;\n    } else {\n      throw new (_errors || _load_errors()).MessageError(this.reporter.lang('unknownRegistryResolver', this.registry));\n    }\n  }\n\n  normalizeRange(pattern) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (pattern.includes(':') || pattern.includes('@') || PackageRequest.getExoticResolver(pattern)) {\n        return (_promise || _load_promise()).default.resolve(pattern);\n      }\n\n      if (yield (_fs || _load_fs()).exists(path.join(_this2.config.cwd, pattern))) {\n        return (_promise || _load_promise()).default.resolve(`file:${pattern}`);\n      }\n\n      return (_promise || _load_promise()).default.resolve(pattern);\n    })();\n  }\n\n  normalize(pattern) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _PackageRequest$norma = PackageRequest.normalizePattern(pattern);\n\n      const name = _PackageRequest$norma.name,\n            range = _PackageRequest$norma.range,\n            hasVersion = _PackageRequest$norma.hasVersion;\n\n      const newRange = yield _this3.normalizeRange(range);\n      return { name: name, range: newRange, hasVersion: hasVersion };\n    })();\n  }\n\n  /**\n   * Explode and normalize a pattern into it's name and range.\n   */\n\n  static normalizePattern(pattern) {\n    let hasVersion = false;\n    let range = 'latest';\n    let name = pattern;\n\n    // if we're a scope then remove the @ and add it back later\n    let isScoped = false;\n    if (name[0] === '@') {\n      isScoped = true;\n      name = name.slice(1);\n    }\n\n    // take first part as the name\n    const parts = name.split('@');\n    if (parts.length > 1) {\n      name = parts.shift();\n      range = parts.join('@');\n\n      if (range) {\n        hasVersion = true;\n      } else {\n        range = '*';\n      }\n    }\n\n    // add back @ scope suffix\n    if (isScoped) {\n      name = `@${name}`;\n    }\n\n    return { name: name, range: range, hasVersion: hasVersion };\n  }\n\n  /**\n   * Construct an exotic resolver instance with the input `ExoticResolver` and `range`.\n   */\n\n  findExoticVersionInfo(ExoticResolver, range) {\n    const resolver = new ExoticResolver(this, range);\n    return resolver.resolve();\n  }\n\n  /**\n   * If the current pattern matches an exotic resolver then delegate to it or else try\n   * the registry.\n   */\n\n  findVersionInfo() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const exoticResolver = PackageRequest.getExoticResolver(_this4.pattern);\n      if (exoticResolver) {\n        return yield _this4.findExoticVersionInfo(exoticResolver, _this4.pattern);\n      } else {\n        return yield _this4.findVersionOnRegistry(_this4.pattern);\n      }\n    })();\n  }\n\n  reportResolvedRangeMatch(info, resolved) {}\n\n  /**\n   * TODO description\n   */\n\n  find() {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // find version info for this package pattern\n      const info = yield _this5.findVersionInfo();\n      if (!info) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('unknownPackage', _this5.pattern));\n      }\n\n      (0, (_validate || _load_validate()).cleanDependencies)(info, false, _this5.reporter, function () {\n        // swallow warnings\n      });\n\n      // check if while we were resolving this dep we've already resolved one that satisfies\n      // the same range\n\n      var _PackageRequest$norma2 = PackageRequest.normalizePattern(_this5.pattern);\n\n      const range = _PackageRequest$norma2.range,\n            name = _PackageRequest$norma2.name;\n\n      const resolved = _this5.resolver.getHighestRangeVersionMatch(name, range);\n      if (resolved) {\n        _this5.reportResolvedRangeMatch(info, resolved);\n        const ref = resolved._reference;\n        invariant(ref, 'Resolved package info has no package reference');\n        ref.addRequest(_this5);\n        ref.addPattern(_this5.pattern, resolved);\n        return;\n      }\n\n      if (info.flat && !_this5.resolver.flat) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('flatGlobalError'));\n      }\n\n      // validate version info\n      PackageRequest.validateVersionInfo(info, _this5.reporter);\n\n      //\n      const remote = info._remote;\n      invariant(remote, 'Missing remote');\n\n      // set package reference\n      const ref = new (_packageReference || _load_packageReference()).default(_this5, info, remote);\n      ref.addPattern(_this5.pattern, info);\n      ref.addOptional(_this5.optional);\n      info._reference = ref;\n      info._remote = remote;\n\n      // start installation of dependencies\n      const promises = [];\n      const deps = [];\n\n      // normal deps\n      for (const depName in info.dependencies) {\n        const depPattern = depName + '@' + info.dependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: false,\n          parentRequest: _this5\n        }));\n      }\n\n      // optional deps\n      for (const depName in info.optionalDependencies) {\n        const depPattern = depName + '@' + info.optionalDependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: true,\n          parentRequest: _this5\n        }));\n      }\n\n      yield (_promise || _load_promise()).default.all(promises);\n      ref.addDependencies(deps);\n\n      // Now that we have all dependencies, it's safe to propagate optional\n      for (const otherRequest of ref.requests.slice(1)) {\n        ref.addOptional(otherRequest.optional);\n      }\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  static validateVersionInfo(info, reporter) {\n    // human readable name to use in errors\n    const human = `${info.name}@${info.version}`;\n\n    info.version = PackageRequest.getPackageVersion(info);\n\n    for (const key of (_constants || _load_constants()).REQUIRED_PACKAGE_KEYS) {\n      if (!info[key]) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('missingRequiredPackageKey', human, key));\n      }\n    }\n  }\n\n  /**\n   * Returns the package version if present, else defaults to the uid\n   */\n\n  static getPackageVersion(info) {\n    // TODO possibly reconsider this behaviour\n    return info.version === undefined ? info._uid : info.version;\n  }\n\n  /**\n   * Gets all of the outdated packages and sorts them appropriately\n   */\n\n  static getOutdatedPackages(lockfile, install, config, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref4 = yield install.fetchRequestFromCwd();\n\n      const depReqPatterns = _ref4.requests;\n\n\n      const deps = yield (_promise || _load_promise()).default.all(depReqPatterns.map((() => {\n        var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref5) {\n          let pattern = _ref5.pattern,\n              hint = _ref5.hint;\n\n          const locked = lockfile.getLocked(pattern);\n          if (!locked) {\n            throw new (_errors || _load_errors()).MessageError(reporter.lang('lockfileOutdated'));\n          }\n\n          const name = locked.name,\n                current = locked.version;\n\n          let latest = '';\n          let wanted = '';\n          let url = '';\n\n          const normalized = PackageRequest.normalizePattern(pattern);\n\n          if (PackageRequest.getExoticResolver(pattern) || PackageRequest.getExoticResolver(normalized.range)) {\n            latest = wanted = 'exotic';\n            url = normalized.range;\n          } else {\n            const registry = config.registries[locked.registry];\n\n            var _ref7 = yield registry.checkOutdated(config, name, normalized.range);\n\n            latest = _ref7.latest;\n            wanted = _ref7.wanted;\n            url = _ref7.url;\n          }\n\n          return { name: name, current: current, wanted: wanted, latest: latest, url: url, hint: hint };\n        });\n\n        return function (_x) {\n          return _ref6.apply(this, arguments);\n        };\n      })()));\n\n      // Make sure to always output `exotic` versions to be compatible with npm\n      const isDepOld = function isDepOld(_ref8) {\n        let current = _ref8.current,\n            latest = _ref8.latest,\n            wanted = _ref8.wanted;\n        return latest === 'exotic' || latest !== 'exotic' && (semver.lt(current, wanted) || semver.lt(current, latest));\n      };\n      const orderByName = function orderByName(depA, depB) {\n        return depA.name.localeCompare(depB.name);\n      };\n\n      return deps.filter(isDepOld).sort(orderByName);\n    })();\n  }\n}\nexports.default = PackageRequest;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/package-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('./package-request.js'));\n}\n\nvar _requestManager;\n\nfunction _load_requestManager() {\n  return _requestManager = _interopRequireDefault(require('./util/request-manager.js'));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./util/blocking-queue.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageResolver {\n  constructor(config, lockfile) {\n    this.patternsByPackage = (0, (_map || _load_map()).default)();\n    this.fetchingPatterns = (0, (_map || _load_map()).default)();\n    this.fetchingQueue = new (_blockingQueue || _load_blockingQueue()).default('resolver fetching');\n    this.newPatterns = [];\n    this.patterns = (0, (_map || _load_map()).default)();\n    this.usedRegistries = new (_set || _load_set()).default();\n    this.flat = false;\n\n    this.reporter = config.reporter;\n    this.lockfile = lockfile;\n    this.config = config;\n  }\n\n  // whether the dependency graph will be flattened\n\n\n  // list of registries that have been used in this resolution\n\n\n  // activity monitor\n\n\n  // patterns we've already resolved or are in the process of resolving\n\n\n  // new patterns that didn't exist in the lockfile\n\n\n  // TODO\n\n\n  // these are patterns that the package resolver was seeded with. these are required in\n  // order to resolve top level peerDependencies\n\n\n  // manages and throttles json api http requests\n\n\n  // list of patterns associated with a package\n\n\n  // lockfile instance which we can use to retrieve version info\n\n\n  // a map of dependency patterns to packages\n\n\n  // reporter instance, abstracts out display logic\n\n\n  // environment specific config methods and options\n\n\n  /**\n   * TODO description\n   */\n\n  isNewPattern(pattern) {\n    return this.newPatterns.indexOf(pattern) >= 0;\n  }\n\n  /**\n   * TODO description\n   */\n\n  updateManifest(ref, newPkg) {\n    // inherit fields\n    const oldPkg = this.patterns[ref.patterns[0]];\n    newPkg._reference = ref;\n    newPkg._remote = ref.remote;\n    newPkg.name = oldPkg.name;\n\n    // update patterns\n    for (const pattern of ref.patterns) {\n      this.patterns[pattern] = newPkg;\n    }\n\n    return (_promise || _load_promise()).default.resolve();\n  }\n\n  /**\n   * Given a list of patterns, dedupe them to a list of unique patterns.\n   */\n\n  dedupePatterns(patterns) {\n    const deduped = [];\n    const seen = new (_set || _load_set()).default();\n\n    for (const pattern of patterns) {\n      const info = this.getResolvedPattern(pattern);\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      deduped.push(pattern);\n    }\n\n    return deduped;\n  }\n\n  /**\n   * Get a list of all manifests by topological order.\n   */\n\n  getTopologicalManifests(seedPatterns) {\n    const pkgs = new (_set || _load_set()).default();\n    const skip = new (_set || _load_set()).default();\n\n    const add = seedPatterns => {\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n        skip.add(pkg);\n        add(ref.dependencies);\n        pkgs.add(pkg);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all manifests by level sort order.\n   */\n\n  getLevelOrderManifests(seedPatterns) {\n    const pkgs = new (_set || _load_set()).default();\n    const skip = new (_set || _load_set()).default();\n\n    const add = seedPatterns => {\n      const refs = [];\n\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n\n        refs.push(ref);\n        skip.add(pkg);\n        pkgs.add(pkg);\n      }\n\n      for (const ref of refs) {\n        add(ref.dependencies);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all package names in the depenency graph.\n   */\n\n  getAllDependencyNamesByLevelOrder(seedPatterns) {\n    const names = new (_set || _load_set()).default();\n    for (const _ref of this.getLevelOrderManifests(seedPatterns)) {\n      const name = _ref.name;\n\n      names.add(name);\n    }\n    return names;\n  }\n\n  /**\n   * Retrieve all the package info stored for this package name.\n   */\n\n  getAllInfoForPackageName(name) {\n    const infos = [];\n    const seen = new (_set || _load_set()).default();\n\n    for (const pattern of this.patternsByPackage[name]) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      infos.push(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * Get a flat list of all package references.\n   */\n\n  getPackageReferences() {\n    const refs = [];\n\n    for (const manifest of this.getManifests()) {\n      const ref = manifest._reference;\n      if (ref) {\n        refs.push(ref);\n      }\n    }\n\n    return refs;\n  }\n\n  /**\n   * Get a flat list of all package info.\n   */\n\n  getManifests() {\n    const infos = [];\n    const seen = new (_set || _load_set()).default();\n\n    for (const pattern in this.patterns) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      infos.push(info);\n      seen.add(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * replace pattern in resolver, e.g. `name` is replaced with `name@^1.0.1`\n   */\n  replacePattern(pattern, newPattern) {\n    const pkg = this.getResolvedPattern(pattern);\n    invariant(pkg, `missing package ${pattern}`);\n    const ref = pkg._reference;\n    invariant(ref, 'expected package reference');\n    ref.patterns = [newPattern];\n    this.newPatterns.splice(this.newPatterns.indexOf(pattern), 1, newPattern);\n    this.addPattern(newPattern, pkg);\n    this.removePattern(pattern);\n  }\n\n  /**\n   * Make all versions of this package resolve to it.\n   */\n\n  collapseAllVersionsOfPackage(name, version) {\n    const patterns = this.dedupePatterns(this.patternsByPackage[name]);\n    const human = `${name}@${version}`;\n\n    // get manifest that matches the version we're collapsing too\n    let collapseToReference;\n    let collapseToManifest;\n    let collapseToPattern;\n    for (const pattern of patterns) {\n      const _manifest = this.patterns[pattern];\n      if (_manifest.version === version) {\n        collapseToReference = _manifest._reference;\n        collapseToManifest = _manifest;\n        collapseToPattern = pattern;\n        break;\n      }\n    }\n    invariant(collapseToReference && collapseToManifest && collapseToPattern, `Couldn't find package manifest for ${human}`);\n\n    for (const pattern of patterns) {\n      // don't touch the pattern we're collapsing to\n      if (pattern === collapseToPattern) {\n        continue;\n      }\n\n      // remove this pattern\n      const ref = this.getStrictResolvedPattern(pattern)._reference;\n      invariant(ref, 'expected package reference');\n      const refPatterns = ref.patterns.slice();\n      ref.prune();\n\n      // add pattern to the manifest we're collapsing to\n      for (const pattern of refPatterns) {\n        collapseToReference.addPattern(pattern, collapseToManifest);\n      }\n    }\n\n    return collapseToPattern;\n  }\n\n  /**\n   * TODO description\n   */\n\n  addPattern(pattern, info) {\n    this.patterns[pattern] = info;\n\n    const byName = this.patternsByPackage[info.name] = this.patternsByPackage[info.name] || [];\n    byName.push(pattern);\n  }\n\n  /**\n   * TODO description\n   */\n\n  removePattern(pattern) {\n    const pkg = this.patterns[pattern];\n    if (!pkg) {\n      return;\n    }\n\n    const byName = this.patternsByPackage[pkg.name];\n    if (!byName) {\n      return;\n    }\n\n    byName.splice(byName.indexOf(pattern), 1);\n    delete this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getResolvedPattern(pattern) {\n    return this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getStrictResolvedPattern(pattern) {\n    const manifest = this.getResolvedPattern(pattern);\n    invariant(manifest, 'expected manifest');\n    return manifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  getExactVersionMatch(name, version) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    for (const pattern of patterns) {\n      const info = this.getStrictResolvedPattern(pattern);\n      if (info.version === version) {\n        return info;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the manifest of the highest known version that satisfies a package range\n   */\n\n  getHighestRangeVersionMatch(name, range) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    const versionNumbers = [];\n    const resolvedPatterns = patterns.map(pattern => {\n      const info = this.getStrictResolvedPattern(pattern);\n      versionNumbers.push(info.version);\n\n      return info;\n    });\n\n    const maxValidRange = semver.maxSatisfying(versionNumbers, range);\n    if (!maxValidRange) {\n      return null;\n    }\n\n    const indexOfmaxValidRange = versionNumbers.indexOf(maxValidRange);\n    const maxValidRangeManifest = resolvedPatterns[indexOfmaxValidRange];\n\n    return maxValidRangeManifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  find(req) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const fetchKey = `${req.registry}:${req.pattern}`;\n      if (_this.fetchingPatterns[fetchKey]) {\n        return;\n      } else {\n        _this.fetchingPatterns[fetchKey] = true;\n      }\n\n      if (_this.activity) {\n        _this.activity.tick(req.pattern);\n      }\n\n      if (!_this.lockfile.getLocked(req.pattern, true)) {\n        _this.newPatterns.push(req.pattern);\n      }\n\n      const request = new (_packageRequest || _load_packageRequest()).default(req, _this);\n      yield request.find();\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  init(deps, isFlat) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this2.flat = isFlat;\n\n      //\n      const activity = _this2.activity = _this2.reporter.activity();\n\n      //\n      _this2.seedPatterns = deps.map(function (dep) {\n        return dep.pattern;\n      });\n\n      //\n      yield (_promise || _load_promise()).default.all(deps.map(function (req) {\n        return _this2.find(req);\n      }));\n\n      activity.end();\n      _this2.activity = null;\n    })();\n  }\n}\nexports.default = PackageResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/types.js":"'use strict';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/fetchers/base-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\nconst path = require('path');\n\nclass BaseFetcher {\n  constructor(dest, remote, config) {\n    this.reporter = config.reporter;\n    this.reference = remote.reference;\n    this.registry = remote.registry;\n    this.hash = remote.hash;\n    this.remote = remote;\n    this.config = config;\n    this.dest = dest;\n  }\n\n  getResolvedFromCached(hash) {\n    // fetcher subclasses may use this to perform actions such as copying over a cached tarball to the offline\n    // mirror etc\n    return Promise.resolve();\n  }\n\n  _fetch() {\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  fetch() {\n    var _this = this;\n\n    const dest = this.dest;\n\n\n    return (_fs || _load_fs()).lockQueue.push(dest, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield (_fs || _load_fs()).mkdirp(dest);\n\n      // fetch package and get the hash\n\n      var _ref2 = yield _this._fetch();\n\n      const hash = _ref2.hash,\n            resolved = _ref2.resolved;\n\n      // load the new normalized manifest\n\n      const pkg = yield _this.config.readManifest(dest, _this.registry);\n\n      yield (_fs || _load_fs()).writeFile(path.join(dest, (_constants || _load_constants()).METADATA_FILENAME), JSON.stringify({\n        artifacts: [],\n        remote: _this.remote,\n        registry: _this.registry,\n        hash\n      }, null, '  '));\n\n      return {\n        resolved,\n        hash,\n        dest,\n        package: pkg,\n        cached: false\n      };\n    }));\n  }\n}\nexports.default = BaseFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/fetchers/copy-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _baseFetcher;\n\nfunction _load_baseFetcher() {\n  return _baseFetcher = _interopRequireDefault(require('./base-fetcher.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass CopyFetcher extends (_baseFetcher || _load_baseFetcher()).default {\n  _fetch() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield (_fs || _load_fs()).copy(_this.reference, _this.dest, _this.reporter);\n      return {\n        hash: _this.hash || '',\n        resolved: null\n      };\n    })();\n  }\n}\nexports.default = CopyFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/fetchers/tarball-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalTarballFetcher = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _http;\n\nfunction _load_http() {\n  return _http = _interopRequireDefault(require('http'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _stream;\n\nfunction _load_stream() {\n  return _stream = require('../util/stream.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('../util/crypto.js'));\n}\n\nvar _baseFetcher;\n\nfunction _load_baseFetcher() {\n  return _baseFetcher = _interopRequireDefault(require('./base-fetcher.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst path = require('path');\nconst tar = require('tar');\nconst url = require('url');\nconst fs = require('fs');\n\nclass TarballFetcher extends (_baseFetcher || _load_baseFetcher()).default {\n  getResolvedFromCached(hash) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const mirrorPath = _this.getMirrorPath();\n      if (mirrorPath == null) {\n        // no mirror\n        return null;\n      }\n\n      const tarballLoc = path.join(_this.dest, (_constants || _load_constants()).TARBALL_FILENAME);\n      if (!(yield (_fs || _load_fs()).exists(tarballLoc))) {\n        // no tarball located in the cache\n        return null;\n      }\n\n      // copy the file over\n      if (!(yield (_fs || _load_fs()).exists(mirrorPath))) {\n        yield (_fs || _load_fs()).copy(tarballLoc, mirrorPath, _this.reporter);\n      }\n\n      const relativeMirrorPath = _this.getRelativeMirrorPath(mirrorPath);\n      invariant(relativeMirrorPath != null, 'Missing offline mirror path');\n\n      return `${relativeMirrorPath}#${hash}`;\n    })();\n  }\n\n  getMirrorPath() {\n    var _url$parse = url.parse(this.reference);\n\n    const pathname = _url$parse.pathname;\n\n\n    if (pathname == null) {\n      return this.config.getOfflineMirrorPath();\n    }\n\n    let packageFilename = path.basename(pathname);\n\n    // handle scoped packages\n    const pathParts = pathname.slice(1).split('/');\n    if (pathParts[0][0] === '@') {\n      // scoped npm package\n      packageFilename = `${pathParts[0]}-${packageFilename}`;\n    }\n\n    return this.config.getOfflineMirrorPath(packageFilename);\n  }\n\n  getRelativeMirrorPath(mirrorPath) {\n    const offlineMirrorPath = this.config.getOfflineMirrorPath();\n    if (offlineMirrorPath == null) {\n      return null;\n    }\n    return path.relative(offlineMirrorPath, mirrorPath);\n  }\n\n  createExtractor(mirrorPath, resolve, reject) {\n    const validateStream = new (_crypto || _load_crypto()).HashStream();\n    const extractorStream = new (_stream || _load_stream()).UnpackStream();\n    const untarStream = tar.Extract({ path: this.dest, strip: 1 });\n\n    extractorStream.pipe(untarStream).on('error', reject).on('entry', entry => {\n      if ((_constants || _load_constants()).ROOT_USER) {\n        entry.props.uid = entry.uid = 0;\n        entry.props.gid = entry.gid = 0;\n      }\n    }).on('end', () => {\n      const expectHash = this.hash;\n      const actualHash = validateStream.getHash();\n      if (!expectHash || expectHash === actualHash) {\n        resolve({\n          hash: actualHash,\n          resolved: mirrorPath ? `${mirrorPath}#${actualHash}` : null\n        });\n      } else {\n        reject(new (_errors || _load_errors()).SecurityError(this.config.reporter.lang('fetchBadHash', expectHash, actualHash)));\n      }\n    });\n\n    return { validateStream, extractorStream };\n  }\n\n  fetchFromLocal(pathname) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const ref = _this2.reference,\n            config = _this2.config;\n      const reporter = config.reporter;\n\n      // path to the local tarball\n\n      let localTarball;\n      let isOfflineTarball = false;\n\n      const relativeFileLoc = pathname ? path.join(config.cwd, pathname) : null;\n      if (relativeFileLoc && (yield (_fs || _load_fs()).exists(relativeFileLoc))) {\n        // this is a reference to a file relative to the cwd\n        localTarball = relativeFileLoc;\n      } else {\n        // generate a offline cache location\n        const offlineMirrorPath = config.getOfflineMirrorPath() || '';\n        localTarball = path.resolve(offlineMirrorPath, ref);\n        isOfflineTarball = true;\n      }\n\n      if (!(yield (_fs || _load_fs()).exists(localTarball))) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('tarballNotInNetworkOrCache', ref, localTarball));\n      }\n\n      return new Promise(function (resolve, reject) {\n        var _createExtractor = _this2.createExtractor(null, resolve, reject);\n\n        const validateStream = _createExtractor.validateStream,\n              extractorStream = _createExtractor.extractorStream;\n\n\n        const cachedStream = fs.createReadStream(localTarball);\n\n        cachedStream.pipe(validateStream).pipe(extractorStream).on('error', function (err) {\n          let msg = 'errorDecompressingTarball';\n          if (isOfflineTarball) {\n            msg = 'fetchErrorCorrupt';\n          }\n          reject(new (_errors || _load_errors()).MessageError(reporter.lang(msg, err.message, localTarball)));\n        });\n      });\n    })();\n  }\n\n  fetchFromExternal() {\n    const ref = this.reference;\n\n    const registry = this.config.registries[this.registry];\n\n    return registry.request(ref, {\n      headers: {\n        'Accept-Encoding': 'gzip',\n        'Accept': 'application/octet-stream'\n      },\n      buffer: true,\n      process: (req, resolve, reject) => {\n        const reporter = this.config.reporter;\n        // should we save this to the offline cache?\n\n        const mirrorPath = this.getMirrorPath();\n        const tarballStorePath = path.join(this.dest, (_constants || _load_constants()).TARBALL_FILENAME);\n        const overwriteResolved = mirrorPath ? this.getRelativeMirrorPath(mirrorPath) : null;\n\n        //\n\n        var _createExtractor2 = this.createExtractor(overwriteResolved, resolve, reject);\n\n        const validateStream = _createExtractor2.validateStream,\n              extractorStream = _createExtractor2.extractorStream;\n\n\n        const handleRequestError = res => {\n          if (res.statusCode >= 400) {\n            // $FlowFixMe\n            const statusDescription = (_http || _load_http()).default.STATUS_CODES[res.statusCode];\n            reject(new Error(reporter.lang('requestFailed', `${res.statusCode} ${statusDescription}`)));\n          }\n        };\n\n        req.on('response', handleRequestError);\n        req.pipe(validateStream);\n\n        validateStream.pipe(fs.createWriteStream(tarballStorePath)).on('error', reject);\n\n        validateStream.pipe(extractorStream).on('error', reject);\n        if (mirrorPath) {\n          validateStream.pipe(fs.createWriteStream(mirrorPath)).on('error', reject);\n        }\n      }\n    });\n  }\n\n  _fetch() {\n    var _url$parse2 = url.parse(this.reference);\n\n    const protocol = _url$parse2.protocol,\n          pathname = _url$parse2.pathname;\n\n    if (protocol === null && typeof pathname === 'string') {\n      return this.fetchFromLocal(pathname);\n    } else {\n      return this.fetchFromExternal();\n    }\n  }\n}\n\nexports.default = TarballFetcher;\nclass LocalTarballFetcher extends TarballFetcher {\n  _fetch() {\n    return this.fetchFromLocal(this.reference);\n  }\n}\nexports.LocalTarballFetcher = LocalTarballFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/lockfile/parse.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = undefined;\nexports.tokenise = tokenise;\n\nexports.default = function (str) {\n  let fileLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'lockfile';\n\n  str = stripBOM(str);\n  const parser = new Parser(str, fileLoc);\n  parser.next();\n  return parser.parse();\n};\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../constants.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../util/map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n/* eslint quotes: 0 */\n\nconst stripBOM = require('strip-bom');\n\nconst VERSION_REGEX = /^yarn lockfile v(\\d+)$/;\n\nconst TOKEN_TYPES = {\n  boolean: 'BOOLEAN',\n  string: 'STRING',\n  identifier: 'IDENTIFIER',\n  eof: 'EOF',\n  colon: 'COLON',\n  newline: 'NEWLINE',\n  comment: 'COMMENT',\n  indent: 'INDENT',\n  invalid: 'INVALID',\n  number: 'NUMBER',\n  comma: 'COMMA'\n};\n\nconst VALID_PROP_VALUE_TOKENS = [TOKEN_TYPES.boolean, TOKEN_TYPES.string, TOKEN_TYPES.number];\n\nfunction isValidPropValueToken(token) {\n  return VALID_PROP_VALUE_TOKENS.indexOf(token.type) >= 0;\n}\n\nfunction* tokenise(input) {\n  let lastNewline = false;\n  let line = 1;\n  let col = 0;\n\n  function buildToken(type, value) {\n    return { line: line, col: col, type: type, value: value };\n  }\n\n  while (input.length) {\n    let chop = 0;\n\n    if (input[0] === '\\n') {\n      chop++;\n      line++;\n      col = 0;\n      yield buildToken(TOKEN_TYPES.newline);\n    } else if (input[0] === '#') {\n      chop++;\n\n      let val = '';\n      while (input[chop] !== '\\n') {\n        val += input[chop];\n        chop++;\n      }\n      yield buildToken(TOKEN_TYPES.comment, val);\n    } else if (input[0] === ' ') {\n      if (lastNewline) {\n        let indent = '';\n        for (let i = 0; input[i] === ' '; i++) {\n          indent += input[i];\n        }\n\n        if (indent.length % 2) {\n          throw new TypeError('Invalid number of spaces');\n        } else {\n          chop = indent.length;\n          yield buildToken(TOKEN_TYPES.indent, indent.length / 2);\n        }\n      } else {\n        chop++;\n      }\n    } else if (input[0] === '\"') {\n      let val = '';\n\n      for (let i = 0;; i++) {\n        const currentChar = input[i];\n        val += currentChar;\n\n        if (i > 0 && currentChar === '\"') {\n          const isEscaped = input[i - 1] === \"\\\\\" && input[i - 2] !== \"\\\\\";\n          if (!isEscaped) {\n            break;\n          }\n        }\n      }\n\n      chop = val.length;\n\n      try {\n        yield buildToken(TOKEN_TYPES.string, JSON.parse(val));\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          yield buildToken(TOKEN_TYPES.invalid);\n        } else {\n          throw err;\n        }\n      }\n    } else if (/^[0-9]/.test(input)) {\n      let val = '';\n      for (let i = 0; /^[0-9]$/.test(input[i]); i++) {\n        val += input[i];\n      }\n      chop = val.length;\n\n      yield buildToken(TOKEN_TYPES.number, +val);\n    } else if (/^true/.test(input)) {\n      yield buildToken(TOKEN_TYPES.boolean, true);\n      chop = 4;\n    } else if (/^false/.test(input)) {\n      yield buildToken(TOKEN_TYPES.boolean, false);\n      chop = 5;\n    } else if (input[0] === ':') {\n      yield buildToken(TOKEN_TYPES.colon);\n      chop++;\n    } else if (input[0] === ',') {\n      yield buildToken(TOKEN_TYPES.comma);\n      chop++;\n    } else if (/^[a-zA-Z]/g.test(input)) {\n      let name = \"\";\n      for (let i = 0; i < input.length; i++) {\n        const char = input[i];\n        if (char === ':' || char === ' ' || char === '\\n' || char === ',') {\n          break;\n        } else {\n          name += char;\n        }\n      }\n      chop = name.length;\n\n      yield buildToken(TOKEN_TYPES.string, name);\n    } else {\n      yield buildToken(TOKEN_TYPES.invalid);\n    }\n\n    if (!chop) {\n      // will trigger infinite recursion\n      yield buildToken(TOKEN_TYPES.invalid);\n    }\n\n    col += chop;\n    lastNewline = input[0] === '\\n';\n    input = input.slice(chop);\n  }\n\n  yield buildToken(TOKEN_TYPES.eof);\n}\n\nclass Parser {\n  constructor(input) {\n    let fileLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'lockfile';\n\n    this.comments = [];\n    this.tokens = tokenise(input);\n    this.fileLoc = fileLoc;\n  }\n\n  onComment(token) {\n    const value = token.value;\n    invariant(typeof value === 'string', 'expected token value to be a string');\n\n    const comment = value.trim();\n\n    const versionMatch = comment.match(VERSION_REGEX);\n    if (versionMatch) {\n      const version = +versionMatch[1];\n      if (version > (_constants || _load_constants()).LOCKFILE_VERSION) {\n        throw new (_errors || _load_errors()).MessageError(`Can't install from a lockfile of version ${version} as you're on an old yarn version that only supports ` + `versions up to ${(_constants || _load_constants()).LOCKFILE_VERSION}. Run \\`$ yarn self-update\\` to upgrade to the latest version.`);\n      }\n    }\n\n    this.comments.push(comment);\n  }\n\n  next() {\n    const item = this.tokens.next();\n    invariant(item, 'expected a token');\n\n    const done = item.done,\n          value = item.value;\n\n    if (done || !value) {\n      throw new Error('No more tokens');\n    } else if (value.type === TOKEN_TYPES.comment) {\n      this.onComment(value);\n      return this.next();\n    } else {\n      return this.token = value;\n    }\n  }\n\n  unexpected() {\n    let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unexpected token';\n\n    throw new SyntaxError(`${msg} ${this.token.line}:${this.token.col} in ${this.fileLoc}`);\n  }\n\n  expect(tokType) {\n    if (this.token.type === tokType) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n  }\n\n  eat(tokType) {\n    if (this.token.type === tokType) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  parse() {\n    let indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    const obj = (0, (_map || _load_map()).default)();\n\n    while (true) {\n      const propToken = this.token;\n\n      if (propToken.type === TOKEN_TYPES.newline) {\n        const nextToken = this.next();\n        if (!indent) {\n          // if we have 0 indentation then the next token doesn't matter\n          continue;\n        }\n\n        if (nextToken.type !== TOKEN_TYPES.indent) {\n          // if we have no indentation after a newline then we've gone down a level\n          break;\n        }\n\n        if (nextToken.value === indent) {\n          // all is good, the indent is on our level\n          this.next();\n        } else {\n          // the indentation is less than our level\n          break;\n        }\n      } else if (propToken.type === TOKEN_TYPES.indent) {\n        if (propToken.value === indent) {\n          this.next();\n        } else {\n          break;\n        }\n      } else if (propToken.type === TOKEN_TYPES.eof) {\n        break;\n      } else if (propToken.type === TOKEN_TYPES.string) {\n        // property key\n        const key = propToken.value;\n        invariant(key, 'Expected a key');\n\n        const keys = [key];\n        this.next();\n\n        // support multiple keys\n        while (this.token.type === TOKEN_TYPES.comma) {\n          this.next(); // skip comma\n\n          const keyToken = this.token;\n          if (keyToken.type !== TOKEN_TYPES.string) {\n            this.unexpected('Expected string');\n          }\n\n          const key = keyToken.value;\n          invariant(key, 'Expected a key');\n          keys.push(key);\n          this.next();\n        }\n\n        const valToken = this.token;\n\n        if (valToken.type === TOKEN_TYPES.colon) {\n          // object\n          this.next();\n\n          // parse object\n          const val = this.parse(indent + 1);\n\n          for (const key of keys) {\n            obj[key] = val;\n          }\n\n          if (indent && this.token.type !== TOKEN_TYPES.indent) {\n            break;\n          }\n        } else if (isValidPropValueToken(valToken)) {\n          // plain value\n          for (const key of keys) {\n            obj[key] = valToken.value;\n          }\n\n          this.next();\n        } else {\n          this.unexpected('Invalid value type');\n        }\n      } else {\n        this.unexpected('Unknown token');\n      }\n    }\n\n    return obj;\n  }\n}\n\nexports.Parser = Parser;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/lockfile/stringify.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _stringify2;\n\nfunction _load_stringify() {\n  return _stringify2 = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nexports.default = stringify;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../constants.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction shouldWrapKey(str) {\n  return str.indexOf('true') === 0 || str.indexOf('false') === 0 || /[:\\s\\n\\\\\",\\[\\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);\n}\n\nfunction maybeWrap(str) {\n  if (typeof str === 'boolean' || typeof str === 'number' || shouldWrapKey(str)) {\n    return (0, (_stringify2 || _load_stringify()).default)(str);\n  } else {\n    return str;\n  }\n}\n\nconst priorities = {\n  name: 1,\n  version: 2,\n  uid: 3,\n  resolved: 4,\n  registry: 5,\n  dependencies: 6\n};\n\nfunction priorityThenAlphaSort(a, b) {\n  if (priorities[a] || priorities[b]) {\n    return (priorities[a] || 100) > (priorities[b] || 100) ? 1 : -1;\n  } else {\n    return (0, (_misc || _load_misc()).sortAlpha)(a, b);\n  }\n}\n\nfunction _stringify(obj, options) {\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  }\n\n  const indent = options.indent;\n  const lines = [];\n\n  // Sorting order needs to be consistent between runs, we run native sort by name because there are no\n  // problems with it being unstable because there are no to keys the same\n  // However priorities can be duplicated and native sort can shuffle things from run to run\n  const keys = (0, (_keys || _load_keys()).default)(obj).sort(priorityThenAlphaSort);\n\n  let addedKeys = [];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const val = obj[key];\n    if (val == null || addedKeys.indexOf(key) >= 0) {\n      continue;\n    }\n\n    //\n    const valKeys = [key];\n\n    // get all keys that have the same value equality, we only want this for objects\n    if (typeof val === 'object') {\n      for (let j = i + 1; j < keys.length; j++) {\n        const key = keys[j];\n        if (val === obj[key]) {\n          valKeys.push(key);\n        }\n      }\n    }\n\n    //\n    const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(', ');\n\n    if (typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number') {\n      lines.push(`${keyLine} ${maybeWrap(val)}`);\n    } else if (typeof val === 'object') {\n      lines.push(`${keyLine}:\\n${_stringify(val, { indent: indent + '  ' })}` + (options.topLevel ? '\\n' : ''));\n    } else {\n      throw new TypeError();\n    }\n\n    addedKeys = addedKeys.concat(valKeys);\n  }\n\n  return indent + lines.join(`\\n${indent}`);\n}\n\nfunction stringify(obj, noHeader) {\n  const val = _stringify(obj, {\n    indent: '',\n    topLevel: true\n  });\n  if (noHeader) {\n    return val;\n  }\n\n  return ['# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.', `# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`, '\\n', val].join('\\n');\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/lockfile/wrapper.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringify = exports.parse = undefined;\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('babel-runtime/core-js/map'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _parse;\n\nfunction _load_parse() {\n  return _parse = require('./parse');\n}\n\nObject.defineProperty(exports, 'parse', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_parse || _load_parse()).default;\n  }\n});\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = require('./stringify');\n}\n\nObject.defineProperty(exports, 'stringify', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_stringify || _load_stringify()).default;\n  }\n});\nexports.implodeEntry = implodeEntry;\nexports.explodeEntry = explodeEntry;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../package-request.js'));\n}\n\nvar _parse2;\n\nfunction _load_parse2() {\n  return _parse2 = _interopRequireDefault(require('./parse.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nfunction getName(pattern) {\n  return (_packageRequest || _load_packageRequest()).default.normalizePattern(pattern).name;\n}\n\nfunction blankObjectUndefined(obj) {\n  return obj && (0, (_keys || _load_keys()).default)(obj).length ? obj : undefined;\n}\n\nfunction implodeEntry(pattern, obj) {\n  const inferredName = getName(pattern);\n  return {\n    name: inferredName === obj.name ? undefined : obj.name,\n    version: obj.version,\n    uid: obj.uid === obj.version ? undefined : obj.uid,\n    resolved: obj.resolved,\n    registry: obj.registry === 'npm' ? undefined : obj.registry,\n    dependencies: blankObjectUndefined(obj.dependencies),\n    optionalDependencies: blankObjectUndefined(obj.optionalDependencies),\n    permissions: blankObjectUndefined(obj.permissions)\n  };\n}\n\nfunction explodeEntry(pattern, obj) {\n  obj.optionalDependencies = obj.optionalDependencies || {};\n  obj.dependencies = obj.dependencies || {};\n  obj.uid = obj.uid || obj.version;\n  obj.permissions = obj.permissions || {};\n  obj.registry = obj.registry || 'npm';\n  obj.name = obj.name || getName(pattern);\n  return obj;\n}\n\nclass Lockfile {\n  constructor(cache, source) {\n    this.source = source || '';\n    this.cache = cache;\n  }\n\n  // source string if the `cache` was parsed\n\n\n  static fromDirectory(dir, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // read the manifest in this directory\n      const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);\n      let lockfile;\n      let rawLockfile = '';\n\n      if (yield (_fs || _load_fs()).exists(lockfileLoc)) {\n        rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);\n        lockfile = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);\n      } else {\n        if (reporter) {\n          reporter.info(reporter.lang('noLockfileFound'));\n        }\n      }\n\n      return new Lockfile(lockfile, rawLockfile);\n    })();\n  }\n\n  getLocked(pattern) {\n    const cache = this.cache;\n    if (!cache) {\n      return undefined;\n    }\n\n    const shrunk = pattern in cache && cache[pattern];\n\n    if (typeof shrunk === 'string') {\n      return this.getLocked(shrunk);\n    } else if (shrunk) {\n      explodeEntry(pattern, shrunk);\n      return shrunk;\n    }\n\n    return undefined;\n  }\n\n  getLockfile(patterns) {\n    const lockfile = {};\n    const seen = new (_map || _load_map()).default();\n\n    // order by name so that lockfile manifest is assigned to the first dependency with this manifest\n    // the others that have the same remote.resolved will just refer to the first\n    // ordering allows for consistency in lockfile when it is serialized\n    const sortedPatternsKeys = (0, (_keys || _load_keys()).default)(patterns).sort((_misc || _load_misc()).sortAlpha);\n\n    for (const pattern of sortedPatternsKeys) {\n      const pkg = patterns[pattern];\n      const remote = pkg._remote,\n            ref = pkg._reference;\n\n      invariant(ref, 'Package is missing a reference');\n      invariant(remote, 'Package is missing a remote');\n\n      const seenPattern = remote.resolved && seen.get(remote.resolved);\n      if (seenPattern) {\n        // no point in duplicating it\n        lockfile[pattern] = seenPattern;\n\n        // if we're relying on our name being inferred and two of the patterns have\n        // different inferred names then we need to set it\n        if (!seenPattern.name && getName(pattern) !== pkg.name) {\n          seenPattern.name = pkg.name;\n        }\n        continue;\n      }\n\n      const obj = implodeEntry(pattern, {\n        name: pkg.name,\n        version: pkg.version,\n        uid: pkg._uid,\n        resolved: remote.resolved,\n        registry: remote.registry,\n        dependencies: pkg.dependencies,\n        peerDependencies: pkg.peerDependencies,\n        optionalDependencies: pkg.optionalDependencies,\n        permissions: ref.permissions\n      });\n      lockfile[pattern] = obj;\n\n      if (remote.resolved) {\n        seen.set(remote.resolved, obj);\n      }\n    }\n\n    return lockfile;\n  }\n}\nexports.default = Lockfile;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/registries/base-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst objectPath = require('object-path');\nconst path = require('path');\n\nclass BaseRegistry {\n  constructor(cwd, registries, requestManager) {\n    this.requestManager = requestManager;\n    this.registries = registries;\n    this.config = {};\n    this.folder = '';\n    this.token = '';\n    this.loc = '';\n    this.cwd = cwd;\n  }\n\n  // the filename to use for package metadata\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  // absolute folder name to insert modules\n\n\n  // relative folder name to put these modules\n\n\n  setToken(token) {\n    this.token = token;\n  }\n\n  getOption(key) {\n    return this.config[key];\n  }\n\n  getAvailableRegistries() {\n    const config = this.config;\n    return (0, (_keys || _load_keys()).default)(config).reduce((registries, option) => {\n      if (option === 'registry' || option.split(':')[1] === 'registry') {\n        registries.push(config[option]);\n      }\n      return registries;\n    }, []);\n  }\n\n  loadConfig() {\n    return (_promise || _load_promise()).default.resolve();\n  }\n\n  checkOutdated(config, name, range) {\n    return (_promise || _load_promise()).default.reject(new Error('unimplemented'));\n  }\n\n  saveHomeConfig(config) {\n    return (_promise || _load_promise()).default.reject(new Error('unimplemented'));\n  }\n\n  request(pathname) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return this.requestManager.request((0, (_extends2 || _load_extends()).default)({\n      url: pathname\n    }, opts));\n  }\n\n  init() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this.mergeEnv('yarn_');\n      yield _this.loadConfig();\n      _this.loc = path.join(_this.cwd, _this.folder);\n    })();\n  }\n\n  static normalizeConfig(config) {\n    for (const key in config) {\n      config[key] = BaseRegistry.normalizeConfigOption(config[key]);\n    }\n    return config;\n  }\n\n  static normalizeConfigOption(val) {\n    if (val === 'true') {\n      return true;\n    } else if (val === 'false') {\n      return false;\n    } else {\n      return val;\n    }\n  }\n\n  mergeEnv(prefix) {\n    // try environment variables\n    for (let key in process.env) {\n      key = key.toLowerCase();\n\n      // only accept keys prefixed with the prefix\n      if (key.indexOf(prefix) < 0) {\n        continue;\n      }\n\n      const val = BaseRegistry.normalizeConfigOption(process.env[key]);\n\n      // remove config prefix\n      key = (0, (_misc || _load_misc()).removePrefix)(key, prefix);\n\n      // replace dunders with dots\n      key = key.replace(/__/g, '.');\n\n      // replace underscores with dashes\n      key = key.replace(/_/g, '-');\n\n      // set it via a path\n      objectPath.set(this.config, key, val);\n    }\n  }\n}\nexports.default = BaseRegistry;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/registries/is-request-to-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isRequestToRegistry;\n\nvar _url;\n\nfunction _load_url() {\n  return _url = _interopRequireDefault(require('url'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isRequestToRegistry(requestUrl, registry) {\n  const requestParsed = (_url || _load_url()).default.parse(requestUrl);\n  const registryParsed = (_url || _load_url()).default.parse(registry);\n  const requestPort = getPortOrDefaultPort(requestParsed.port, requestParsed.protocol);\n  const registryPort = getPortOrDefaultPort(registryParsed.port, registryParsed.protocol);\n  const requestPath = requestParsed.path || '';\n  const registryPath = registryParsed.path || '';\n\n  return requestParsed.protocol === registryParsed.protocol && requestParsed.hostname === registryParsed.hostname && requestPort === registryPort && requestPath.startsWith(registryPath);\n}\n\nfunction getPortOrDefaultPort(port, protocol) {\n  const defaultPort = !port;\n  if (defaultPort && protocol === 'https:') {\n    return '443';\n  }\n  if (defaultPort && protocol === 'http:') {\n    return '80';\n  }\n  return port;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/registries/npm-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nvar _npmResolver;\n\nfunction _load_npmResolver() {\n  return _npmResolver = _interopRequireDefault(require('../resolvers/registries/npm-resolver.js'));\n}\n\nvar _envReplace;\n\nfunction _load_envReplace() {\n  return _envReplace = _interopRequireDefault(require('../util/env-replace.js'));\n}\n\nvar _baseRegistry;\n\nfunction _load_baseRegistry() {\n  return _baseRegistry = _interopRequireDefault(require('./base-registry.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc');\n}\n\nvar _isRequestToRegistry;\n\nfunction _load_isRequestToRegistry() {\n  return _isRequestToRegistry = _interopRequireDefault(require('./is-request-to-registry.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst userHome = require('../util/user-home-dir').default;\nconst path = require('path');\nconst url = require('url');\nconst ini = require('ini');\n\nconst DEFAULT_REGISTRY = 'https://registry.npmjs.org/';\n\nfunction getGlobalPrefix() {\n  if (process.env.PREFIX) {\n    return process.env.PREFIX;\n  } else if (process.platform === 'win32') {\n    // c:\\node\\node.exe --> prefix=c:\\node\\\n    return path.dirname(process.execPath);\n  } else {\n    // /usr/local/bin/node --> prefix=/usr/local\n    let prefix = path.dirname(path.dirname(process.execPath));\n\n    // destdir only is respected on Unix\n    if (process.env.DESTDIR) {\n      prefix = path.join(process.env.DESTDIR, prefix);\n    }\n\n    return prefix;\n  }\n}\n\nclass NpmRegistry extends (_baseRegistry || _load_baseRegistry()).default {\n  constructor(cwd, registries, requestManager) {\n    super(cwd, registries, requestManager);\n    this.folder = 'node_modules';\n  }\n\n  static escapeName(name) {\n    // scoped packages contain slashes and the npm registry expects them to be escaped\n    return name.replace('/', '%2f');\n  }\n\n  request(pathname) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const registry = (0, (_misc || _load_misc()).addSuffix)(this.getRegistry(pathname), '/');\n    const requestUrl = url.resolve(registry, pathname);\n    const alwaysAuth = this.getScopedOption(registry.replace(/^https?:/, ''), 'always-auth') || this.getOption('always-auth') || (0, (_misc || _load_misc()).removePrefix)(requestUrl, registry)[0] === '@';\n\n    const headers = {};\n    if (this.token || alwaysAuth && (0, (_isRequestToRegistry || _load_isRequestToRegistry()).default)(requestUrl, registry)) {\n      const authorization = this.getAuth(pathname);\n      if (authorization) {\n        headers.authorization = authorization;\n      }\n    }\n\n    return this.requestManager.request({\n      url: requestUrl,\n      method: opts.method,\n      body: opts.body,\n      auth: opts.auth,\n      headers: headers,\n      json: !opts.buffer,\n      buffer: opts.buffer,\n      process: opts.process,\n      gzip: true\n    });\n  }\n\n  checkOutdated(config, name, range) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const req = yield _this.request(NpmRegistry.escapeName(name));\n      if (!req) {\n        throw new Error('couldnt find ' + name);\n      }\n\n      const repository = req.repository,\n            homepage = req.homepage;\n\n      const url = homepage || repository && repository.url || '';\n\n      return {\n        latest: req['dist-tags'].latest,\n        wanted: (yield (_npmResolver || _load_npmResolver()).default.findVersionInRegistryResponse(config, range, req)).version,\n        url: url\n      };\n    })();\n  }\n\n  getPossibleConfigLocations(filename) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const possibles = [[false, path.join(_this2.cwd, filename)], [true, _this2.config.userconfig || path.join(userHome, filename)], [false, path.join(getGlobalPrefix(), filename)]];\n\n      const foldersFromRootToCwd = _this2.cwd.split(path.sep);\n      while (foldersFromRootToCwd.length > 1) {\n        possibles.push([false, path.join(foldersFromRootToCwd.join(path.sep), filename)]);\n        foldersFromRootToCwd.pop();\n      }\n\n      const actuals = [];\n      for (const _ref of possibles) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const isHome = _ref2[0];\n        const loc = _ref2[1];\n\n        if (yield (_fs || _load_fs()).exists(loc)) {\n          actuals.push([isHome, loc, yield (_fs || _load_fs()).readFile(loc)]);\n        }\n      }\n      return actuals;\n    })();\n  }\n\n  loadConfig() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // docs: https://docs.npmjs.com/misc/config\n      _this3.mergeEnv('npm_config_');\n\n      for (const _ref3 of yield _this3.getPossibleConfigLocations('.npmrc')) {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 3);\n\n        const loc = _ref4[1];\n        const file = _ref4[2];\n\n        const config = (_baseRegistry || _load_baseRegistry()).default.normalizeConfig(ini.parse(file));\n        for (const key in config) {\n          config[key] = (0, (_envReplace || _load_envReplace()).default)(config[key]);\n        }\n\n        // normalize offline mirror path relative to the current npmrc\n        const offlineLoc = config['yarn-offline-mirror'];\n        // don't normalize if we already have a mirror path\n        if (!_this3.config['yarn-offline-mirror'] && offlineLoc) {\n          const mirrorLoc = config['yarn-offline-mirror'] = path.resolve(path.dirname(loc), offlineLoc);\n          yield (_fs || _load_fs()).mkdirp(mirrorLoc);\n        }\n\n        _this3.config = (0, (_assign || _load_assign()).default)({}, config, _this3.config);\n      }\n    })();\n  }\n\n  getScope(packageName) {\n    return !packageName || packageName[0] !== '@' ? '' : packageName.split(/\\/|%2f/)[0];\n  }\n\n  getRegistry(packageName) {\n    // Try extracting registry from the url, then scoped registry, and default registry\n    if (packageName.match(/^https?:/)) {\n      const availableRegistries = this.getAvailableRegistries();\n      const registry = availableRegistries.find(registry => packageName.startsWith(registry));\n      if (registry) {\n        return registry;\n      }\n    }\n\n    for (const scope of [this.getScope(packageName), '']) {\n      const registry = this.getScopedOption(scope, 'registry') || this.registries.yarn.getScopedOption(scope, 'registry');\n      if (registry) {\n        return String(registry);\n      }\n    }\n\n    return DEFAULT_REGISTRY;\n  }\n\n  getAuth(packageName) {\n    if (this.token) {\n      return this.token;\n    }\n\n    for (let registry of [this.getRegistry(packageName), '', DEFAULT_REGISTRY]) {\n      registry = registry.replace(/^https?:/, '');\n\n      // Check for bearer token.\n      let auth = this.getScopedOption(registry.replace(/\\/?$/, '/'), '_authToken');\n      if (auth) {\n        return `Bearer ${String(auth)}`;\n      }\n\n      // Check for basic auth token.\n      auth = this.getScopedOption(registry, '_auth');\n      if (auth) {\n        return `Basic ${String(auth)}`;\n      }\n\n      // Check for basic username/password auth.\n      const username = this.getScopedOption(registry, 'username');\n      const password = this.getScopedOption(registry, '_password');\n      if (username && password) {\n        const pw = new Buffer(String(password), 'base64').toString();\n        return 'Basic ' + new Buffer(String(username) + ':' + pw).toString('base64');\n      }\n    }\n\n    return '';\n  }\n\n  getScopedOption(scope, option) {\n    return this.getOption(scope + (scope ? ':' : '') + option);\n  }\n}\nexports.default = NpmRegistry;\nNpmRegistry.filename = 'package.json';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/registries/yarn-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULTS = undefined;\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../constants.js');\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('./npm-registry.js'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('../lockfile/stringify.js'));\n}\n\nvar _parse;\n\nfunction _load_parse() {\n  return _parse = _interopRequireDefault(require('../lockfile/parse.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst userHome = require('../util/user-home-dir').default;\n\nconst path = require('path');\nconst pkg = require('../../package.json');\n\nconst DEFAULTS = exports.DEFAULTS = {\n  'version-tag-prefix': 'v',\n  'version-git-tag': true,\n  'version-git-sign': false,\n  'version-git-message': 'v%s',\n\n  'init-version': '1.0.0',\n  'init-license': 'MIT',\n\n  'save-prefix': '^',\n  'ignore-scripts': false,\n  'ignore-optional': false,\n  registry: (_constants || _load_constants()).YARN_REGISTRY,\n  'strict-ssl': true,\n  'user-agent': [`yarn/${pkg.version}`, 'npm/?', `node/${process.version}`, process.platform, process.arch].join(' ')\n};\n\nconst npmMap = {\n  'version-git-sign': 'sign-git-tag',\n  'version-tag-prefix': 'tag-version-prefix',\n  'version-git-tag': 'git-tag-version',\n  'version-git-message': 'message'\n};\n\nclass YarnRegistry extends (_npmRegistry || _load_npmRegistry()).default {\n  constructor(cwd, registries, requestManager) {\n    super(cwd, registries, requestManager);\n\n    this.homeConfigLoc = path.join(userHome, '.yarnrc');\n    this.homeConfig = {};\n  }\n\n  getOption(key) {\n    let val = this.config[key];\n\n    // if this isn't set in a yarn config, then use npm\n    if (typeof val === 'undefined') {\n      val = this.registries.npm.getOption(npmMap[key]);\n    }\n\n    if (typeof val === 'undefined') {\n      val = this.registries.npm.getOption(key);\n    }\n\n    // if this isn't set in a yarn config or npm config, then use the default (or undefined)\n    if (typeof val === 'undefined') {\n      val = DEFAULTS[key];\n    }\n\n    return val;\n  }\n\n  loadConfig() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      for (const _ref of yield _this.getPossibleConfigLocations('.yarnrc')) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 3);\n\n        const isHome = _ref2[0];\n        const loc = _ref2[1];\n        const file = _ref2[2];\n\n        const config = (0, (_parse || _load_parse()).default)(file, loc);\n\n        if (isHome) {\n          _this.homeConfig = config;\n        }\n\n        // normalize offline mirror path relative to the current yarnrc\n        const offlineLoc = config['yarn-offline-mirror'];\n\n        // don't normalize if we already have a mirror path\n        if (!_this.config['yarn-offline-mirror'] && offlineLoc) {\n          const mirrorLoc = config['yarn-offline-mirror'] = path.resolve(path.dirname(loc), offlineLoc);\n          yield (_fs || _load_fs()).mkdirp(mirrorLoc);\n        }\n\n        _this.config = (0, (_assign || _load_assign()).default)({}, config, _this.config);\n      }\n\n      // default yarn config\n      _this.config = (0, (_assign || _load_assign()).default)({}, DEFAULTS, _this.config);\n    })();\n  }\n\n  saveHomeConfig(config) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      YarnRegistry.normalizeConfig(config);\n\n      for (const key in config) {\n        const val = config[key];\n\n        // if the current config key was taken from home config then update\n        // the global config\n        if (_this2.homeConfig[key] === _this2.config[key]) {\n          _this2.config[key] = val;\n        }\n\n        // update just the home config\n        _this2.homeConfig[key] = config[key];\n      }\n\n      yield (_fs || _load_fs()).writeFilePreservingEol(_this2.homeConfigLoc, `${(0, (_stringify || _load_stringify()).default)(_this2.homeConfig)}\\n`);\n    })();\n  }\n}\nexports.default = YarnRegistry;\nYarnRegistry.filename = 'yarn.json';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/base-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nexports.stringifyLangArgs = stringifyLangArgs;\n\nvar _format;\n\nfunction _load_format() {\n  return _format = require('./format.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./lang/index.js'));\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n  return _isCi = _interopRequireDefault(require('is-ci'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\nconst util = require('util');\nconst EventEmitter = require('events').EventEmitter;\n\nfunction stringifyLangArgs(args) {\n  return args.map(function (val) {\n    if (val != null && val.inspect) {\n      return val.inspect();\n    } else {\n      try {\n        const str = (0, (_stringify || _load_stringify()).default)(val) || val + '';\n        // should match all \"u001b\" that follow an odd number of backslashes and convert them to ESC\n        // we do this because the JSON.stringify process has escaped these characters\n        return str.replace(/((?:^|[^\\\\])(?:\\\\{2})*)\\\\u001[bB]/g, '$1\\u001b');\n      } catch (e) {\n        return util.inspect(val);\n      }\n    }\n  });\n}\n\nclass BaseReporter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const lang = 'en';\n    this.language = lang;\n\n    this.stdout = opts.stdout || process.stdout;\n    this.stderr = opts.stderr || process.stderr;\n    this.stdin = opts.stdin || this._getStandardInput();\n    this.emoji = !!opts.emoji;\n    this.noProgress = !!opts.noProgress || (_isCi || _load_isCi()).default;\n    this.isVerbose = !!opts.verbose;\n\n    // $FlowFixMe: this is valid!\n    this.isTTY = this.stdout.isTTY;\n\n    this.peakMemory = 0;\n    this.startTime = Date.now();\n    this.format = (_format || _load_format()).defaultFormatter;\n  }\n\n  lang(key) {\n    const msg = (_index || _load_index())[this.language][key] || (_index || _load_index()).en[key];\n    if (!msg) {\n      throw new ReferenceError(`Unknown language key ${key}`);\n    }\n\n    // stringify args\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    const stringifiedArgs = stringifyLangArgs(args);\n\n    // replace $0 placeholders with args\n    return msg.replace(/\\$(\\d+)/g, (str, i) => {\n      return stringifiedArgs[i];\n    });\n  }\n\n  verbose(msg) {\n    if (this.isVerbose) {\n      this._verbose(msg);\n    }\n  }\n\n  verboseInspect(val) {\n    if (this.isVerbose) {\n      this._verboseInspect(val);\n    }\n  }\n\n  _verbose(msg) {}\n  _verboseInspect(val) {}\n\n  _getStandardInput() {\n    let standardInput;\n\n    try {\n      standardInput = process.stdin;\n    } catch (e) {\n      delete process.stdin;\n      // $FlowFixMe: this is valid!\n      process.stdin = new EventEmitter();\n      standardInput = process.stdin;\n    }\n\n    return standardInput;\n  }\n\n  initPeakMemoryCounter() {\n    this.checkPeakMemory();\n    this.peakMemoryInterval = setInterval(() => {\n      this.checkPeakMemory();\n    }, 1000);\n  }\n\n  checkPeakMemory() {\n    var _process$memoryUsage = process.memoryUsage();\n\n    const heapTotal = _process$memoryUsage.heapTotal;\n\n    if (heapTotal > this.peakMemory) {\n      this.peakMemory = heapTotal;\n    }\n  }\n\n  close() {\n    if (this.peakMemoryInterval) {\n      clearInterval(this.peakMemoryInterval);\n      this.peakMemoryInterval = null;\n    }\n  }\n\n  getTotalTime() {\n    return Date.now() - this.startTime;\n  }\n\n  // TODO\n  list(key, items, hints) {}\n\n  // Outputs basic tree structure to console\n  tree(key, obj) {}\n\n  // called whenever we begin a step in the CLI.\n  step(current, total, message, emoji) {}\n\n  // a error message has been triggered. this however does not always meant an abrupt\n  // program end.\n  error(message) {}\n\n  // an info message has been triggered. this provides things like stats and diagnostics.\n  info(message) {}\n\n  // a warning message has been triggered.\n  warn(message) {}\n\n  // a success message has been triggered.\n  success(message) {}\n\n  // a simple log message\n  log(message) {}\n\n  // a shell command has been executed\n  command(command) {}\n\n  // inspect and pretty-print any value\n  inspect(value) {}\n\n  // the screen shown at the very start of the CLI\n  header(command, pkg) {}\n\n  // the screen shown at the very end of the CLI\n  footer(showPeakMemory) {}\n\n  //\n  table(head, body) {}\n\n  // render an activity spinner and return a function that will trigger an update\n  activity() {\n    return {\n      tick: function tick(name) {},\n      end: function end() {}\n    };\n  }\n\n  //\n  activitySet(total, workers) {\n    return {\n      spinners: Array(workers).fill({\n        clear: function clear() {},\n        setPrefix: function setPrefix() {},\n        tick: function tick() {},\n        end: function end() {}\n      }),\n      end: function end() {}\n    };\n  }\n\n  //\n  question(question) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return (_promise || _load_promise()).default.reject(new Error('Not implemented'));\n  }\n\n  //\n  questionAffirm(question) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const condition = true; // trick eslint\n\n      while (condition) {\n        let answer = yield _this.question(question);\n        answer = answer.toLowerCase();\n\n        if (answer === 'y' || answer === 'yes') {\n          return true;\n        }\n        if (answer === 'n' || answer === 'no') {\n          return false;\n        }\n\n        _this.error('Invalid answer for question');\n      }\n\n      return false;\n    })();\n  }\n\n  // prompt the user to select an option from an array\n  select(header, question, options) {\n    return (_promise || _load_promise()).default.reject(new Error('Not implemented'));\n  }\n\n  // render a progress bar and return a function which when called will trigger an update\n  progress(total) {\n    return function () {};\n  }\n\n  // utility function to disable progress bar\n  disableProgress() {\n    this.noProgress = true;\n  }\n}\nexports.default = BaseReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/buffer-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _jsonReporter;\n\nfunction _load_jsonReporter() {\n  return _jsonReporter = _interopRequireDefault(require('./json-reporter.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass BufferReporter extends (_jsonReporter || _load_jsonReporter()).default {\n  constructor(opts) {\n    super(opts);\n    this._buffer = [];\n  }\n\n  _dump(type, data, error) {\n    this._buffer.push({\n      type: type,\n      data: data,\n      error: !!error\n    });\n  }\n\n  getBuffer() {\n    return this._buffer;\n  }\n}\nexports.default = BufferReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/json-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('./base-reporter.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass JSONReporter extends (_baseReporter || _load_baseReporter()).default {\n  constructor(opts) {\n    super(opts);\n\n    this._activityId = 0;\n    this._progressId = 0;\n  }\n\n  _dump(type, data, error) {\n    let stdout = this.stdout;\n    if (error) {\n      stdout = this.stderr;\n    }\n    stdout.write(`${(0, (_stringify || _load_stringify()).default)({ type: type, data: data })}\\n`);\n  }\n\n  _verbose(msg) {\n    this._dump('verbose', msg);\n  }\n\n  list(type, items, hints) {\n    this._dump('list', { type: type, items: items, hints: hints });\n  }\n\n  tree(type, trees) {\n    this._dump('tree', { type: type, trees: trees });\n  }\n\n  step(current, total, message) {\n    this._dump('step', { message: message, current: current, total: total });\n  }\n\n  inspect(value) {\n    this._dump('inspect', value);\n  }\n\n  footer() {\n    this._dump('finished', this.getTotalTime());\n  }\n\n  log(msg) {\n    this._dump('log', msg);\n  }\n\n  command(msg) {\n    this._dump('command', msg);\n  }\n\n  table(head, body) {\n    this._dump('table', { head: head, body: body });\n  }\n\n  success(msg) {\n    this._dump('success', msg);\n  }\n\n  error(msg) {\n    this._dump('error', msg, true);\n  }\n\n  warn(msg) {\n    this._dump('warning', msg, true);\n  }\n\n  info(msg) {\n    this._dump('info', msg);\n  }\n\n  activitySet(total, workers) {\n    const id = this._activityId++;\n    this._dump('activitySetStart', { id: id, total: total, workers: workers });\n\n    const spinners = [];\n    for (let i = 0; i < workers; i++) {\n      let current = 0;\n      let header = '';\n\n      spinners.push({\n        clear: function clear() {},\n        setPrefix: function setPrefix(_current, _header) {\n          current = _current;\n          header = _header;\n        },\n\n        tick: msg => {\n          this._dump('activitySetTick', { id: id, header: header, current: current, worker: i, message: msg });\n        },\n        end: function end() {}\n      });\n    }\n\n    return {\n      spinners: spinners,\n      end: () => {\n        this._dump('activitySetEnd', { id: id });\n      }\n    };\n  }\n\n  activity() {\n    return this._activity({});\n  }\n\n  _activity(data) {\n    const id = this._activityId++;\n    this._dump('activityStart', (0, (_extends2 || _load_extends()).default)({ id: id }, data));\n\n    return {\n      tick: name => {\n        this._dump('activityTick', { id: id, name: name });\n      },\n\n      end: () => {\n        this._dump('activityEnd', { id: id });\n      }\n    };\n  }\n\n  progress(total) {\n    const id = this._progressId++;\n    let current = 0;\n    this._dump('progressStart', { id: id, total: total });\n\n    return () => {\n      current++;\n      this._dump('progressTick', { id: id, current: current });\n\n      if (current === total) {\n        this._dump('progressFinish', { id: id });\n      }\n    };\n  }\n}\nexports.default = JSONReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/event-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _jsonReporter;\n\nfunction _load_jsonReporter() {\n  return _jsonReporter = _interopRequireDefault(require('./json-reporter.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _require = require('events');\n\nconst EventEmitter = _require.EventEmitter;\nclass EventReporter extends (_jsonReporter || _load_jsonReporter()).default {\n\n  constructor(opts) {\n    super(opts);\n\n    // $FlowFixMe: looks like a flow bug\n    EventEmitter.call(this);\n  }\n\n  _dump(type, data) {\n    this.emit(type, data);\n  }\n}\n\nexports.default = EventReporter; // $FlowFixMe: need to \"inherit\" from it\n\n(0, (_assign || _load_assign()).default)(EventReporter.prototype, EventEmitter.prototype);","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/format.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction formatFunction() {\n  for (var _len = arguments.length, strs = Array(_len), _key = 0; _key < _len; _key++) {\n    strs[_key] = arguments[_key];\n  }\n\n  return strs.join(' ');\n}\n\nconst defaultFormatter = exports.defaultFormatter = {\n  bold: formatFunction,\n  dim: formatFunction,\n  italic: formatFunction,\n  underline: formatFunction,\n  inverse: formatFunction,\n  strikethrough: formatFunction,\n  black: formatFunction,\n  red: formatFunction,\n  green: formatFunction,\n  yellow: formatFunction,\n  blue: formatFunction,\n  magenta: formatFunction,\n  cyan: formatFunction,\n  white: formatFunction,\n  gray: formatFunction,\n  grey: formatFunction,\n  stripColor: formatFunction\n};","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/noop-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _format;\n\nfunction _load_format() {\n  return _format = require('./format.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./lang/index.js'));\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n  return _isCi = _interopRequireDefault(require('is-ci'));\n}\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('./base-reporter.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass NoopReporter extends (_baseReporter || _load_baseReporter()).default {\n  lang(key) {\n    return 'do nothing';\n  }\n  verbose(msg) {}\n  verboseInspect(val) {}\n  initPeakMemoryCounter() {}\n  checkPeakMemory() {}\n  close() {}\n  getTotalTime() {\n    return 0;\n  }\n  list(key, items, hints) {}\n  tree(key, obj) {}\n  step(current, total, message, emoji) {}\n  error(message) {}\n  info(message) {}\n  warn(message) {}\n  success(message) {}\n  log(message) {}\n  command(command) {}\n  inspect(value) {}\n  header(command, pkg) {}\n  footer(showPeakMemory) {}\n  table(head, body) {}\n\n  activity() {\n    return {\n      tick: function tick(name) {},\n      end: function end() {}\n    };\n  }\n\n  activitySet(total, workers) {\n    return {\n      spinners: Array(workers).fill({\n        clear: function clear() {},\n        setPrefix: function setPrefix() {},\n        tick: function tick() {},\n        end: function end() {}\n      }),\n      end: function end() {}\n    };\n  }\n\n  question(question) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return (_promise || _load_promise()).default.reject(new Error('Not implemented'));\n  }\n\n  questionAffirm(question) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield _this.question(question);\n      return false;\n    })();\n  }\n\n  select(header, question, options) {\n    return (_promise || _load_promise()).default.reject(new Error('Not implemented'));\n  }\n\n  progress(total) {\n    return function () {};\n  }\n\n  disableProgress() {\n    this.noProgress = true;\n  }\n}\nexports.default = NoopReporter;\n/* eslint no-unused-vars: 0 */","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/base-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass BaseResolver {\n  constructor(request, fragment) {\n    this.resolver = request.resolver;\n    this.reporter = request.reporter;\n    this.fragment = fragment;\n    this.registry = request.registry;\n    this.request = request;\n    this.pattern = request.pattern;\n    this.config = request.config;\n  }\n\n  fork(Resolver, resolveArg) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    const resolver = new (Function.prototype.bind.apply(Resolver, [null].concat([this.request], args)))();\n    resolver.registry = this.registry;\n    return resolver.resolve(resolveArg);\n  }\n\n  resolve() {\n    throw new Error('Not implemented');\n  }\n}\nexports.default = BaseResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/blocking-queue.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = require('debug')('yarn');\n\nclass BlockingQueue {\n  constructor(alias) {\n    let maxConcurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n    this.concurrencyQueue = [];\n    this.maxConcurrency = maxConcurrency;\n    this.runningCount = 0;\n    this.warnedStuck = false;\n    this.alias = alias;\n    this.first = true;\n\n    this.running = (0, (_map || _load_map()).default)();\n    this.queue = (0, (_map || _load_map()).default)();\n\n    this.stuckTick = this.stuckTick.bind(this);\n  }\n\n  stillActive() {\n    if (this.stuckTimer) {\n      clearTimeout(this.stuckTimer);\n    }\n\n    this.stuckTimer = setTimeout(this.stuckTick, 5000);\n  }\n\n  stuckTick() {\n    if (this.runningCount === 1) {\n      this.warnedStuck = true;\n      debug(`The ${(0, (_stringify || _load_stringify()).default)(this.alias)} blocking queue may be stuck. 5 seconds ` + `without any activity with 1 worker: ${(0, (_keys || _load_keys()).default)(this.running)[0]}`);\n    }\n  }\n\n  push(key, factory) {\n    if (this.first) {\n      this.first = false;\n    } else {\n      this.stillActive();\n    }\n\n    return new (_promise || _load_promise()).default((resolve, reject) => {\n      // we're already running so push ourselves to the queue\n      const queue = this.queue[key] = this.queue[key] || [];\n      queue.push({ factory: factory, resolve: resolve, reject: reject });\n\n      if (!this.running[key]) {\n        this.shift(key);\n      }\n    });\n  }\n\n  shift(key) {\n    if (this.running[key]) {\n      delete this.running[key];\n      this.runningCount--;\n\n      if (this.warnedStuck) {\n        this.warnedStuck = false;\n        debug(`${(0, (_stringify || _load_stringify()).default)(this.alias)} blocking queue finally resolved. Nothing to worry about.`);\n      }\n    }\n\n    const queue = this.queue[key];\n    if (!queue) {\n      return;\n    }\n\n    var _queue$shift = queue.shift();\n\n    const resolve = _queue$shift.resolve,\n          reject = _queue$shift.reject,\n          factory = _queue$shift.factory;\n\n    if (!queue.length) {\n      delete this.queue[key];\n    }\n\n    const next = () => {\n      this.shift(key);\n      this.shiftConcurrencyQueue();\n    };\n\n    const run = () => {\n      this.running[key] = true;\n      this.runningCount++;\n\n      factory().then(function (val) {\n        resolve(val);\n        next();\n        return null;\n      }).catch(function (err) {\n        reject(err);\n        next();\n      });\n    };\n\n    this.maybePushConcurrencyQueue(run);\n  }\n\n  maybePushConcurrencyQueue(run) {\n    if (this.runningCount < this.maxConcurrency) {\n      run();\n    } else {\n      this.concurrencyQueue.push(run);\n    }\n  }\n\n  shiftConcurrencyQueue() {\n    if (this.runningCount < this.maxConcurrency) {\n      const fn = this.concurrencyQueue.shift();\n      if (fn) {\n        fn();\n      }\n    }\n  }\n}\nexports.default = BlockingQueue;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/child.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exec = exports.queue = undefined;\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nexports.spawn = spawn;\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _promise2;\n\nfunction _load_promise2() {\n  return _promise2 = require('./promise.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* global child_process$spawnOpts */\n\nconst child = require('child_process');\n\nconst queue = exports.queue = new (_blockingQueue || _load_blockingQueue()).default('child', (_constants || _load_constants()).CHILD_CONCURRENCY);\n\n// TODO: this uid check is kinda whack\nlet uid = 0;\n\nconst exec = exports.exec = (0, (_promise2 || _load_promise2()).promisify)(child.exec);\n\nfunction spawn(program, args) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let onData = arguments[3];\n\n  return queue.push(opts.cwd || String(++uid), () => new (_promise || _load_promise()).default((resolve, reject) => {\n    const proc = child.spawn(program, args, opts);\n\n    let processingDone = false;\n    let processClosed = false;\n    let err = null;\n\n    let stdout = '';\n\n    proc.on('error', err => {\n      if (err.code === 'ENOENT') {\n        reject(new (_errors || _load_errors()).MessageError(`Couldn't find the binary ${program}`));\n      } else {\n        reject(err);\n      }\n    });\n\n    function updateStdout(chunk) {\n      stdout += chunk;\n      if (onData) {\n        onData(chunk);\n      }\n    }\n\n    function finish() {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stdout.trim());\n      }\n    }\n\n    if (typeof opts.process === 'function') {\n      opts.process(proc, updateStdout, reject, function () {\n        if (processClosed) {\n          finish();\n        } else {\n          processingDone = true;\n        }\n      });\n    } else {\n      if (proc.stderr) {\n        proc.stderr.on('data', updateStdout);\n      }\n\n      if (proc.stdout) {\n        proc.stdout.on('data', updateStdout);\n      }\n\n      processingDone = true;\n    }\n\n    proc.on('close', code => {\n      if (code >= 1) {\n        // TODO make this output nicer\n        err = new (_errors || _load_errors()).SpawnError(['Command failed.', `Exit code: ${code}`, `Command: ${program}`, `Arguments: ${args.join(' ')}`, `Directory: ${opts.cwd || process.cwd()}`, `Output:\\n${stdout.trim()}`].join('\\n'));\n        err.EXIT_CODE = code;\n      }\n\n      if (processingDone || err) {\n        finish();\n      } else {\n        processClosed = true;\n      }\n    });\n  }));\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/crypto.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hash = hash;\nconst crypto = require('crypto');\nconst stream = require('stream');\n\nfunction hash(content) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'md5';\n\n  return crypto.createHash(type).update(content).digest('hex');\n}\n\nclass HashStream extends stream.Transform {\n  constructor(options) {\n    super(options);\n    this._hash = crypto.createHash('sha1');\n    this._updated = false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    this._updated = true;\n    this._hash.update(chunk);\n    callback(null, chunk);\n  }\n\n  getHash() {\n    return this._hash.digest('hex');\n  }\n\n  test(sum) {\n    return this._updated && sum === this.getHash();\n  }\n}\nexports.HashStream = HashStream;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/env-replace.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = envReplace;\nconst ENV_EXPR = /(\\\\*)\\$\\{([^}]+)\\}/g;\n\nfunction envReplace(value) {\n  let env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.env;\n\n  if (typeof value !== 'string' || !value) {\n    return value;\n  }\n\n  return value.replace(ENV_EXPR, (match, esc, envVarName) => {\n    if (esc.length && esc.length % 2) {\n      return match;\n    }\n    if (undefined === env[envVarName]) {\n      throw new Error('Failed to replace env in config: ' + match);\n    }\n    return env[envVarName] || '';\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/execute-lifecycle-script.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.execCommand = exports.execFromManifest = exports.executeLifecycleScript = undefined;\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _toConsumableArray2;\n\nfunction _load_toConsumableArray() {\n  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));\n}\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet makeEnv = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, cwd, config) {\n    const env = (0, (_assign || _load_assign()).default)({}, process.env);\n\n    env.npm_lifecycle_event = stage;\n    env.npm_node_execpath = env.NODE || process.execPath;\n    env.npm_execpath = path.join(__dirname, '..', '..', 'bin', 'yarn.js');\n\n    // Set the env to production for npm compat if production mode.\n    // https://github.com/npm/npm/blob/30d75e738b9cb7a6a3f9b50e971adcbe63458ed3/lib/utils/lifecycle.js#L336\n    if (config.production) {\n      env.NODE_ENV = 'production';\n    }\n\n    // Note: npm_config_argv environment variable contains output of nopt - command-line\n    // parser used by npm. Since we use other parser, we just roughly emulate it's output. (See: #684)\n    env.npm_config_argv = (0, (_stringify || _load_stringify()).default)({ remain: [], cooked: [config.commandName], original: [config.commandName] });\n\n    // add npm_package_*\n    const manifest = yield config.maybeReadManifest(cwd);\n    if (manifest) {\n      const queue = [['', manifest]];\n      while (queue.length) {\n        var _queue$pop = queue.pop(),\n            _queue$pop2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_queue$pop, 2);\n\n        const key = _queue$pop2[0],\n              val = _queue$pop2[1];\n\n        if (key[0] === '_') {\n          continue;\n        }\n\n        if (typeof val === 'object') {\n          for (const subKey in val) {\n            const completeKey = [key, subKey].filter(function (part) {\n              return !!part;\n            }).join('_');\n            queue.push([completeKey, val[subKey]]);\n          }\n        } else if (IGNORE_MANIFEST_KEYS.indexOf(key) < 0) {\n          let cleanVal = String(val);\n          if (cleanVal.indexOf('\\n') >= 0) {\n            cleanVal = (0, (_stringify || _load_stringify()).default)(cleanVal);\n          }\n          env[`npm_package_${key}`] = cleanVal;\n        }\n      }\n    }\n\n    // add npm_config_*\n    const keys = new (_set || _load_set()).default([].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)((0, (_keys || _load_keys()).default)(config.registries.yarn.config)), (0, (_toConsumableArray2 || _load_toConsumableArray()).default)((0, (_keys || _load_keys()).default)(config.registries.npm.config))));\n    for (const key of keys) {\n      if (key.match(/:_/) || IGNORE_CONFIG_KEYS.indexOf(key) >= 0) {\n        continue;\n      }\n\n      let val = config.getOption(key);\n\n      if (!val) {\n        val = '';\n      } else if (typeof val === 'number') {\n        val = '' + val;\n      } else if (typeof val !== 'string') {\n        val = (0, (_stringify || _load_stringify()).default)(val);\n      }\n\n      if (val.indexOf('\\n') >= 0) {\n        val = (0, (_stringify || _load_stringify()).default)(val);\n      }\n\n      const cleanKey = key.replace(/^_+/, '');\n      const envKey = `npm_config_${cleanKey}`.replace(/[^a-zA-Z0-9_]/g, '_');\n      env[envKey] = val;\n    }\n\n    return env;\n  });\n\n  return function makeEnv(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet executeLifecycleScript = exports.executeLifecycleScript = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, config, cwd, cmd, spinner) {\n    // if we don't have a spinner then pipe everything to the terminal\n    const stdio = spinner ? undefined : 'inherit';\n\n    const env = yield makeEnv(stage, cwd, config);\n\n    // split up the path\n    const pathParts = (env[(_constants || _load_constants()).ENV_PATH_KEY] || '').split(path.delimiter);\n\n    // add node-gyp\n    pathParts.unshift(path.join(__dirname, '..', '..', 'bin', 'node-gyp-bin'));\n\n    // add .bin folders to PATH\n    for (const registry of (0, (_keys || _load_keys()).default)((_index || _load_index()).registries)) {\n      const binFolder = path.join(config.registries[registry].folder, '.bin');\n      pathParts.unshift(path.join(config.linkFolder, binFolder));\n      pathParts.unshift(path.join(cwd, binFolder));\n    }\n\n    // join path back together\n    env[(_constants || _load_constants()).ENV_PATH_KEY] = pathParts.join(path.delimiter);\n\n    // get shell\n    const conf = { windowsVerbatimArguments: false };\n    let sh = 'sh';\n    let shFlag = '-c';\n    if (process.platform === 'win32') {\n      // cmd or command.com\n      sh = process.env.comspec || 'cmd';\n\n      // d - Ignore registry AutoRun commands\n      // s - Strip \" quote characters from command.\n      // c - Run Command and then terminate\n      shFlag = '/d /s /c';\n\n      // handle windows run scripts starting with a relative path\n      cmd = (0, (_fixCmdWinSlashes || _load_fixCmdWinSlashes()).fixCmdWinSlashes)(cmd);\n\n      // handle quotes properly in windows environments - https://github.com/nodejs/node/issues/5060\n      conf.windowsVerbatimArguments = true;\n    }\n\n    const stdout = yield (_child || _load_child()).spawn(sh, [shFlag, cmd], (0, (_extends2 || _load_extends()).default)({ cwd: cwd, env: env, stdio: stdio }, conf), function (data) {\n      if (spinner) {\n        const line = data.toString() // turn buffer into string\n        .trim() // trim whitespace\n        .split('\\n') // split into lines\n        .pop() // use only the last line\n        .replace(/\\t/g, ' '); // change tabs to spaces as they can interfere with the console\n\n        if (line) {\n          spinner.tick(line);\n        }\n      }\n    });\n\n    return { cwd: cwd, command: cmd, stdout: stdout };\n  });\n\n  return function executeLifecycleScript(_x4, _x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet execFromManifest = exports.execFromManifest = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, commandName, cwd) {\n    const pkg = yield config.maybeReadManifest(cwd);\n    if (!pkg || !pkg.scripts) {\n      return;\n    }\n\n    const cmd = pkg.scripts[commandName];\n    if (cmd) {\n      yield execCommand(commandName, config, cmd, cwd);\n    }\n  });\n\n  return function execFromManifest(_x9, _x10, _x11) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nlet execCommand = exports.execCommand = (() => {\n  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, config, cmd, cwd) {\n    const reporter = config.reporter;\n\n    try {\n      reporter.command(cmd);\n      yield executeLifecycleScript(stage, config, cwd, cmd);\n      return (_promise || _load_promise()).default.resolve();\n    } catch (err) {\n      if (err instanceof (_errors || _load_errors()).SpawnError) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('commandFailed', err.EXIT_CODE));\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  return function execCommand(_x12, _x13, _x14, _x15) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _child;\n\nfunction _load_child() {\n  return _child = _interopRequireWildcard(require('./child.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../resolvers/index.js');\n}\n\nvar _fixCmdWinSlashes;\n\nfunction _load_fixCmdWinSlashes() {\n  return _fixCmdWinSlashes = require('./fix-cmd-win-slashes.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst IGNORE_MANIFEST_KEYS = ['readme'];\n\n// We treat these configs as internal, thus not expose them to process.env.\n// This helps us avoid some gyp issues when building native modules.\n// See https://github.com/yarnpkg/yarn/issues/2286.\nconst IGNORE_CONFIG_KEYS = ['lastUpdateCheck'];\n\nexports.default = executeLifecycleScript;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/filter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nexports.sortFilter = sortFilter;\nexports.matchesFilter = matchesFilter;\nexports.ignoreLinesToRegex = ignoreLinesToRegex;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst minimatch = require('minimatch');\nconst path = require('path');\n\nconst WHITESPACE_RE = /^\\s+$/;\n\nfunction sortFilter(files, filters) {\n  let keepFiles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new (_set || _load_set()).default();\n  let possibleKeepFiles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new (_set || _load_set()).default();\n  let ignoreFiles = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new (_set || _load_set()).default();\n\n  for (const file of files) {\n    let keep = false;\n\n    // always keep a file if a ! pattern matches it\n    for (const filter of filters) {\n      if (filter.isNegation && matchesFilter(filter, file.basename, file.relative)) {\n        keep = true;\n        break;\n      }\n    }\n\n    //\n    if (keep) {\n      keepFiles.add(file.relative);\n      continue;\n    }\n\n    // otherwise don't keep it if a pattern matches it\n    keep = true;\n    for (const filter of filters) {\n      if (!filter.isNegation && matchesFilter(filter, file.basename, file.relative)) {\n        keep = false;\n        break;\n      }\n    }\n\n    if (keep) {\n      possibleKeepFiles.add(file.relative);\n    } else {\n      ignoreFiles.add(file.relative);\n    }\n  }\n\n  // exclude file\n  for (const file of possibleKeepFiles) {\n    const parts = path.dirname(file).split(path.sep);\n\n    while (parts.length) {\n      const folder = parts.join(path.sep);\n      if (ignoreFiles.has(folder)) {\n        ignoreFiles.add(file);\n        break;\n      }\n      parts.pop();\n    }\n  }\n\n  //\n  for (const file of possibleKeepFiles) {\n    if (!ignoreFiles.has(file)) {\n      keepFiles.add(file);\n    }\n  }\n\n  //\n  for (const file of keepFiles) {\n    const parts = path.dirname(file).split(path.sep);\n\n    while (parts.length) {\n      // deregister this folder from being ignored, any files inside\n      // will still be marked as ignored\n      ignoreFiles.delete(parts.join(path.sep));\n      parts.pop();\n    }\n  }\n\n  return { keepFiles: keepFiles, ignoreFiles: ignoreFiles };\n}\n\nfunction matchesFilter(filter, basename, loc) {\n  if (filter.base && filter.base !== '.') {\n    loc = path.relative(filter.base, loc);\n  }\n  return filter.regex.test(loc) || filter.regex.test(`/${loc}`) || filter.regex.test(basename);\n}\n\nfunction ignoreLinesToRegex(lines) {\n  let base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n\n  return lines\n  // create regex\n  .map(line => {\n    // remove empty lines, comments, etc\n    if (line === '' || line === '!' || line[0] === '#' || WHITESPACE_RE.test(line)) {\n      return null;\n    }\n\n    let pattern = line;\n    let isNegation = false;\n\n    // hide the fact that it's a negation from minimatch since we'll handle this specifally\n    // ourselves\n    if (pattern[0] === '!') {\n      isNegation = true;\n      pattern = pattern.slice(1);\n    }\n\n    // remove trailing slash\n    pattern = (0, (_misc || _load_misc()).removeSuffix)(pattern, '/');\n\n    const regex = minimatch.makeRe(pattern, { nocase: true });\n\n    if (regex) {\n      return {\n        base: base,\n        isNegation: isNegation,\n        regex: regex\n      };\n    } else {\n      return null;\n    }\n  }).filter(Boolean);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/fix-cmd-win-slashes.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixCmdWinSlashes = fixCmdWinSlashes;\nfunction fixCmdWinSlashes(cmd) {\n  function findQuotes(quoteSymbol) {\n    const quotes = [];\n    const addQuote = (_, index) => {\n      quotes.push({ from: index, to: index + _.length });\n      return _;\n    };\n    const regEx = new RegExp(quoteSymbol + '.*' + quoteSymbol);\n    cmd.replace(regEx, addQuote);\n    return quotes;\n  }\n  const quotes = findQuotes('\"').concat(findQuotes('\\''));\n\n  function isInsideQuotes(index) {\n    return quotes.reduce((result, quote) => {\n      return result || quote.from <= index && index <= quote.to;\n    }, false);\n  }\n\n  const cmdPrePattern = '((?:^|&&|&|\\\\|\\\\||\\\\|)\\\\s*)';\n  const cmdPattern = '(\".*?\"|\\'.*?\\'|\\\\S*)';\n  const regExp = new RegExp(`${cmdPrePattern}${cmdPattern}`, 'g');\n  return cmd.replace(regExp, (whole, pre, cmd, index) => {\n    if ((pre[0] === '&' || pre[0] === '|') && isInsideQuotes(index)) {\n      return whole;\n    }\n    return pre + cmd.replace(/\\//g, '\\\\');\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/fs.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeTempDir = exports.hardlinksWork = exports.writeFilePreservingEol = exports.getFileSizeOnDisk = exports.walk = exports.symlink = exports.find = exports.readJsonAndFile = exports.readJson = exports.readFileAny = exports.hardlinkBulk = exports.copyBulk = exports.link = exports.chmod = exports.lstat = exports.exists = exports.mkdirp = exports.unlink = exports.stat = exports.access = exports.rename = exports.readdir = exports.realpath = exports.readlink = exports.writeFile = exports.readFileBuffer = exports.lockQueue = undefined;\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _set;\n\nfunction _load_set() {\n  return _set = _interopRequireDefault(require('babel-runtime/core-js/set'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet buildActionsForCopy = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n        files.add(dest);\n\n        if (events.ignoreBasenames.indexOf(path.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        if (yield exists(dest)) {\n          const destStat = yield lstat(dest);\n\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          if (srcStat.mode !== destStat.mode) {\n            try {\n              yield access(dest, srcStat.mode);\n            } catch (err) {\n              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n              // us modes that aren't valid. investigate this, it's generally safe to proceed.\n            }\n          }\n\n          if (bothFiles && srcStat.size === destStat.size && +srcStat.mtime === +destStat.mtime) {\n            // we can safely assume this is the same file\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.size, +srcStat.mtime));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (const file of destFiles) {\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = path.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (const file of yield readdir(loc)) {\n                    possibleExtraneous.add(path.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.push({\n            type: 'symlink',\n            dest: dest,\n            linkname: linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          reporter.verbose(reporter.lang('verboseFileFolder', dest));\n          yield mkdirp(dest);\n\n          const destParts = dest.split(path.sep);\n          while (destParts.length) {\n            files.add(destParts.join(path.sep));\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (const file of srcFiles) {\n            queue.push({\n              onFresh: onFresh,\n              src: path.join(src, file),\n              dest: path.join(dest, file),\n              onDone: function (_onDone) {\n                function onDone() {\n                  return _onDone.apply(this, arguments);\n                }\n\n                onDone.toString = function () {\n                  return _onDone.toString();\n                };\n\n                return onDone;\n              }(function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              })\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.push({\n            type: 'file',\n            src: src,\n            dest: dest,\n            atime: srcStat.atime,\n            mtime: srcStat.mtime,\n            mode: srcStat.mode\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new (_set || _load_set()).default(events.artifactFiles || []);\n    const files = new (_set || _load_set()).default();\n\n    // initialise events\n    for (const item of queue) {\n      const onDone = item.onDone;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        if (onDone) {\n          onDone();\n        }\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = [];\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield (_promise || _load_promise()).default.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraenous\n    for (const file of artifactFiles) {\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (const loc of possibleExtraneous) {\n      if (files.has(loc)) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForCopy(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet buildActionsForHardlink = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n        files.add(dest);\n\n        if (events.ignoreBasenames.indexOf(path.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        const destExists = yield exists(dest);\n        if (destExists) {\n          const destStat = yield lstat(dest);\n\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          if (srcStat.mode !== destStat.mode) {\n            try {\n              yield access(dest, srcStat.mode);\n            } catch (err) {\n              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n              // us modes that aren't valid. investigate this, it's generally safe to proceed.\n              reporter.verbose(err);\n            }\n          }\n\n          // correct hardlink\n          if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.ino));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (const file of destFiles) {\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = path.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (const file of yield readdir(loc)) {\n                    possibleExtraneous.add(path.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.push({\n            type: 'symlink',\n            dest: dest,\n            linkname: linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          reporter.verbose(reporter.lang('verboseFileFolder', dest));\n          yield mkdirp(dest);\n\n          const destParts = dest.split(path.sep);\n          while (destParts.length) {\n            files.add(destParts.join(path.sep));\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (const file of srcFiles) {\n            queue.push({\n              onFresh: onFresh,\n              src: path.join(src, file),\n              dest: path.join(dest, file),\n              onDone: function (_onDone2) {\n                function onDone() {\n                  return _onDone2.apply(this, arguments);\n                }\n\n                onDone.toString = function () {\n                  return _onDone2.toString();\n                };\n\n                return onDone;\n              }(function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              })\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.push({\n            type: 'link',\n            src: src,\n            dest: dest,\n            removeDest: destExists\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x10) {\n        return _ref4.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new (_set || _load_set()).default(events.artifactFiles || []);\n    const files = new (_set || _load_set()).default();\n\n    // initialise events\n    for (const item of queue) {\n      const onDone = item.onDone;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        if (onDone) {\n          onDone();\n        }\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = [];\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield (_promise || _load_promise()).default.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraenous\n    for (const file of artifactFiles) {\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (const loc of possibleExtraneous) {\n      if (files.has(loc)) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForHardlink(_x6, _x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nlet copyBulk = exports.copyBulk = (() => {\n  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new (_set || _load_set()).default(),\n      ignoreBasenames: _events && _events.ignoreBasenames || [],\n      artifactFiles: _events && _events.artifactFiles || []\n    };\n\n    const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.length);\n\n    const fileActions = actions.filter(function (action) {\n      return action.type === 'file';\n    });\n\n    const currentlyWriting = {};\n\n    yield (_promise2 || _load_promise2()).queue(fileActions, (() => {\n      var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        let writePromise;\n        while (writePromise = currentlyWriting[data.dest]) {\n          yield writePromise;\n        }\n\n        const cleanup = function cleanup() {\n          return delete currentlyWriting[data.dest];\n        };\n        return currentlyWriting[data.dest] = new (_promise || _load_promise()).default(function (resolve, reject) {\n          const readStream = fs.createReadStream(data.src);\n          const writeStream = fs.createWriteStream(data.dest, { mode: data.mode });\n\n          reporter.verbose(reporter.lang('verboseFileCopy', data.src, data.dest));\n\n          readStream.on('error', reject);\n          writeStream.on('error', reject);\n\n          writeStream.on('open', function () {\n            readStream.pipe(writeStream);\n          });\n\n          writeStream.once('finish', function () {\n            fs.utimes(data.dest, data.atime, data.mtime, function (err) {\n              if (err) {\n                reject(err);\n              } else {\n                events.onProgress(data.dest);\n                cleanup();\n                resolve();\n              }\n            });\n          });\n        }).then(function (arg) {\n          cleanup();\n          return arg;\n        }).catch(function (arg) {\n          cleanup();\n          throw arg;\n        });\n      });\n\n      return function (_x14) {\n        return _ref6.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.filter(function (action) {\n      return action.type === 'symlink';\n    });\n    yield (_promise2 || _load_promise2()).queue(symlinkActions, function (data) {\n      const linkname = path.resolve(path.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function copyBulk(_x11, _x12, _x13) {\n    return _ref5.apply(this, arguments);\n  };\n})();\n\nlet hardlinkBulk = exports.hardlinkBulk = (() => {\n  var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new (_set || _load_set()).default(),\n      artifactFiles: _events && _events.artifactFiles || [],\n      ignoreBasenames: []\n    };\n\n    const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.length);\n\n    const fileActions = actions.filter(function (action) {\n      return action.type === 'link';\n    });\n\n    yield (_promise2 || _load_promise2()).queue(fileActions, (() => {\n      var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        reporter.verbose(reporter.lang('verboseFileLink', data.src, data.dest));\n        if (data.removeDest) {\n          yield unlink(data.dest);\n        }\n        yield link(data.src, data.dest);\n      });\n\n      return function (_x18) {\n        return _ref8.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.filter(function (action) {\n      return action.type === 'symlink';\n    });\n    yield (_promise2 || _load_promise2()).queue(symlinkActions, function (data) {\n      const linkname = path.resolve(path.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function hardlinkBulk(_x15, _x16, _x17) {\n    return _ref7.apply(this, arguments);\n  };\n})();\n\nlet readFileAny = exports.readFileAny = (() => {\n  var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {\n    for (const file of files) {\n      if (yield exists(file)) {\n        return readFile(file);\n      }\n    }\n    return null;\n  });\n\n  return function readFileAny(_x19) {\n    return _ref9.apply(this, arguments);\n  };\n})();\n\nlet readJson = exports.readJson = (() => {\n  var _ref10 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    return (yield readJsonAndFile(loc)).object;\n  });\n\n  return function readJson(_x20) {\n    return _ref10.apply(this, arguments);\n  };\n})();\n\nlet readJsonAndFile = exports.readJsonAndFile = (() => {\n  var _ref11 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const file = yield readFile(loc);\n    try {\n      return {\n        object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),\n        content: file\n      };\n    } catch (err) {\n      err.message = `${loc}: ${err.message}`;\n      throw err;\n    }\n  });\n\n  return function readJsonAndFile(_x21) {\n    return _ref11.apply(this, arguments);\n  };\n})();\n\nlet find = exports.find = (() => {\n  var _ref12 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {\n    const parts = dir.split(path.sep);\n\n    while (parts.length) {\n      const loc = parts.concat(filename).join(path.sep);\n\n      if (yield exists(loc)) {\n        return loc;\n      } else {\n        parts.pop();\n      }\n    }\n\n    return false;\n  });\n\n  return function find(_x22, _x23) {\n    return _ref12.apply(this, arguments);\n  };\n})();\n\nlet symlink = exports.symlink = (() => {\n  var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    try {\n      const stats = yield lstat(dest);\n\n      if (stats.isSymbolicLink() && (yield exists(dest))) {\n        const resolved = yield realpath(dest);\n        if (resolved === src) {\n          return;\n        }\n      }\n\n      yield unlink(dest);\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n\n    try {\n      if (process.platform === 'win32') {\n        // use directory junctions if possible on win32, this requires absolute paths\n        yield fsSymlink(src, dest, 'junction');\n      } else {\n        // use relative paths otherwise which will be retained if the directory is moved\n        let relative;\n        if (yield exists(src)) {\n          relative = path.relative(fs.realpathSync(path.dirname(dest)), fs.realpathSync(src));\n        } else {\n          relative = path.relative(path.dirname(dest), src);\n        }\n        yield fsSymlink(relative, dest);\n      }\n    } catch (err) {\n      if (err.code === 'EEXIST') {\n        // race condition\n        yield symlink(src, dest);\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  return function symlink(_x24, _x25) {\n    return _ref13.apply(this, arguments);\n  };\n})();\n\nlet walk = exports.walk = (() => {\n  var _ref14 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir) {\n    let ignoreBasenames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new (_set || _load_set()).default();\n\n    let files = [];\n\n    let filenames = yield readdir(dir);\n    if (ignoreBasenames.size) {\n      filenames = filenames.filter(function (name) {\n        return !ignoreBasenames.has(name);\n      });\n    }\n\n    for (const name of filenames) {\n      const relative = relativeDir ? path.join(relativeDir, name) : name;\n      const loc = path.join(dir, name);\n      const stat = yield lstat(loc);\n\n      files.push({\n        relative: relative,\n        basename: name,\n        absolute: loc,\n        mtime: +stat.mtime\n      });\n\n      if (stat.isDirectory()) {\n        files = files.concat((yield walk(loc, relative, ignoreBasenames)));\n      }\n    }\n\n    return files;\n  });\n\n  return function walk(_x27, _x28) {\n    return _ref14.apply(this, arguments);\n  };\n})();\n\nlet getFileSizeOnDisk = exports.getFileSizeOnDisk = (() => {\n  var _ref15 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const stat = yield lstat(loc);\n    const size = stat.size,\n          blockSize = stat.blksize;\n\n\n    return Math.ceil(size / blockSize) * blockSize;\n  });\n\n  return function getFileSizeOnDisk(_x29) {\n    return _ref15.apply(this, arguments);\n  };\n})();\n\nlet getEolFromFile = (() => {\n  var _ref16 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {\n    if (!(yield exists(path))) {\n      return undefined;\n    }\n\n    const buffer = yield readFileBuffer(path);\n\n    for (let i = 0; i < buffer.length; ++i) {\n      if (buffer[i] === cr) {\n        return '\\r\\n';\n      }\n      if (buffer[i] === lf) {\n        return '\\n';\n      }\n    }\n    return undefined;\n  });\n\n  return function getEolFromFile(_x30) {\n    return _ref16.apply(this, arguments);\n  };\n})();\n\nlet writeFilePreservingEol = exports.writeFilePreservingEol = (() => {\n  var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {\n    const eol = (yield getEolFromFile(path)) || os.EOL;\n    if (eol !== '\\n') {\n      data = data.replace(/\\n/g, eol);\n    }\n    yield (0, (_promise3 || _load_promise3()).promisify)(fs.writeFile)(path, data);\n  });\n\n  return function writeFilePreservingEol(_x31, _x32) {\n    return _ref17.apply(this, arguments);\n  };\n})();\n\nlet hardlinksWork = exports.hardlinksWork = (() => {\n  var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {\n    const filename = 'test-file' + Math.random();\n    const file = path.join(dir, filename);\n    const fileLink = path.join(dir, filename + '-link');\n    try {\n      yield writeFile(file, 'test');\n      yield link(file, fileLink);\n    } catch (err) {\n      return false;\n    } finally {\n      yield unlink(file);\n      yield unlink(fileLink);\n    }\n    return true;\n  });\n\n  return function hardlinksWork(_x33) {\n    return _ref18.apply(this, arguments);\n  };\n})();\n\n// not a strict polyfill for Node's fs.mkdtemp\n\n\nlet makeTempDir = exports.makeTempDir = (() => {\n  var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {\n    const dir = path.join(os.tmpdir(), `yarn-${prefix || ''}-${Date.now()}-${Math.random()}`);\n    yield unlink(dir);\n    yield mkdirp(dir);\n    return dir;\n  });\n\n  return function makeTempDir(_x34) {\n    return _ref19.apply(this, arguments);\n  };\n})();\n\nexports.copy = copy;\nexports.readFile = readFile;\nexports.readFileRaw = readFileRaw;\nexports.normalizeOS = normalizeOS;\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _promise2;\n\nfunction _load_promise2() {\n  return _promise2 = _interopRequireWildcard(require('./promise.js'));\n}\n\nvar _promise3;\n\nfunction _load_promise3() {\n  return _promise3 = require('./promise.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst fs = require('fs');\nconst os = require('os');\n\nconst lockQueue = exports.lockQueue = new (_blockingQueue || _load_blockingQueue()).default('fs lock');\n\nconst readFileBuffer = exports.readFileBuffer = (0, (_promise3 || _load_promise3()).promisify)(fs.readFile);\nconst writeFile = exports.writeFile = (0, (_promise3 || _load_promise3()).promisify)(fs.writeFile);\nconst readlink = exports.readlink = (0, (_promise3 || _load_promise3()).promisify)(fs.readlink);\nconst realpath = exports.realpath = (0, (_promise3 || _load_promise3()).promisify)(fs.realpath);\nconst readdir = exports.readdir = (0, (_promise3 || _load_promise3()).promisify)(fs.readdir);\nconst rename = exports.rename = (0, (_promise3 || _load_promise3()).promisify)(fs.rename);\nconst access = exports.access = (0, (_promise3 || _load_promise3()).promisify)(fs.access);\nconst stat = exports.stat = (0, (_promise3 || _load_promise3()).promisify)(fs.stat);\nconst unlink = exports.unlink = (0, (_promise3 || _load_promise3()).promisify)(require('rimraf'));\nconst mkdirp = exports.mkdirp = (0, (_promise3 || _load_promise3()).promisify)(require('mkdirp'));\nconst exists = exports.exists = (0, (_promise3 || _load_promise3()).promisify)(fs.exists, true);\nconst lstat = exports.lstat = (0, (_promise3 || _load_promise3()).promisify)(fs.lstat);\nconst chmod = exports.chmod = (0, (_promise3 || _load_promise3()).promisify)(fs.chmod);\nconst link = exports.link = (0, (_promise3 || _load_promise3()).promisify)(fs.link);\n\nconst CONCURRENT_QUEUE_ITEMS = 4;\n\nconst fsSymlink = (0, (_promise3 || _load_promise3()).promisify)(fs.symlink);\nconst invariant = require('invariant');\nconst stripBOM = require('strip-bom');\n\nconst noop = () => {};\n\nfunction copy(src, dest, reporter) {\n  return copyBulk([{ src: src, dest: dest }], reporter);\n}\n\nfunction _readFile(loc, encoding) {\n  return new (_promise || _load_promise()).default((resolve, reject) => {\n    fs.readFile(loc, encoding, function (err, content) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(content);\n      }\n    });\n  });\n}\n\nfunction readFile(loc) {\n  return _readFile(loc, 'utf8').then(normalizeOS);\n}\n\nfunction readFileRaw(loc) {\n  return _readFile(loc, 'binary');\n}\n\nfunction normalizeOS(body) {\n  return body.replace(/\\r\\n/g, '\\n');\n}\n\nconst cr = new Buffer('\\r', 'utf8')[0];\nconst lf = new Buffer('\\n', 'utf8')[0];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/misc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortAlpha = sortAlpha;\nexports.entries = entries;\nexports.removePrefix = removePrefix;\nexports.removeSuffix = removeSuffix;\nexports.addSuffix = addSuffix;\nexports.hyphenate = hyphenate;\nexports.camelCase = camelCase;\nconst _camelCase = require('camelcase');\n\nfunction sortAlpha(a, b) {\n  // sort alphabetically in a deterministic way\n  const shortLen = Math.min(a.length, b.length);\n  for (let i = 0; i < shortLen; i++) {\n    const aChar = a.charCodeAt(i);\n    const bChar = b.charCodeAt(i);\n    if (aChar !== bChar) {\n      return aChar - bChar;\n    }\n  }\n  return a.length - b.length;\n}\n\nfunction entries(obj) {\n  const entries = [];\n  if (obj) {\n    for (const key in obj) {\n      entries.push([key, obj[key]]);\n    }\n  }\n  return entries;\n}\n\nfunction removePrefix(pattern, prefix) {\n  if (pattern.startsWith(prefix)) {\n    pattern = pattern.slice(prefix.length);\n  }\n\n  return pattern;\n}\n\nfunction removeSuffix(pattern, suffix) {\n  if (pattern.endsWith(suffix)) {\n    return pattern.slice(0, -suffix.length);\n  }\n\n  return pattern;\n}\n\nfunction addSuffix(pattern, suffix) {\n  if (!pattern.endsWith(suffix)) {\n    return pattern + suffix;\n  }\n\n  return pattern;\n}\n\nfunction hyphenate(str) {\n  return str.replace(/[A-Z]/g, match => {\n    return '-' + match.charAt(0).toLowerCase();\n  });\n}\n\nfunction camelCase(str) {\n  if (/[A-Z]/.test(str)) {\n    return null;\n  } else {\n    return _camelCase(str);\n  }\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/mutex.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require(\"babel-runtime/core-js/promise\"));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require(\"babel-runtime/core-js/map\"));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst lockPromises = new (_map || _load_map()).default();\n\n/**\n * Acquires a mutex lock over the given key. If the lock can't be acquired, it waits until it's available.\n * @param key Key to get the lock for.\n * @return {Promise.<Function>} A Promise that resolves when the lock is acquired, with the function that\n * must be called to release the lock.\n */\n\nexports.default = key => {\n  let unlockNext;\n  const willLock = new (_promise || _load_promise()).default(resolve => unlockNext = resolve);\n  const lockPromise = lockPromises.get(key) || (_promise || _load_promise()).default.resolve();\n  const willUnlock = lockPromise.then(() => unlockNext);\n  lockPromises.set(key, lockPromise.then(() => willLock));\n  return willUnlock;\n};","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/network.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOffline = isOffline;\nconst os = require('os');\n\nconst IGNORE_INTERFACES = ['lo0', 'awdl0', 'bridge0'];\nconst LOCAL_IPS = ['127.0.0.1', '::1'];\n\nfunction isOffline() {\n  let interfaces;\n\n  try {\n    interfaces = os.networkInterfaces();\n  } catch (e) {\n    // As of October 2016, Windows Subsystem for Linux (WSL) does not support\n    // the os.networkInterfaces() call and throws instead. For this platform,\n    // assume we are online.\n    if (e.syscall === 'uv_interface_addresses') {\n      return false;\n    } else {\n      throw e;\n    }\n  }\n\n  for (const name in interfaces) {\n    if (IGNORE_INTERFACES.indexOf(name) >= 0) {\n      continue;\n    }\n\n    const addrs = interfaces[name];\n    for (const addr of addrs) {\n      if (LOCAL_IPS.indexOf(addr.address) < 0) {\n        // found a possible remote ip\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/parse-package-name.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require(\"babel-runtime/helpers/slicedToArray\"));\n}\n\nexports.default = parsePackageName;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst PKG_INPUT = /(^\\S?[^\\s@]+)(?:@(\\S+))?$/;\n\nfunction parsePackageName(input) {\n  var _PKG_INPUT$exec = PKG_INPUT.exec(input),\n      _PKG_INPUT$exec2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_PKG_INPUT$exec, 3);\n\n  const name = _PKG_INPUT$exec2[1],\n        version = _PKG_INPUT$exec2[2];\n\n  return { name: name, version: version };\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/request-manager.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _network;\n\nfunction _load_network() {\n  return _network = _interopRequireWildcard(require('./network.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst RequestCaptureHar = require('request-capture-har');\nconst invariant = require('invariant');\nconst url = require('url');\nconst fs = require('fs');\n\nconst successHosts = (0, (_map || _load_map()).default)();\nconst controlOffline = (_network || _load_network()).isOffline();\n\nclass RequestManager {\n  constructor(reporter) {\n    this.offlineNoRequests = false;\n    this._requestCaptureHar = null;\n    this._requestModule = null;\n    this.offlineQueue = [];\n    this.captureHar = false;\n    this.httpsProxy = null;\n    this.ca = null;\n    this.httpProxy = null;\n    this.strictSSL = true;\n    this.userAgent = '';\n    this.reporter = reporter;\n    this.running = 0;\n    this.queue = [];\n    this.cache = {};\n    this.max = (_constants || _load_constants()).NETWORK_CONCURRENCY;\n  }\n\n  setOptions(opts) {\n    if (opts.userAgent != null) {\n      this.userAgent = opts.userAgent;\n    }\n\n    if (opts.offline != null) {\n      this.offlineNoRequests = opts.offline;\n    }\n\n    if (opts.captureHar != null) {\n      this.captureHar = opts.captureHar;\n    }\n\n    if (opts.httpProxy != null) {\n      this.httpProxy = opts.httpProxy;\n    }\n\n    if (opts.httpsProxy != null) {\n      this.httpsProxy = opts.httpsProxy;\n    }\n\n    if (opts.strictSSL !== null && typeof opts.strictSSL !== 'undefined') {\n      this.strictSSL = opts.strictSSL;\n    }\n\n    if (opts.ca != null && opts.ca.length > 0) {\n      this.ca = opts.ca;\n    }\n\n    if (opts.networkConcurrency != null) {\n      this.max = opts.networkConcurrency;\n    }\n\n    if (opts.cafile != null && opts.cafile != '') {\n      // The CA bundle file can contain one or more certificates with comments/text between each PEM block.\n      // tls.connect wants an array of certificates without any comments/text, so we need to split the string\n      // and strip out any text in between the certificates\n      try {\n        const bundle = fs.readFileSync(opts.cafile).toString();\n        const hasPemPrefix = block => block.startsWith('-----BEGIN ');\n        // opts.cafile overrides opts.ca, this matches with npm behavior\n        this.ca = bundle.split(/(-----BEGIN .*\\r?\\n[^-]+\\r?\\n--.*)/).filter(hasPemPrefix);\n      } catch (err) {\n        this.reporter.error(`Could not open cafile: ${err.message}`);\n      }\n    }\n\n    if (opts.cert != null) {\n      this.cert = opts.cert;\n    }\n\n    if (opts.key != null) {\n      this.key = opts.key;\n    }\n  }\n\n  /**\n   * Lazy load `request` since it is exceptionally expensive to load and is\n   * often not needed at all.\n   */\n\n  _getRequestModule() {\n    if (!this._requestModule) {\n      const request = require('request');\n      if (this.captureHar) {\n        this._requestCaptureHar = new RequestCaptureHar(request);\n        this._requestModule = this._requestCaptureHar.request.bind(this._requestCaptureHar);\n      } else {\n        this._requestModule = request;\n      }\n    }\n    return this._requestModule;\n  }\n\n  /**\n   * Queue up a request.\n   */\n\n  request(params) {\n    if (this.offlineNoRequests) {\n      return (_promise || _load_promise()).default.reject(new (_errors || _load_errors()).MessageError(this.reporter.lang('cantRequestOffline')));\n    }\n\n    const cached = this.cache[params.url];\n    if (cached) {\n      return cached;\n    }\n\n    params.method = params.method || 'GET';\n    params.forever = true;\n    params.retryAttempts = 0;\n    params.strictSSL = this.strictSSL;\n    params.headers = (0, (_assign || _load_assign()).default)({\n      'User-Agent': this.userAgent\n    }, params.headers);\n\n    const promise = new (_promise || _load_promise()).default((resolve, reject) => {\n      this.queue.push({ params: params, resolve: resolve, reject: reject });\n      this.shiftQueue();\n    });\n\n    // we can't cache a request with a processor\n    if (!params.process) {\n      this.cache[params.url] = promise;\n    }\n\n    return promise;\n  }\n\n  /**\n   * Clear the request cache. This is important as we cache all HTTP requests so you'll\n   * want to do this as soon as you can.\n   */\n\n  clearCache() {\n    this.cache = {};\n    if (this._requestCaptureHar != null) {\n      this._requestCaptureHar.clear();\n    }\n  }\n\n  /**\n   * Check if an error is possibly due to lost or poor network connectivity.\n   */\n\n  isPossibleOfflineError(err) {\n    const code = err.code,\n          hostname = err.hostname;\n\n    if (!code) {\n      return false;\n    }\n\n    // network was previously online but now we're offline\n    const possibleOfflineChange = !controlOffline && !(_network || _load_network()).isOffline();\n    if (code === 'ENOTFOUND' && possibleOfflineChange) {\n      // can't resolve a domain\n      return true;\n    }\n\n    // used to be able to resolve this domain! something is wrong\n    if (code === 'ENOTFOUND' && hostname && successHosts[hostname]) {\n      // can't resolve this domain but we've successfully resolved it before\n      return true;\n    }\n\n    // network was previously offline and we can't resolve the domain\n    if (code === 'ENOTFOUND' && controlOffline) {\n      return true;\n    }\n\n    // connection was reset or dropped\n    if (code === 'ECONNRESET') {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Queue up request arguments to be retried. Start a network connectivity timer if there\n   * isn't already one.\n   */\n\n  queueForOffline(opts) {\n    if (!this.offlineQueue.length) {\n      this.reporter.warn(this.reporter.lang('offlineRetrying'));\n      this.initOfflineRetry();\n    }\n\n    this.offlineQueue.push(opts);\n  }\n\n  /**\n   * Begin timers to retry failed requests when we possibly establish network connectivity\n   * again.\n   */\n\n  initOfflineRetry() {\n    setTimeout(() => {\n      const queue = this.offlineQueue;\n      this.offlineQueue = [];\n      for (const opts of queue) {\n        this.execute(opts);\n      }\n    }, 3000);\n  }\n\n  /**\n   * Execute a request.\n   */\n\n  execute(opts) {\n    const params = opts.params;\n    const reporter = this.reporter;\n\n\n    const buildNext = fn => data => {\n      fn(data);\n      this.running--;\n      this.shiftQueue();\n    };\n\n    const resolve = buildNext(opts.resolve);\n\n    const rejectNext = buildNext(opts.reject);\n    const reject = function reject(err) {\n      err.message = `${params.url}: ${err.message}`;\n      rejectNext(err);\n    };\n\n    //\n    let calledOnError = false;\n    const onError = err => {\n      if (calledOnError) {\n        return;\n      }\n      calledOnError = true;\n\n      const attempts = params.retryAttempts || 0;\n      if (attempts < 5 && this.isPossibleOfflineError(err)) {\n        params.retryAttempts = attempts + 1;\n        if (typeof params.cleanup === 'function') {\n          params.cleanup();\n        }\n        this.queueForOffline(opts);\n      } else {\n        reject(err);\n      }\n    };\n\n    if (!params.process) {\n      const parts = url.parse(params.url);\n\n      params.callback = (err, res, body) => {\n        if (err) {\n          onError(err);\n          return;\n        }\n\n        successHosts[parts.hostname] = true;\n\n        this.reporter.verbose(this.reporter.lang('verboseRequestFinish', params.url, res.statusCode));\n\n        if (body && typeof body.error === 'string') {\n          reject(new Error(body.error));\n          return;\n        }\n\n        if (res.statusCode === 403) {\n          const errMsg = body && body.message || reporter.lang('requestError', params.url, res.statusCode);\n          reject(new Error(errMsg));\n        } else {\n          if (res.statusCode === 400 || res.statusCode === 404 || res.statusCode === 401) {\n            body = false;\n          }\n          resolve(body);\n        }\n      };\n    }\n\n    if (params.buffer) {\n      params.encoding = null;\n    }\n\n    let proxy = this.httpProxy;\n    if (params.url.startsWith('https:')) {\n      proxy = this.httpsProxy || proxy;\n    }\n    if (proxy) {\n      params.proxy = proxy;\n    }\n\n    if (this.ca != null) {\n      params.ca = this.ca;\n    }\n\n    if (this.cert != null) {\n      params.cert = this.cert;\n    }\n\n    if (this.key != null) {\n      params.key = this.key;\n    }\n\n    const request = this._getRequestModule();\n    const req = request(params);\n    this.reporter.verbose(this.reporter.lang('verboseRequestStart', params.method, params.url));\n\n    req.on('error', onError);\n\n    const queue = params.queue;\n    if (queue) {\n      req.on('data', queue.stillActive.bind(queue));\n    }\n\n    if (params.process) {\n      params.process(req, resolve, reject);\n    }\n  }\n\n  /**\n   * Remove an item from the queue. Create it's request options and execute it.\n   */\n\n  shiftQueue() {\n    if (this.running >= this.max || !this.queue.length) {\n      return;\n    }\n\n    const opts = this.queue.shift();\n\n    this.running++;\n    this.execute(opts);\n  }\n\n  saveHar(filename) {\n    if (!this.captureHar) {\n      throw new Error(this.reporter.lang('requestManagerNotSetupHAR'));\n    }\n    // No request may have occurred at all.\n    this._getRequestModule();\n    invariant(this._requestCaptureHar != null, 'request-capture-har not setup');\n    this._requestCaptureHar.saveHar(filename);\n  }\n}\nexports.default = RequestManager;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/stream.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst invariant = require('invariant');\nconst stream = require('stream');\nconst zlib = require('zlib');\n\nfunction hasGzipHeader(chunk) {\n  return chunk[0] === 0x1F && chunk[1] === 0x8B && chunk[2] === 0x08;\n}\n\nclass UnpackStream extends stream.Transform {\n  constructor(options) {\n    super(options);\n    this._srcStream = null;\n    this._readHeader = false;\n    this.once('pipe', src => {\n      this._srcStream = src;\n    });\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!this._readHeader) {\n      this._readHeader = true;\n      invariant(chunk instanceof Buffer, 'Chunk must be a buffer');\n      if (hasGzipHeader(chunk)) {\n        // Stop receiving data from the src stream, and pipe it instead to zlib,\n        // then pipe it's output through us.\n        const unzipStream = zlib.createUnzip();\n        unzipStream.on('error', err => this.emit('error', err));\n\n        const srcStream = this._srcStream;\n        invariant(srcStream, 'How? To get here a stream must have been piped!');\n        srcStream.pipe(unzipStream).pipe(this);\n\n        // Unpipe after another stream has been piped so it's always piping to\n        // something, thus avoiding pausing it.\n        srcStream.unpipe(this);\n        unzipStream.write(chunk);\n        this._srcStream = null;\n        callback();\n        return;\n      }\n    }\n    callback(null, chunk);\n  }\n}\n\nexports.UnpackStream = UnpackStream;\nclass ConcatStream extends stream.Transform {\n  constructor(done) {\n    super();\n    this._data = [];\n    this._done = done;\n  }\n\n  _transform(chunk, encoding, callback) {\n    invariant(chunk instanceof Buffer, 'Chunk must be a buffer');\n    invariant(this._data != null, 'Missing data array');\n    this._data.push(chunk);\n    this.push(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    invariant(this._data != null, 'Missing data array');\n    this._done(Buffer.concat(this._data));\n    this._data = null;\n    callback();\n  }\n}\nexports.ConcatStream = ConcatStream;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/version.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explodeHashedUrl = explodeHashedUrl;\nfunction explodeHashedUrl(url) {\n  const parts = url.split('#');\n\n  return {\n    url: parts[0],\n    hash: parts[1] || ''\n  };\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/console/console-reporter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));\n}\n\nvar _toConsumableArray2;\n\nfunction _load_toConsumableArray() {\n  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));\n}\n\nvar _baseReporter;\n\nfunction _load_baseReporter() {\n  return _baseReporter = _interopRequireDefault(require('../base-reporter.js'));\n}\n\nvar _progressBar;\n\nfunction _load_progressBar() {\n  return _progressBar = _interopRequireDefault(require('./progress-bar.js'));\n}\n\nvar _spinnerProgress;\n\nfunction _load_spinnerProgress() {\n  return _spinnerProgress = _interopRequireDefault(require('./spinner-progress.js'));\n}\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nvar _treeHelper;\n\nfunction _load_treeHelper() {\n  return _treeHelper = require('./helpers/tree-helper.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _require = require('util');\n\nconst inspect = _require.inspect;\n\nconst readline = require('readline');\nconst chalk = require('chalk');\nconst read = require('read');\n\nclass ConsoleReporter extends (_baseReporter || _load_baseReporter()).default {\n  constructor(opts) {\n    super(opts);\n    this._lastCategorySize = 0;\n\n    this.format = chalk;\n  }\n\n  _prependEmoji(msg, emoji) {\n    if (this.emoji && emoji && this.isTTY) {\n      msg = `${emoji}  ${msg}`;\n    }\n    return msg;\n  }\n\n  _logCategory(category, color, msg) {\n    this._lastCategorySize = category.length;\n    this._log(`${this.format[color](category)} ${msg}`);\n  }\n\n  _verbose(msg) {\n    this._logCategory('verbose', 'grey', `${process.uptime()} ${msg}`);\n  }\n\n  _verboseInspect(obj) {\n    this.inspect(obj);\n  }\n\n  table(head, body) {\n    //\n    head = head.map(field => this.format.underline(field));\n\n    //\n    const rows = [head].concat(body);\n\n    // get column widths\n    const cols = [];\n    for (let i = 0; i < head.length; i++) {\n      const widths = rows.map(row => this.format.stripColor(row[i]).length);\n      cols[i] = Math.max.apply(Math, (0, (_toConsumableArray2 || _load_toConsumableArray()).default)(widths));\n    }\n\n    //\n    const builtRows = rows.map(row => {\n      for (let i = 0; i < row.length; i++) {\n        const field = row[i];\n        const padding = cols[i] - this.format.stripColor(field).length;\n\n        row[i] = field + ' '.repeat(padding);\n      }\n      return row.join(' ');\n    });\n\n    this.log(builtRows.join('\\n'));\n  }\n\n  step(current, total, msg, emoji) {\n    msg = this._prependEmoji(msg, emoji);\n\n    if (msg.endsWith('?')) {\n      msg = `${(0, (_misc || _load_misc()).removeSuffix)(msg, '?')}...?`;\n    } else {\n      msg += '...';\n    }\n\n    this.log(`${this.format.dim(`[${current}/${total}]`)} ${msg}`);\n  }\n\n  inspect(value) {\n    if (typeof value !== 'number' && typeof value !== 'string') {\n      value = inspect(value, {\n        breakLength: 0,\n        colors: true,\n        depth: null,\n        maxArrayLength: null\n      });\n    }\n\n    this.log('' + value);\n  }\n\n  list(key, items, hints) {\n    const gutterWidth = (this._lastCategorySize || 2) - 1;\n\n    if (hints) {\n      for (const item of items) {\n        this._log(`${' '.repeat(gutterWidth)}- ${item}`);\n        this._log(`  ${' '.repeat(gutterWidth)} ${hints[item]}`);\n      }\n    } else {\n      for (const item of items) {\n        this._log(`${' '.repeat(gutterWidth)}- ${item}`);\n      }\n    }\n  }\n\n  header(command, pkg) {\n    this.log(this.format.bold(`${pkg.name} ${command} v${pkg.version}`));\n  }\n\n  footer(showPeakMemory) {\n    const totalTime = (this.getTotalTime() / 1000).toFixed(2);\n    let msg = `Done in ${totalTime}s.`;\n    if (showPeakMemory) {\n      const peakMemory = (this.peakMemory / 1024 / 1024).toFixed(2);\n      msg += ` Peak memory usage ${peakMemory}MB.`;\n    }\n    this.log(this._prependEmoji(msg, '✨'));\n  }\n\n  log(msg) {\n    this._lastCategorySize = 0;\n    this._log(msg);\n  }\n\n  _log(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stdout);\n    this.stdout.write(`${msg}\\n`);\n  }\n\n  success(msg) {\n    this._logCategory('success', 'green', msg);\n  }\n\n  error(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stderr);\n    this.stderr.write(`${this.format.red('error')} ${msg}\\n`);\n  }\n\n  info(msg) {\n    this._logCategory('info', 'blue', msg);\n  }\n\n  command(command) {\n    this.log(this.format.dim(`$ ${command}`));\n  }\n\n  warn(msg) {\n    (0, (_util || _load_util()).clearLine)(this.stderr);\n    this.stderr.write(`${this.format.yellow('warning')} ${msg}\\n`);\n  }\n\n  question(question) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!process.stdout.isTTY) {\n      return (_promise || _load_promise()).default.reject(new Error(\"Can't answer a question unless a user TTY\"));\n    }\n\n    return new (_promise || _load_promise()).default((resolve, reject) => {\n      read({\n        prompt: `${this.format.dim('question')} ${question}: `,\n        silent: !!options.password,\n        output: this.stdout,\n        input: this.stdin\n      }, (err, answer) => {\n        if (err) {\n          if (err.message === 'canceled') {\n            process.exit(1);\n          } else {\n            reject(err);\n          }\n        } else {\n          if (!answer && options.required) {\n            this.error(this.lang('answerRequired'));\n            resolve(this.question(question, options));\n          } else {\n            resolve(answer);\n          }\n        }\n      });\n    });\n  }\n  // handles basic tree output to console\n  tree(key, trees) {\n    //\n    const output = (_ref, level, end) => {\n      let name = _ref.name,\n          children = _ref.children,\n          hint = _ref.hint,\n          color = _ref.color;\n\n      const formatter = this.format;\n      const out = (0, (_treeHelper || _load_treeHelper()).getFormattedOutput)({ end: end, level: level, hint: hint, color: color, name: name, formatter: formatter });\n      this.stdout.write(out);\n\n      if (children && children.length) {\n        (0, (_treeHelper || _load_treeHelper()).recurseTree)((0, (_treeHelper || _load_treeHelper()).sortTrees)(children), level, output);\n      }\n    };\n    (0, (_treeHelper || _load_treeHelper()).recurseTree)((0, (_treeHelper || _load_treeHelper()).sortTrees)(trees), -1, output);\n  }\n\n  activitySet(total, workers) {\n    if (!this.isTTY || this.noProgress) {\n      return super.activitySet(total, workers);\n    }\n\n    const spinners = [];\n\n    for (let i = 1; i < workers; i++) {\n      this.log('');\n    }\n\n    for (let i = 0; i < workers; i++) {\n      const spinner = new (_spinnerProgress || _load_spinnerProgress()).default(this.stderr, i);\n      spinner.start();\n\n      let prefix = null;\n      let current = 0;\n      const updatePrefix = () => {\n        spinner.setPrefix(`${this.format.dim(`[${current === 0 ? '-' : current}/${total}]`)} `);\n      };\n      const clear = () => {\n        prefix = null;\n        current = 0;\n        updatePrefix();\n        spinner.setText('waiting...');\n      };\n      clear();\n\n      spinners.unshift({\n        clear: clear,\n\n        setPrefix: function setPrefix(_current, _prefix) {\n          current = _current;\n          prefix = _prefix;\n          spinner.setText(prefix);\n          updatePrefix();\n        },\n        tick: function tick(msg) {\n          if (prefix) {\n            msg = `${prefix}: ${msg}`;\n          }\n          spinner.setText(msg);\n        },\n        end: function end() {\n          spinner.stop();\n        }\n      });\n    }\n\n    return {\n      spinners: spinners,\n      end: () => {\n        for (const spinner of spinners) {\n          spinner.end();\n        }\n        readline.moveCursor(this.stdout, 0, -workers + 1);\n      }\n    };\n  }\n\n  activity() {\n    if (!this.isTTY) {\n      return {\n        tick: function tick() {},\n        end: function end() {}\n      };\n    }\n\n    const spinner = new (_spinnerProgress || _load_spinnerProgress()).default(this.stderr);\n    spinner.start();\n\n    return {\n      tick: function tick(name) {\n        spinner.setText(name);\n      },\n      end: function end() {\n        spinner.stop();\n      }\n    };\n  }\n\n  select(header, question, options) {\n    if (!this.isTTY) {\n      return (_promise || _load_promise()).default.reject(new Error(\"Can't answer a question unless a user TTY\"));\n    }\n\n    const rl = readline.createInterface({\n      input: this.stdin,\n      output: this.stdout,\n      terminal: true\n    });\n\n    const questions = options.map(opt => opt.name);\n    const answers = options.map(opt => opt.value);\n\n    function toIndex(input) {\n      const index = answers.indexOf(input);\n\n      if (index >= 0) {\n        return index;\n      } else {\n        return +input;\n      }\n    }\n\n    return new (_promise || _load_promise()).default(resolve => {\n      this.info(header);\n\n      for (let i = 0; i < questions.length; i++) {\n        this.log(`  ${this.format.dim(`${i + 1})`)} ${questions[i]}`);\n      }\n\n      const ask = () => {\n        rl.question(`${question}: `, input => {\n          let index = toIndex(input);\n\n          if (isNaN(index)) {\n            this.log('Not a number');\n            ask();\n            return;\n          }\n\n          if (index <= 0 || index > options.length) {\n            this.log('Outside answer range');\n            ask();\n            return;\n          }\n\n          // get index\n          index--;\n          rl.close();\n          resolve(answers[index]);\n        });\n      };\n\n      ask();\n    });\n  }\n\n  progress(count) {\n    if (this.noProgress || count <= 0) {\n      return function () {\n        // noop\n      };\n    }\n\n    if (!this.isTTY) {\n      return function () {\n        // TODO what should the behaviour here be? we could buffer progress messages maybe\n      };\n    }\n\n    const bar = new (_progressBar || _load_progressBar()).default(count, this.stderr);\n\n    bar.render();\n\n    return function () {\n      bar.tick();\n    };\n  }\n}\nexports.default = ConsoleReporter;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/console/progress-bar.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nclass ProgressBar {\n  constructor(total) {\n    let stdout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.stderr;\n\n    this.stdout = stdout;\n    this.total = total;\n    this.chars = ProgressBar.bars[0];\n    this.delay = 60;\n    this.curr = 0;\n    (0, (_util || _load_util()).clearLine)(stdout);\n  }\n\n  tick() {\n    this.curr++;\n\n    // schedule render\n    if (!this.id) {\n      this.id = setTimeout(() => this.render(), this.delay);\n    }\n\n    // progress complete\n    if (this.curr >= this.total) {\n      clearTimeout(this.id);\n      (0, (_util || _load_util()).clearLine)(this.stdout);\n    }\n  }\n\n  render() {\n    // clear throttle\n    clearTimeout(this.id);\n    this.id = null;\n\n    let ratio = this.curr / this.total;\n    ratio = Math.min(Math.max(ratio, 0), 1);\n\n    // progress without bar\n    let bar = ` ${this.curr}/${this.total}`;\n\n    // calculate size of actual bar\n    // $FlowFixMe: investigate process.stderr.columns flow error\n    const availableSpace = Math.max(0, this.stdout.columns - bar.length - 1);\n    const width = Math.min(this.total, availableSpace);\n    const completeLength = Math.round(width * ratio);\n    const complete = this.chars[0].repeat(completeLength);\n    const incomplete = this.chars[1].repeat(width - completeLength);\n    bar = `${complete}${incomplete}${bar}`;\n\n    (0, (_util || _load_util()).toStartOfLine)(this.stdout);\n    this.stdout.write(bar);\n  }\n}\nexports.default = ProgressBar;\nProgressBar.bars = [['█', '░']];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/console/spinner-progress.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nclass Spinner {\n  constructor() {\n    let stdout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.stderr;\n    let lineNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this.current = 0;\n    this.prefix = '';\n    this.lineNumber = lineNumber;\n    this.stdout = stdout;\n    this.delay = 60;\n    this.chars = Spinner.spinners[28].split('');\n    this.text = '';\n    this.id = null;\n  }\n\n  setPrefix(prefix) {\n    this.prefix = prefix;\n  }\n\n  setText(text) {\n    this.text = text;\n  }\n\n  start() {\n    this.current = 0;\n    this.render();\n  }\n\n  render() {\n    if (this.id) {\n      clearTimeout(this.id);\n    }\n\n    // build line ensuring we don't wrap to the next line\n    let msg = `${this.prefix}${this.chars[this.current]} ${this.text}`;\n    const columns = typeof this.stdout.columns === 'number' ? this.stdout.columns : 100;\n    msg = msg.slice(0, columns);\n\n    (0, (_util || _load_util()).writeOnNthLine)(this.stdout, this.lineNumber, msg);\n\n    this.current = ++this.current % this.chars.length;\n    this.id = setTimeout(() => this.render(), this.delay);\n  }\n\n  stop() {\n    if (this.id) {\n      clearTimeout(this.id);\n      this.id = null;\n    }\n\n    (0, (_util || _load_util()).clearNthLine)(this.stdout, this.lineNumber);\n  }\n}\nexports.default = Spinner;\nSpinner.spinners = ['|/-\\\\', '⠂-–—–-', '◐◓◑◒', '◴◷◶◵', '◰◳◲◱', '▖▘▝▗', '■□▪▫', '▌▀▐▄', '▉▊▋▌▍▎▏▎▍▌▋▊▉', '▁▃▄▅▆▇█▇▆▅▄▃', '←↖↑↗→↘↓↙', '┤┘┴└├┌┬┐', '◢◣◤◥', '.oO°Oo.', '.oO@*', '🌍🌎🌏', '◡◡ ⊙⊙ ◠◠', '☱☲☴', '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏', '⠋⠙⠚⠞⠖⠦⠴⠲⠳⠓', '⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆', '⠋⠙⠚⠒⠂⠂⠒⠲⠴⠦⠖⠒⠐⠐⠒⠓⠋', '⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠴⠲⠒⠂⠂⠒⠚⠙⠉⠁', '⠈⠉⠋⠓⠒⠐⠐⠒⠖⠦⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈', '⠁⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈⠈', '⢄⢂⢁⡁⡈⡐⡠', '⢹⢺⢼⣸⣇⡧⡗⡏', '⣾⣽⣻⢿⡿⣟⣯⣷', '⠁⠂⠄⡀⢀⠠⠐⠈'];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/console/util.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearLine = clearLine;\nexports.toStartOfLine = toStartOfLine;\nexports.writeOnNthLine = writeOnNthLine;\nexports.clearNthLine = clearNthLine;\n\n\nconst readline = require('readline');\n\nvar _require = require('chalk');\n\nconst supportsColor = _require.supportsColor;\n\n\nconst CLEAR_WHOLE_LINE = 0;\nconst CLEAR_RIGHT_OF_CURSOR = 1;\n\nfunction clearLine(stdout) {\n  if (!supportsColor) {\n    return;\n  }\n\n  readline.clearLine(stdout, CLEAR_WHOLE_LINE);\n  readline.cursorTo(stdout, 0);\n}\n\nfunction toStartOfLine(stdout) {\n  if (!supportsColor) {\n    return;\n  }\n\n  readline.cursorTo(stdout, 0);\n}\n\nfunction writeOnNthLine(stdout, n, msg) {\n  if (!supportsColor) {\n    return;\n  }\n\n  if (n == 0) {\n    readline.cursorTo(stdout, 0);\n    stdout.write(msg);\n    readline.clearLine(stdout, CLEAR_RIGHT_OF_CURSOR);\n    return;\n  }\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, -n);\n  stdout.write(msg);\n  readline.clearLine(stdout, CLEAR_RIGHT_OF_CURSOR);\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, n);\n}\n\nfunction clearNthLine(stdout, n) {\n  if (!supportsColor) {\n    return;\n  }\n\n  if (n == 0) {\n    clearLine(stdout);\n    return;\n  }\n  readline.cursorTo(stdout, 0);\n  readline.moveCursor(stdout, 0, -n);\n  readline.clearLine(stdout, CLEAR_WHOLE_LINE);\n  readline.moveCursor(stdout, 0, n);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/reporters/lang/en.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/* eslint max-len: 0 */\n\nconst messages = {\n  upToDate: 'Already up-to-date.',\n  folderInSync: 'Folder in sync.',\n  nothingToInstall: 'Nothing to install.',\n  resolvingPackages: 'Resolving packages',\n  fetchingPackages: 'Fetching packages',\n  linkingDependencies: 'Linking dependencies',\n  rebuildingPackages: 'Rebuilding all packages',\n  buildingFreshPackages: 'Building fresh packages',\n  cleaningModules: 'Cleaning modules',\n  bumpingVersion: 'Bumping version',\n  savingHar: 'Saving HAR file: $0',\n  answer: 'Answer?',\n  usage: 'Usage',\n  installCommandRenamed: '`install` has been replaced with `add` to add new dependencies. Run $0 instead.',\n  waitingInstance: 'Waiting for the other yarn instance to finish',\n  offlineRetrying: 'There appears to be trouble with your network connection. Retrying...',\n  clearedCache: 'Cleared cache.',\n  packWroteTarball: 'Wrote tarball to $0.',\n\n  manifestPotentialTypo: 'Potential typo $0, did you mean $1?',\n  manifestBuiltinModule: '$0 is also the name of a node core module',\n  manifestNameDot: \"Name can't start with a dot\",\n  manifestNameIllegalChars: 'Name contains illegal characters',\n  manifestNameBlacklisted: 'Name is blacklisted',\n  manifestLicenseInvalid: 'License should be a valid SPDX license expression',\n  manifestLicenseNone: 'No license field',\n  manifestStringExpected: '$0 is not a string',\n  manifestDependencyCollision: '$0 has dependency $1 with range $2 that collides with a dependency in $3 of the same name with version $4',\n  manifestDirectoryNotFound: 'Unable to read $0 directory of module $1',\n\n  verboseFileCopy: 'Copying $0 to $1.',\n  verboseFileLink: 'Creating hardlink at $0 to $1.',\n  verboseFileSymlink: 'Creating symlink at $0 to $1.',\n  verboseFileSkip: 'Skipping copying of file $0 as the file at $1 is the same size ($2) and mtime ($3).',\n  verboseFileSkipSymlink: 'Skipping copying of $0 as the file at $1 is the same symlink ($2).',\n  verboseFileSkipHardlink: 'Skipping copying of $0 as the file at $1 is the same hardlink ($2).',\n  verboseFileRemoveExtraneous: 'Removing extraneous file $0.',\n  verboseFilePhantomExtraneous: \"File $0 would be marked as extraneous but has been removed as it's listed as a phantom file.\",\n  verboseFileFolder: 'Creating directory $0.',\n\n  verboseRequestStart: 'Performing $0 request to $1.',\n  verboseRequestFinish: 'Request $0 finished with status code $1.',\n\n  configSet: 'Set $0 to $1.',\n  configDelete: 'Deleted $0.',\n  configNpm: 'npm config',\n  configYarn: 'yarn config',\n\n  couldntFindPackagejson: \"Couldn't find a package.json file in $0\",\n  couldntFindMatch: \"Couldn't find match for $0 in $1 for $2.\",\n  couldntFindPackageInCache: \"Couldn't find any versions for $0 that matches $1 in our cache. Possible versions: $2\",\n  couldntFindVersionThatMatchesRange: \"Couldn't find any versions for $0 that matches $1\",\n  chooseVersionFromList: 'Please choose a version from this list:',\n  moduleNotInManifest: \"This module isn't specified in a manifest.\",\n  unknownFolderOrTarball: \"Passed folder/tarball doesn't exist,\",\n  unknownPackage: \"Couldn't find package $0.\",\n  unknownPackageName: \"Couldn't find package name.\",\n  unknownUser: \"Couldn't find user $0.\",\n  unknownRegistryResolver: 'Unknown registry resolver $0',\n  userNotAnOwner: \"User $0 isn't an owner of this package.\",\n  invalidVersionArgument: 'Use the $0 flag to create a new version.',\n  invalidVersion: 'Invalid version supplied.',\n  requiredVersionInRange: 'Required version in range.',\n  packageNotFoundRegistry: \"Couldn't find package $0 on the $1 registry.\",\n  doesntExist: \"$0 doesn't exist.\",\n  missingRequiredPackageKey: `Package $0 doesn't have a $1.`,\n  invalidAccess: 'Invalid argument for access, expected public or restricted.',\n  invalidCommand: 'Invalid subcommand. Try $0',\n  invalidGistFragment: 'Invalid gist fragment $0.',\n  invalidHostedGitFragment: 'Invalid hosted git fragment $0.',\n  invalidFragment: 'Invalid fragment $0.',\n  invalidPackageName: 'Invalid package name.',\n  couldntFindManifestIn: \"Couldn't find manifest in $0.\",\n  shrinkwrapWarning: 'npm-shrinkwrap.json found. This will not be updated or respected. See https://yarnpkg.com/en/docs/migrating-from-npm for more information.',\n  lockfileOutdated: 'Outdated lockfile. Please run `yarn install` and try again.',\n  ignoredScripts: 'Ignored scripts due to flag.',\n  missingAddDependencies: 'Missing list of packages to add to your project.',\n  yesWarning: 'The yes flag has been set. This will automatically answer yes to all questions which may have security implications.',\n  networkWarning: \"You don't appear to have an internet connection. Try the --offline flag to use the cache for registry queries.\",\n  flatGlobalError: 'The package $0@$1 requires a flat dependency graph. Add `\"flat\": true` to your package.json and try again.',\n  noName: `Package doesn't have a name.`,\n  noVersion: `Package doesn't have a version.`,\n  answerRequired: 'An answer is required.',\n  missingWhyDependency: 'Missing package name, folder or path to file to identify why a package has been installed',\n  bugReport: 'If you think this is a bug, please open a bug report with the information provided in $0.',\n  unexpectedError: 'An unexpected error occurred: $0.',\n  jsonError: 'Error parsing JSON at $0, $1.',\n  noFilePermission: \"We don't have permissions to touch the file $0.\",\n  allDependenciesUpToDate: 'All of your dependencies are up to date.',\n  frozenLockfileError: 'Your lockfile needs to be updated, but yarn was run with `--frozen-lockfile`.',\n  fileWriteError: 'Could not write file $0: $1',\n\n  yarnOutdated: \"Your current version of Yarn is out of date. The latest version is $0 while you're on $1.\",\n  yarnOutdatedInstaller: 'To upgrade, download the latest installer at $0.',\n  yarnOutdatedCommand: 'To upgrade, run the following command:',\n\n  tooManyArguments: 'Too many arguments, maximum of $0.',\n  tooFewArguments: 'Not enough arguments, expected at least $0.',\n  noArguments: \"This command doesn't require any arguments.\",\n\n  ownerRemoving: 'Removing owner $0 from package $1.',\n  ownerRemoved: 'Owner removed.',\n  ownerRemoveError: \"Couldn't remove owner.\",\n  ownerGetting: 'Getting owners for package $0',\n  ownerGettingFailed: \"Couldn't get list of owners.\",\n  ownerAlready: 'This user is already an owner of this package.',\n  ownerAdded: 'Added owner.',\n  ownerAdding: 'Adding owner $0 to package $1',\n  ownerAddingFailed: \"Couldn't add owner.\",\n  ownerNone: 'No owners.',\n\n  teamCreating: 'Creating team',\n  teamRemoving: 'Removing team',\n  teamAddingUser: 'Adding user to team',\n  teamRemovingUser: 'Removing user from team',\n  teamListing: 'Listing teams',\n\n  cleaning: 'Cleaning modules',\n  cleanCreatingFile: 'Creating $0',\n\n  binLinkCollision: \"There's already a linked binary called $0 in your global Yarn bin. Could not link this package's $0 bin entry.\",\n  linkCollision: \"There's already a module called $0 registered.\",\n  linkMissing: 'No registered module found called $0.',\n  linkInstallMessage: 'You can now run `yarn link $0` in the projects where you want to use this module and it will be used instead.',\n  linkRegistered: 'Registered $0.',\n  linkUnregistered: 'Unregistered $0.',\n  linkUsing: 'Using linked module for $0.',\n\n  commandNotSpecified: 'No command specified.',\n  binCommands: 'Commands available from binary scripts: ',\n  possibleCommands: 'Project commands',\n  commandQuestion: 'Which command would you like to run?',\n  commandFailed: 'Command failed with exit code $0.',\n\n  foundIncompatible: 'Found incompatible module',\n  incompatibleEngine: 'The engine $0 is incompatible with this module. Expected version $1.',\n  incompatibleCPU: 'The CPU architecture $0 is incompatible with this module.',\n  incompatibleOS: 'The platform $0 is incompatible with this module.',\n  invalidEngine: 'The engine $0 appears to be invalid.',\n\n  selfUpdateReleased: 'Replaced current release with $0.',\n  selfUpdateDownloading: 'Downloading yarn version $0.',\n  selfUpdateNoNewer: 'Yarn is already using the latest version.',\n\n  optionalCompatibilityExcluded: '$0 is an optional dependency and failed compatibility check. Excluding it from installation.',\n  optionalModuleFail: 'This module is OPTIONAL, you can safely ignore this error',\n  optionalModuleScriptFail: 'Error running install script for optional dependency: $0',\n  optionalModuleCleanupFail: 'Could not cleanup build artifacts from failed install: $0',\n\n  unmetPeer: '$0 has unmet peer dependency $1.',\n  incorrectPeer: '$0 has incorrect peer dependency $1.',\n\n  savedNewDependency: 'Saved 1 new dependency.',\n  savedNewDependencies: 'Saved $0 new dependencies.',\n\n  foundWarnings: 'Found $0 warnings.',\n  foundErrors: 'Found $0 errors.',\n\n  savedLockfile: 'Saved lockfile.',\n  noRequiredLockfile: 'No lockfile in this directory. Run `yarn install` to generate one.',\n  noLockfileFound: 'No lockfile found.',\n\n  invalidSemver: 'Invalid semver version',\n  newVersion: 'New version',\n  currentVersion: 'Current version',\n\n  manualVersionResolution: 'Unable to find a suitable version for $0, please choose one by typing one of the numbers below:',\n  manualVersionResolutionOption: '$0 which resolved to $1',\n\n  createdTag: 'Created tag.',\n  createdTagFail: \"Couldn't add tag.\",\n  deletedTag: 'Deleted tag.',\n  deletedTagFail: \"Couldn't delete tag.\",\n  gettingTags: 'Getting tags',\n  deletingTags: 'Deleting tag',\n  creatingTag: 'Creating tag $0 = $1',\n\n  whyStart: 'Why do we have the module $0?',\n  whyFinding: 'Finding dependency',\n  whyCalculating: 'Calculating file sizes',\n  whyUnknownMatch: \"We couldn't find a match!\",\n  whyInitGraph: 'Initialising dependency graph',\n  whyWhoKnows: \"We don't know why this module exists\",\n  whyDiskSizeWithout: 'Disk size without dependencies: $0',\n  whyDiskSizeUnique: 'Disk size with unique dependencies: $0',\n  whyDiskSizeTransitive: 'Disk size with transitive dependencies: $0',\n  whySharedDependencies: 'Amount of shared dependencies: $0',\n  whyHoistedTo: `Has been hoisted to $0`,\n\n  whyHoistedFromSimple: `This module exists because it's hoisted from $0.`,\n  whyDependedOnSimple: `This module exists because $0 depends on it.`,\n  whySpecifiedSimple: `This module exists because it's specified in $0.`,\n  whyReasons: 'Reasons this module exists',\n  whyHoistedFrom: 'Hoisted from $0',\n  whyDependedOn: '$0 depends on it',\n  whySpecified: `Specified in $0`,\n\n  uninstalledPackages: 'Uninstalled packages.',\n  uninstallRegenerate: 'Regenerating lockfile and installing missing dependencies',\n\n  cleanRemovedFiles: 'Removed $0 files',\n  cleanSavedSize: 'Saved $0 MB.',\n\n  npmUsername: 'npm username',\n  npmPassword: 'npm password',\n  npmEmail: 'npm email',\n\n  loggingIn: 'Logging in',\n  loggedIn: 'Logged in.',\n  notRevokingEnvToken: 'Not revoking login token, specified via environment variable.',\n  notRevokingConfigToken: 'Not revoking login token, specified via config file.',\n  noTokenToRevoke: 'No login token to revoke.',\n  revokingToken: 'Revoking token',\n  revokedToken: 'Revoked login token.',\n\n  loginAsPublic: 'Logging in as public',\n  incorrectCredentials: 'Incorrect username or password.',\n  clearedCredentials: 'Cleared login credentials.',\n\n  publishSame: 'New version is the same as the current version.',\n  publishFail: \"Couldn't publish package.\",\n  publishPrivate: 'Package marked as private, not publishing.',\n  published: 'Published.',\n  publishing: 'Publishing',\n\n  infoFail: 'Received invalid response from npm.',\n  malformedRegistryResponse: 'Received malformed response from registry for $0. The registry may be down.',\n\n  cantRequestOffline: 'Can\\'t make a request in offline mode',\n  requestManagerNotSetupHAR: 'RequestManager was not setup to capture HAR files',\n  requestError: 'Request $0 returned a $1',\n  requestFailed: 'Request failed $0',\n  tarballNotInNetworkOrCache: '$0: Tarball is not in network and can not be located in cache ($1)',\n  fetchBadHash: 'Bad hash. Expected $0 but got $1 ',\n  fetchErrorCorrupt: '$0. Mirror tarball appears to be corrupt. You can resolve this by running:\\n\\n  rm -rf $1\\n  yarn install',\n  errorDecompressingTarball: '$0. Error decompressing $1, it appears to be corrupt.',\n  updateInstalling: 'Installing $0...',\n  hostedGitResolveError: 'Error connecting to repository. Please, check the url.',\n\n  unknownFetcherFor: 'Unknown fetcher for $0',\n\n  refusingDownloadGitWithoutCommit: 'Refusing to download the git repo $0 over plain git without a commit hash',\n  refusingDownloadHTTPWithoutCommit: 'Refusing to download the git repo $0 over HTTP without a commit hash',\n  refusingDownloadHTTPSWithoutCommit: 'Refusing to download the git repo $0 over HTTPS without a commit hash - possible certificate error?',\n\n  packageInstalledWithBinaries: 'Installed $0 with binaries:',\n  packageHasBinaries: '$0 has binaries:',\n  packageHasNoBinaries: '$0 has no binaries',\n\n  couldBeDeduped: '$0 could be deduped from $1 to $2',\n  lockfileNotContainPatter: 'Lockfile does not contain pattern: $0',\n  integrityHashesDontMatch: 'Integrity hashes don\\'t match, expected $0 but got $1',\n  noIntegirtyHashFile: 'Couldn\\'t find an integrity hash file',\n  packageNotInstalled: '$0 not installed',\n  optionalDepNotInstalled: 'Optional dependency $0 not installed',\n  packageWrongVersion: '$0 is wrong version: expected $1, got $2',\n  packageDontSatisfy: '$0 doesn\\'t satisfy found match of $1',\n\n  lockfileExists: 'Lockfile already exists, not importing.',\n  skippingImport: 'Skipping import of $0 for $1',\n  importFailed: 'Import of $0 for $1 failed, resolving normally.',\n  importResolveFailed: 'Import of $0 failed starting in $1',\n  importResolvedRangeMatch: 'Using version $0 of $1 instead of $2 for $3'\n};\n\nexports.default = messages;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/bitbucket-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass BitbucketResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static getTarballUrl(parts, hash) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/get/${hash}.tar.gz`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/raw/${commit}/${filename}`;\n  }\n}\nexports.default = BitbucketResolver;\nBitbucketResolver.hostname = 'bitbucket.org';\nBitbucketResolver.protocol = 'bitbucket';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/hosted-git-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.explodeHostedGitFragment = explodeHostedGitFragment;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _git;\n\nfunction _load_git() {\n  return _git = _interopRequireDefault(require('../../util/git.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction explodeHostedGitFragment(fragment, reporter) {\n\n  const preParts = fragment.split('@');\n  if (preParts.length > 2) {\n    fragment = preParts[1] + '@' + preParts[2];\n  }\n\n  const parts = fragment.split(':');\n\n  if (parts.length == 3) {\n    // protocol + host + folder\n    parts[1] = parts[1].indexOf('//') >= 0 ? parts[1].substr(2) : parts[1];\n    fragment = parts[1] + '/' + parts[2];\n  } else if (parts.length == 2) {\n    if (parts[0].indexOf('@') == -1) {\n      // protocol + host\n      fragment = parts[1];\n    } else {\n      // host + folder\n      fragment = parts[0] + '/' + parts[1];\n    }\n  } else if (parts.length == 1) {\n    fragment = parts[0];\n  } else {\n    throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidHostedGitFragment', fragment));\n  }\n\n  const userParts = fragment.split('/');\n\n  if (userParts.length >= 2) {\n\n    if (userParts[0].indexOf('@') >= 0) {\n      userParts.shift();\n    }\n\n    const user = userParts.shift();\n    const repoParts = userParts.join('/').split(/(?:[.]git)?#(.*)/);\n\n    if (repoParts.length <= 3) {\n      return {\n        user: user,\n        repo: repoParts[0].replace('.git', ''),\n        hash: repoParts[1] || ''\n      };\n    }\n  }\n\n  throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidHostedGitFragment', fragment));\n}\n\nclass HostedGitResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    const exploded = this.exploded = explodeHostedGitFragment(fragment, this.reporter);\n    const user = exploded.user,\n          repo = exploded.repo,\n          hash = exploded.hash;\n\n    this.user = user;\n    this.repo = repo;\n    this.hash = hash;\n  }\n\n  static getTarballUrl(exploded, commit) {\n    exploded;\n    commit;\n    throw new Error('Not implemented');\n  }\n\n  static getGitHTTPUrl(exploded) {\n    exploded;\n    throw new Error('Not implemented');\n  }\n\n  static getGitSSHUrl(exploded) {\n    exploded;\n    throw new Error('Not implemented');\n  }\n\n  static getHTTPFileUrl(exploded, filename, commit) {\n    exploded;\n    filename;\n    commit;\n    throw new Error('Not implemented');\n  }\n\n  getRefOverHTTP(url) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const client = new (_git || _load_git()).default(_this.config, url, _this.hash);\n\n      let out = yield _this.config.requestManager.request({\n        url: `${url}/info/refs?service=git-upload-pack`,\n        queue: _this.resolver.fetchingQueue\n      });\n\n      if (out) {\n        // clean up output\n        let lines = out.trim().split('\\n');\n\n        // remove first two lines which contains compatibility info etc\n        lines = lines.slice(2);\n\n        // remove last line which contains the terminator \"0000\"\n        lines.pop();\n\n        // remove line lengths from start of each line\n        lines = lines.map(function (line) {\n          return line.slice(4);\n        });\n\n        out = lines.join('\\n');\n      } else {\n        throw new Error(_this.reporter.lang('hostedGitResolveError'));\n      }\n\n      const refs = (_git || _load_git()).default.parseRefs(out);\n      return yield client.setRef(refs);\n    })();\n  }\n\n  resolveOverHTTP(url) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const shrunk = _this2.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const commit = yield _this2.getRefOverHTTP(url);\n      const config = _this2.config;\n\n\n      const tryRegistry = (() => {\n        var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (registry) {\n          const filename = (_index || _load_index()).registries[registry].filename;\n\n          const href = _this2.constructor.getHTTPFileUrl(_this2.exploded, filename, commit);\n          const file = yield config.requestManager.request({\n            url: href,\n            queue: _this2.resolver.fetchingQueue\n          });\n          if (!file) {\n            return null;\n          }\n\n          const tarballUrl = _this2.constructor.getTarballUrl(_this2.exploded, commit);\n          const json = yield config.readJson(href, function () {\n            return JSON.parse(file);\n          });\n          json._uid = commit;\n          json._remote = {\n            resolved: tarballUrl,\n            type: 'tarball',\n            reference: tarballUrl,\n            registry: registry\n          };\n          return json;\n        });\n\n        return function tryRegistry(_x) {\n          return _ref.apply(this, arguments);\n        };\n      })();\n\n      const file = yield tryRegistry(_this2.registry);\n      if (file) {\n        return file;\n      }\n\n      for (const registry in (_index || _load_index()).registries) {\n        if (registry === _this2.registry) {\n          continue;\n        }\n\n        const file = yield tryRegistry(registry);\n        if (file) {\n          return file;\n        }\n      }\n\n      throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('couldntFindManifestIn', url));\n    })();\n  }\n\n  hasHTTPCapability(url) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      return (yield _this3.config.requestManager.request({\n        url: url,\n        method: 'HEAD',\n        queue: _this3.resolver.fetchingQueue,\n        followRedirect: false\n      })) !== false;\n    })();\n  }\n\n  resolve() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const httpUrl = _this4.constructor.getGitHTTPUrl(_this4.exploded);\n      const sshUrl = _this4.constructor.getGitSSHUrl(_this4.exploded);\n\n      // If we can access the files over HTTP then we should as it's MUCH faster than git\n      // archive and tarball unarchiving. The HTTP API is only available for public repos\n      // though.\n      if (yield _this4.hasHTTPCapability(httpUrl)) {\n        return yield _this4.resolveOverHTTP(httpUrl);\n      }\n\n      // If the url is accessible over git archive then we should immediately delegate to\n      // the git resolver.\n      //\n      // NOTE: Here we use a different url than when we delegate to the git resolver later on.\n      // This is because `git archive` requires access over ssh and github only allows that\n      // if you have write permissions\n      if (yield (_git || _load_git()).default.hasArchiveCapability(sshUrl)) {\n        const archiveClient = new (_git || _load_git()).default(_this4.config, sshUrl, _this4.hash);\n        const commit = yield archiveClient.init();\n        return yield _this4.fork((_gitResolver || _load_gitResolver()).default, true, `${sshUrl}#${commit}`);\n      }\n\n      // fallback to the plain git resolver\n      return yield _this4.fork((_gitResolver || _load_gitResolver()).default, true, sshUrl);\n    })();\n  }\n}\nexports.default = HostedGitResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/exotic-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _baseResolver;\n\nfunction _load_baseResolver() {\n  return _baseResolver = _interopRequireDefault(require('../base-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ExoticResolver extends (_baseResolver || _load_baseResolver()).default {\n\n  static isVersion(pattern) {\n    const proto = this.protocol;\n    if (proto) {\n      return pattern.startsWith(`${proto}:`);\n    } else {\n      throw new Error('No protocol specified');\n    }\n  }\n}\nexports.default = ExoticResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/file-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nclass FileResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n    this.loc = (_misc || _load_misc()).removePrefix(fragment, 'file:');\n  }\n\n  resolve() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let loc = _this.loc;\n      if (!path.isAbsolute(loc)) {\n        loc = path.join(_this.config.cwd, loc);\n      }\n      if (!(yield (_fs || _load_fs()).exists(loc))) {\n        throw new (_errors || _load_errors()).MessageError(_this.reporter.lang('doesntExist', loc));\n      }\n\n      const manifest = yield _this.config.readManifest(loc, _this.registry);\n      const registry = manifest._registry;\n      invariant(registry, 'expected registry');\n\n      manifest._remote = {\n        type: 'copy',\n        registry: registry,\n        hash: null,\n        reference: loc\n      };\n\n      manifest._uid = manifest.version;\n\n      // Normalize relative paths; if anything changes, make a copy of the manifest\n      const dependencies = _this.normalizeDependencyPaths(manifest.dependencies, loc);\n      const optionalDependencies = _this.normalizeDependencyPaths(manifest.optionalDependencies, loc);\n\n      if (dependencies !== manifest.dependencies || optionalDependencies !== manifest.optionalDependencies) {\n        const _manifest = (0, (_assign || _load_assign()).default)({}, manifest);\n        if (dependencies != null) {\n          _manifest.dependencies = dependencies;\n        }\n        if (optionalDependencies != null) {\n          _manifest.optionalDependencies = optionalDependencies;\n        }\n        return _manifest;\n      } else {\n        return manifest;\n      }\n    })();\n  }\n\n  normalizeDependencyPaths(section, loc) {\n    if (section == null) {\n      return section;\n    }\n\n    let temp = section;\n\n    for (const _ref of (_misc || _load_misc()).entries(section)) {\n      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n      const k = _ref2[0];\n      const v = _ref2[1];\n\n      if (typeof v === 'string' && v.startsWith('file:') && !path.isAbsolute(v)) {\n        if (temp === section) {\n          temp = (0, (_assign || _load_assign()).default)({}, section);\n        }\n        temp[k] = `file:${path.relative(this.config.cwd, path.join(loc, (_misc || _load_misc()).removePrefix(v, 'file:')))}`;\n      }\n    }\n\n    return temp;\n  }\n}\nexports.default = FileResolver;\nFileResolver.protocol = 'file';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/gist-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explodeGistFragment = explodeGistFragment;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction explodeGistFragment(fragment, reporter) {\n  fragment = (_misc || _load_misc()).removePrefix(fragment, 'gist:');\n\n  const parts = fragment.split('#');\n\n  if (parts.length <= 2) {\n    return {\n      id: parts[0],\n      hash: parts[1] || ''\n    };\n  } else {\n    throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidGistFragment', fragment));\n  }\n}\n\nclass GistResolver extends (_exoticResolver || _load_exoticResolver()).default {\n\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    var _explodeGistFragment = explodeGistFragment(fragment, this.reporter);\n\n    const id = _explodeGistFragment.id,\n          hash = _explodeGistFragment.hash;\n\n    this.id = id;\n    this.hash = hash;\n  }\n\n  resolve() {\n    return this.fork((_gitResolver || _load_gitResolver()).default, false, `https://gist.github.com/${this.id}.git#${this.hash}`);\n  }\n}\nexports.default = GistResolver;\nGistResolver.protocol = 'gist';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/github-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass GitHubResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static isVersion(pattern) {\n    // github proto\n    if (pattern.startsWith('github:')) {\n      return true;\n    }\n\n    // github shorthand\n    if (/^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(pattern)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  static getTarballUrl(parts, hash) {\n    return `https://codeload.${this.hostname}/${parts.user}/${parts.repo}/tar.gz/${hash}`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://raw.githubusercontent.com/${parts.user}/${parts.repo}/${commit}/${filename}`;\n  }\n}\nexports.default = GitHubResolver;\nGitHubResolver.protocol = 'github';\nGitHubResolver.hostname = 'github.com';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/gitlab-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass GitLabResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static getTarballUrl(parts, hash) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/repository/archive.tar.gz?ref=${hash}`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/raw/${commit}/${filename}`;\n  }\n}\nexports.default = GitLabResolver;\nGitLabResolver.hostname = 'gitlab.com';\nGitLabResolver.protocol = 'gitlab';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/registry-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass RegistryResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    const match = fragment.match(/^(\\S+):(.*?)(@(.*?)|)$/);\n    if (match) {\n      this.range = match[4] || 'latest';\n      this.name = match[2];\n    } else {\n      throw new (_errors || _load_errors()).MessageError(this.reporter.lang('invalidFragment', fragment));\n    }\n\n    // $FlowFixMe\n    this.registry = this.constructor.protocol;\n  }\n\n  resolve() {\n    return this.fork(this.constructor.factory, false, this.name, this.range);\n  }\n}\nexports.default = RegistryResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/exotics/tarball-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _tarballFetcher;\n\nfunction _load_tarballFetcher() {\n  return _tarballFetcher = _interopRequireDefault(require('../../fetchers/tarball-fetcher.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('../../util/version.js'));\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('../../util/crypto.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nclass TarballResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    var _versionUtil$explodeH = (_version || _load_version()).explodeHashedUrl(fragment);\n\n    const hash = _versionUtil$explodeH.hash,\n          url = _versionUtil$explodeH.url;\n\n    this.hash = hash;\n    this.url = url;\n  }\n\n  static isVersion(pattern) {\n    // we can sometimes match git urls which we don't want\n    if ((_gitResolver || _load_gitResolver()).default.isVersion(pattern)) {\n      return false;\n    }\n\n    // full http url\n    if (pattern.startsWith('http://') || pattern.startsWith('https://')) {\n      return true;\n    }\n\n    // local file reference - ignore patterns with names\n    if (pattern.indexOf('@') < 0) {\n      if (pattern.endsWith('.tgz') || pattern.endsWith('.tar.gz')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolve() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const shrunk = _this.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const url = (0, (_misc || _load_misc()).removePrefix)(_this.url, 'file:');\n      let hash = _this.hash,\n          registry = _this.registry;\n\n      let pkgJson;\n\n      // generate temp directory\n      const dest = _this.config.getTemp((_crypto || _load_crypto()).hash(url));\n\n      if (yield _this.config.isValidModuleDest(dest)) {\n        var _ref = yield _this.config.readPackageMetadata(dest);\n        // load from local cache\n\n\n        pkgJson = _ref.package;\n        hash = _ref.hash;\n        registry = _ref.registry;\n      } else {\n        // delete if invalid\n        yield (_fs || _load_fs()).unlink(dest);\n\n        const fetcher = new (_tarballFetcher || _load_tarballFetcher()).default(dest, {\n          type: 'tarball',\n          reference: url,\n          registry: registry,\n          hash: hash\n        }, _this.config, false);\n\n        // fetch file and get it's hash\n        const fetched = yield fetcher.fetch();\n        pkgJson = fetched.package;\n        hash = fetched.hash;\n\n        registry = pkgJson._registry;\n        invariant(registry, 'expected registry');\n      }\n\n      // use the commit/tarball hash as the uid as we can't rely on the version as it's not\n      // in the registry\n      pkgJson._uid = hash;\n\n      // set remote so it can be \"fetched\"\n      pkgJson._remote = {\n        type: 'copy',\n        resolved: `${url}#${hash}`,\n        hash: hash,\n        registry: registry,\n        reference: dest\n      };\n\n      return pkgJson;\n    })();\n  }\n}\nexports.default = TarballResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/registries/npm-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign;\n\nfunction _load_assign() {\n  return _assign = _interopRequireDefault(require('babel-runtime/core-js/object/assign'));\n}\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _registryResolver;\n\nfunction _load_registryResolver() {\n  return _registryResolver = _interopRequireDefault(require('./registry-resolver.js'));\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../../util/map.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst inquirer = require('inquirer');\n\nconst tty = require('tty');\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst NPM_REGISTRY = /http[s]:\\/\\/registry.npmjs.org/g;\n\nclass NpmResolver extends (_registryResolver || _load_registryResolver()).default {\n\n  static findVersionInRegistryResponse(config, range, body, request) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (!body['dist-tags']) {\n        throw new (_errors || _load_errors()).MessageError(config.reporter.lang('malformedRegistryResponse', body.name));\n      }\n\n      if (range in body['dist-tags']) {\n        range = body['dist-tags'][range];\n      }\n\n      const satisfied = yield config.resolveConstraints((0, (_keys || _load_keys()).default)(body.versions), range);\n      if (satisfied) {\n        return body.versions[satisfied];\n      } else if (request && !config.nonInteractive) {\n        if (request.resolver && request.resolver.activity) {\n          request.resolver.activity.end();\n        }\n        config.reporter.log(config.reporter.lang('couldntFindVersionThatMatchesRange', body.name, range));\n        let pageSize;\n        if (process.stdout instanceof tty.WriteStream) {\n          pageSize = process.stdout.rows - 2;\n        }\n        const response = yield inquirer.prompt([{\n          name: 'package',\n          type: 'list',\n          message: config.reporter.lang('chooseVersionFromList'),\n          choices: (0, (_keys || _load_keys()).default)(body.versions).reverse(),\n          pageSize: pageSize\n        }]);\n        if (response && response.package) {\n          return body.versions[response.package];\n        }\n      }\n      throw new (_errors || _load_errors()).MessageError(config.reporter.lang('couldntFindVersionThatMatchesRange', body.name, range));\n    })();\n  }\n\n  resolveRequest() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (_this.config.offline) {\n        const res = _this.resolveRequestOffline();\n        if (res != null) {\n          return res;\n        }\n      }\n\n      const body = yield _this.config.registries.npm.request((_npmRegistry || _load_npmRegistry()).default.escapeName(_this.name));\n\n      if (body) {\n        return yield NpmResolver.findVersionInRegistryResponse(_this.config, _this.range, body, _this.request);\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  resolveRequestOffline() {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n\n      const scope = _this2.config.registries.npm.getScope(_this2.name);\n      // find modules of this name\n      const prefix = scope ? _this2.name.split(/\\/|%2f/)[1] : `npm-${_this2.name}-`;\n\n      invariant(_this2.config.cacheFolder, 'expected packages root');\n      const cacheFolder = path.join(_this2.config.cacheFolder, scope ? 'npm-' + scope : '');\n\n      const files = yield _this2.config.getCache('cachedPackages', (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n        const files = yield (_fs || _load_fs()).readdir(cacheFolder);\n        const validFiles = [];\n\n        for (const name of files) {\n          // no hidden files\n          if (name[0] === '.') {\n            continue;\n          }\n\n          // ensure valid module cache\n          const dir = path.join(cacheFolder, name);\n          if (yield _this2.config.isValidModuleDest(dir)) {\n            validFiles.push(name);\n          }\n        }\n\n        return validFiles;\n      }));\n\n      const versions = (0, (_map || _load_map()).default)();\n\n      for (const name of files) {\n        // check if folder starts with our prefix\n        if (name.indexOf(prefix) !== 0) {\n          continue;\n        }\n\n        const dir = path.join(cacheFolder, name);\n\n        // read manifest and validate correct name\n        const pkg = yield _this2.config.readManifest(dir, 'npm');\n        if (pkg.name !== _this2.name) {\n          continue;\n        }\n\n        // read package metadata\n        const metadata = yield _this2.config.readPackageMetadata(dir);\n        if (!metadata.remote) {\n          continue; // old yarn metadata\n        }\n\n        versions[pkg.version] = (0, (_assign || _load_assign()).default)({}, pkg, { _remote: metadata.remote });\n      }\n\n      const satisfied = yield _this2.config.resolveConstraints((0, (_keys || _load_keys()).default)(versions), _this2.range);\n      if (satisfied) {\n        return versions[satisfied];\n      } else if (!_this2.config.preferOffline) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('couldntFindPackageInCache', _this2.name, _this2.range, (0, (_keys || _load_keys()).default)(versions).join(', ')));\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  cleanRegistry(url) {\n    if (this.config.getOption('registry') === (_constants || _load_constants()).YARN_REGISTRY) {\n      return url.replace(NPM_REGISTRY, (_constants || _load_constants()).YARN_REGISTRY);\n    } else {\n      return url;\n    }\n  }\n\n  resolve() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // lockfile\n      const shrunk = _this3.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const info = yield _this3.resolveRequest();\n      if (info == null) {\n        throw new (_errors || _load_errors()).MessageError(_this3.reporter.lang('packageNotFoundRegistry', _this3.name, 'npm'));\n      }\n\n      const deprecated = info.deprecated,\n            dist = info.dist;\n\n      if (typeof deprecated === 'string') {\n        let human = `${info.name}@${info.version}`;\n        const parentNames = _this3.request.getParentNames();\n        if (parentNames.length) {\n          human = parentNames.concat(human).join(' > ');\n        }\n        _this3.reporter.warn(`${human}: ${deprecated}`);\n      }\n\n      if (dist != null && dist.tarball) {\n        info._remote = {\n          resolved: `${_this3.cleanRegistry(dist.tarball)}#${dist.shasum}`,\n          type: 'tarball',\n          reference: _this3.cleanRegistry(dist.tarball),\n          hash: dist.shasum,\n          registry: 'npm'\n        };\n      }\n\n      info._uid = info.version;\n\n      return info;\n    })();\n  }\n}\nexports.default = NpmResolver;\nNpmResolver.registry = 'npm';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/registries/registry-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _baseResolver;\n\nfunction _load_baseResolver() {\n  return _baseResolver = _interopRequireDefault(require('../base-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass RegistryResolver extends (_baseResolver || _load_baseResolver()).default {\n  constructor(request, name, range) {\n    super(request, `${name}@${range}`);\n    this.name = name;\n    this.range = range;\n\n    this.registryConfig = request.config.registries[this.constructor.registry].config;\n  }\n\n}\nexports.default = RegistryResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/resolvers/registries/yarn-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _npmResolver;\n\nfunction _load_npmResolver() {\n  return _npmResolver = _interopRequireDefault(require('./npm-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass YarnResolver extends (_npmResolver || _load_npmResolver()).default {}\nexports.default = YarnResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/normalize-manifest/fix.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys;\n\nfunction _load_keys() {\n  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));\n}\n\nvar _toArray2;\n\nfunction _load_toArray() {\n  return _toArray2 = _interopRequireDefault(require('babel-runtime/helpers/toArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../resolvers/index.js');\n}\n\nvar _inferLicense;\n\nfunction _load_inferLicense() {\n  return _inferLicense = _interopRequireDefault(require('./infer-license.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst semver = require('semver');\nconst path = require('path');\nconst url = require('url');\n\nconst LICENSE_RENAMES = {\n  'MIT/X11': 'MIT',\n  X11: 'MIT'\n};\n\nexports.default = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (info, moduleLoc, reporter, warn, looseSemver) {\n    const files = yield (_fs || _load_fs()).readdir(moduleLoc);\n\n    // clean info.version\n    if (typeof info.version === 'string' && !semver.valid(info.version)) {\n      info.version = semver.clean(info.version, looseSemver) || info.version;\n    }\n\n    // if name or version aren't set then set them to empty strings\n    info.name = info.name || '';\n    info.version = info.version || '';\n\n    // if the man field is a string then coerce it to an array\n    if (typeof info.man === 'string') {\n      info.man = [info.man];\n    }\n\n    // if the keywords field is a string then split it on any whitespace\n    if (typeof info.keywords === 'string') {\n      info.keywords = info.keywords.split(/\\s+/g);\n    }\n\n    // if there's no contributors field but an authors field then expand it\n    if (!info.contributors && files.indexOf('AUTHORS') >= 0) {\n      const authorsFilepath = path.join(moduleLoc, 'AUTHORS');\n      const authorsFilestats = yield (_fs || _load_fs()).stat(authorsFilepath);\n      if (authorsFilestats.isFile()) {\n        let authors = yield (_fs || _load_fs()).readFile(authorsFilepath);\n        authors = authors.split(/\\r?\\n/g) // split on lines\n        .map(function (line) {\n          return line.replace(/^\\s*#.*$/, '').trim();\n        }) // remove comments\n        .filter(function (line) {\n          return !!line;\n        }); // remove empty lines\n        info.contributors = authors;\n      }\n    }\n\n    // expand people fields to objects\n    if (typeof info.author === 'string' || typeof info.author === 'object') {\n      info.author = (0, (_util || _load_util()).normalizePerson)(info.author);\n    }\n    if (Array.isArray(info.contributors)) {\n      info.contributors = info.contributors.map((_util || _load_util()).normalizePerson);\n    }\n    if (Array.isArray(info.maintainers)) {\n      info.maintainers = info.maintainers.map((_util || _load_util()).normalizePerson);\n    }\n\n    // if there's no readme field then load the README file from the cwd\n    if (!info.readme) {\n      const readmeCandidates = files.filter(function (filename) {\n        const lower = filename.toLowerCase();\n        return lower === 'readme' || lower.indexOf('readme.') === 0;\n      }).sort(function (filename1, filename2) {\n        // favor files with extensions\n        return filename2.indexOf('.') - filename1.indexOf('.');\n      });\n\n      for (const readmeFilename of readmeCandidates) {\n        const readmeFilepath = path.join(moduleLoc, readmeFilename);\n        const readmeFileStats = yield (_fs || _load_fs()).stat(readmeFilepath);\n        if (readmeFileStats.isFile()) {\n          info.readmeFilename = readmeFilename;\n          info.readme = yield (_fs || _load_fs()).readFile(readmeFilepath);\n          break;\n        }\n      }\n    }\n\n    // if there's no description then take the first paragraph from the readme\n    if (!info.description && info.readme) {\n      const desc = (0, (_util || _load_util()).extractDescription)(info.readme);\n      if (desc) {\n        info.description = desc;\n      }\n    }\n\n    // support array of engine keys\n    if (Array.isArray(info.engines)) {\n      const engines = {};\n      for (const str of info.engines) {\n        if (typeof str === 'string') {\n          var _str$trim$split = str.trim().split(/ +/g),\n              _str$trim$split2 = (0, (_toArray2 || _load_toArray()).default)(_str$trim$split);\n\n          const name = _str$trim$split2[0],\n                patternParts = _str$trim$split2.slice(1);\n\n          engines[name] = patternParts.join(' ');\n        }\n      }\n      info.engines = engines;\n    }\n\n    // if the repository field is a string then assume it's a git repo and expand it\n    if (typeof info.repository === 'string') {\n      info.repository = {\n        type: 'git',\n        url: info.repository\n      };\n    }\n\n    const repo = info.repository;\n\n    // explode info.repository.url if it's a hosted git shorthand\n    if (repo && typeof repo === 'object' && typeof repo.url === 'string') {\n      repo.url = (0, (_index || _load_index()).hostedGitFragmentToGitUrl)(repo.url, reporter);\n    }\n\n    // allow bugs to be specified as a string, expand it to an object with a single url prop\n    if (typeof info.bugs === 'string') {\n      info.bugs = { url: info.bugs };\n    }\n\n    // normalize homepage url to http\n    if (typeof info.homepage === 'string') {\n      const parts = url.parse(info.homepage);\n      parts.protocol = parts.protocol || 'http:';\n      if (parts.pathname && !parts.hostname) {\n        parts.hostname = parts.pathname;\n        parts.pathname = '';\n      }\n      info.homepage = url.format(parts);\n    }\n\n    // if the `bin` field is as string then expand it to an object with a single property\n    // based on the original `bin` field and `name field`\n    // { name: \"foo\", bin: \"cli.js\" } -> { name: \"foo\", bin: { foo: \"cli.js\" } }\n    if (typeof info.name === 'string' && typeof info.bin === 'string') {\n      // Remove scoped package name for consistency with NPM's bin field fixing behaviour\n      const name = info.name.replace(/^@[^\\/]+\\//, '');\n      info.bin = { [name]: info.bin };\n    }\n\n    // bundleDependencies is an alias for bundledDependencies\n    if (info.bundledDependencies) {\n      info.bundleDependencies = info.bundledDependencies;\n      delete info.bundledDependencies;\n    }\n\n    let scripts;\n\n    // dummy script object to shove file inferred scripts onto\n    if (info.scripts && typeof info.scripts === 'object') {\n      scripts = info.scripts;\n    } else {\n      scripts = {};\n    }\n\n    // if there's a server.js file and no start script then set it to `node server.js`\n    if (!scripts.start && files.indexOf('server.js') >= 0) {\n      scripts.start = 'node server.js';\n    }\n\n    // if there's a binding.gyp file and no install script then set it to `node-gyp rebuild`\n    if (!scripts.install && files.indexOf('binding.gyp') >= 0) {\n      scripts.install = 'node-gyp rebuild';\n    }\n\n    // set scripts if we've polluted the empty object\n    if ((0, (_keys || _load_keys()).default)(scripts).length) {\n      info.scripts = scripts;\n    }\n\n    const dirs = info.directories;\n\n    if (dirs && typeof dirs === 'object') {\n      const binDir = dirs.bin;\n\n      if (!info.bin && binDir && typeof binDir === 'string') {\n        const bin = info.bin = {};\n        const fullBinDir = path.join(moduleLoc, binDir);\n\n        if (yield (_fs || _load_fs()).exists(fullBinDir)) {\n          for (const scriptName of yield (_fs || _load_fs()).readdir(fullBinDir)) {\n            if (scriptName[0] === '.') {\n              continue;\n            }\n            bin[scriptName] = path.join('.', binDir, scriptName);\n          }\n        } else {\n          warn(reporter.lang('manifestDirectoryNotFound', binDir, info.name));\n        }\n      }\n\n      const manDir = dirs.man;\n\n      if (!info.man && typeof manDir === 'string') {\n        const man = info.man = [];\n        const fullManDir = path.join(moduleLoc, manDir);\n\n        if (yield (_fs || _load_fs()).exists(fullManDir)) {\n          for (const filename of yield (_fs || _load_fs()).readdir(fullManDir)) {\n            if (/^(.*?)\\.[0-9]$/.test(filename)) {\n              man.push(path.join('.', manDir, filename));\n            }\n          }\n        } else {\n          warn(reporter.lang('manifestDirectoryNotFound', manDir, info.name));\n        }\n      }\n    }\n\n    delete info.directories;\n\n    // normalize licenses field\n    const licenses = info.licenses;\n    if (Array.isArray(licenses) && !info.license) {\n      let licenseTypes = [];\n\n      for (let license of licenses) {\n        if (license && typeof license === 'object') {\n          license = license.type;\n        }\n        if (typeof license === 'string') {\n          licenseTypes.push(license);\n        }\n      }\n\n      licenseTypes = licenseTypes.filter((_util || _load_util()).isValidLicense);\n\n      if (licenseTypes.length === 1) {\n        info.license = licenseTypes[0];\n      } else if (licenseTypes.length) {\n        info.license = `(${licenseTypes.join(' OR ')})`;\n      }\n    }\n\n    const license = info.license;\n\n    // normalize license\n    if (license && typeof license === 'object') {\n      info.license = license.type;\n    }\n\n    // get license file\n    const licenseFile = files.find(function (filename) {\n      const lower = filename.toLowerCase();\n      return lower === 'license' || lower.startsWith('license.') || lower === 'unlicense' || lower.startsWith('unlicense.');\n    });\n    if (licenseFile) {\n      const licenseFilepath = path.join(moduleLoc, licenseFile);\n      const licenseFileStats = yield (_fs || _load_fs()).stat(licenseFilepath);\n      if (licenseFileStats.isFile()) {\n        const licenseContent = yield (_fs || _load_fs()).readFile(licenseFilepath);\n        const inferredLicense = (0, (_inferLicense || _load_inferLicense()).default)(licenseContent);\n        info.licenseText = licenseContent;\n\n        const license = info.license;\n\n        if (typeof license === 'string') {\n          if (inferredLicense && (0, (_util || _load_util()).isValidLicense)(inferredLicense) && !(0, (_util || _load_util()).isValidLicense)(license)) {\n            // some packages don't specify their license version but we can infer it based on their license file\n            const basicLicense = license.toLowerCase().replace(/(-like|\\*)$/g, '');\n            const expandedLicense = inferredLicense.toLowerCase();\n            if (expandedLicense.startsWith(basicLicense)) {\n              // TODO consider doing something to notify the user\n              info.license = inferredLicense;\n            }\n          }\n        } else if (inferredLicense) {\n          // if there's no license then infer it based on the license file\n          info.license = inferredLicense;\n        } else {\n          // valid expression to refer to a license in a file\n          info.license = `SEE LICENSE IN ${licenseFile}`;\n        }\n      }\n    }\n\n    if (typeof info.license === 'string') {\n      // sometimes licenses are known by different names, reduce them\n      info.license = LICENSE_RENAMES[info.license] || info.license;\n    } else if (typeof info.readme === 'string') {\n      // the license might be at the bottom of the README\n      const inferredLicense = (0, (_inferLicense || _load_inferLicense()).default)(info.readme);\n      if (inferredLicense) {\n        info.license = inferredLicense;\n      }\n    }\n  });\n\n  return function (_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n})();","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib-legacy/util/normalize-manifest/infer-license.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inferLicense;\n\nvar _licenses;\n\nfunction _load_licenses() {\n  return _licenses = _interopRequireDefault(require('./licenses.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction clean(str) {\n  return str.replace(/[^A-Za-z\\s]/g, ' ').replace(/[\\s]+/g, ' ').trim().toLowerCase();\n}\n\nconst REGEXES = {\n  Unlicense: [/http:\\/\\/unlicense.org\\//],\n  WTFPL: [/DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE/, /WTFPL\\b/],\n  ISC: [/The ISC License/, /ISC\\b/],\n  Apache: [/Apache License\\b/],\n  MIT: [/MIT\\b/],\n  BSD: [/BSD\\b/]\n};\n\nfunction inferLicense(license) {\n  // check if we have any explicit licenses\n  const cleanLicense = clean(license);\n  for (const licenseName in (_licenses || _load_licenses()).default) {\n    const testLicense = (_licenses || _load_licenses()).default[licenseName];\n    if (cleanLicense.search(testLicense) >= 0) {\n      return licenseName;\n    }\n  }\n\n  // infer based on some keywords\n  for (const licenseName in REGEXES) {\n    for (const regex of REGEXES[licenseName]) {\n      if (license.search(regex) >= 0) {\n        return `${licenseName}*`;\n      }\n    }\n  }\n\n  return null;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/registries/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registryNames = exports.registries = undefined;\n\nvar _yarnRegistry;\n\nfunction _load_yarnRegistry() {\n  return _yarnRegistry = _interopRequireDefault(require('./yarn-registry.js'));\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('./npm-registry.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst registries = exports.registries = {\n  npm: (_npmRegistry || _load_npmRegistry()).default,\n  yarn: (_yarnRegistry || _load_yarnRegistry()).default\n};\n\nconst registryNames = exports.registryNames = Object.keys(registries);","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/registries/npm-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nvar _npmResolver;\n\nfunction _load_npmResolver() {\n  return _npmResolver = _interopRequireDefault(require('../resolvers/registries/npm-resolver.js'));\n}\n\nvar _envReplace;\n\nfunction _load_envReplace() {\n  return _envReplace = _interopRequireDefault(require('../util/env-replace.js'));\n}\n\nvar _baseRegistry;\n\nfunction _load_baseRegistry() {\n  return _baseRegistry = _interopRequireDefault(require('./base-registry.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc');\n}\n\nvar _isRequestToRegistry;\n\nfunction _load_isRequestToRegistry() {\n  return _isRequestToRegistry = _interopRequireDefault(require('./is-request-to-registry.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst userHome = require('../util/user-home-dir').default;\nconst path = require('path');\nconst url = require('url');\nconst ini = require('ini');\n\nconst DEFAULT_REGISTRY = 'https://registry.npmjs.org/';\n\nfunction getGlobalPrefix() {\n  if (process.env.PREFIX) {\n    return process.env.PREFIX;\n  } else if (process.platform === 'win32') {\n    // c:\\node\\node.exe --> prefix=c:\\node\\\n    return path.dirname(process.execPath);\n  } else {\n    // /usr/local/bin/node --> prefix=/usr/local\n    let prefix = path.dirname(path.dirname(process.execPath));\n\n    // destdir only is respected on Unix\n    if (process.env.DESTDIR) {\n      prefix = path.join(process.env.DESTDIR, prefix);\n    }\n\n    return prefix;\n  }\n}\n\nclass NpmRegistry extends (_baseRegistry || _load_baseRegistry()).default {\n  constructor(cwd, registries, requestManager) {\n    super(cwd, registries, requestManager);\n    this.folder = 'node_modules';\n  }\n\n  static escapeName(name) {\n    // scoped packages contain slashes and the npm registry expects them to be escaped\n    return name.replace('/', '%2f');\n  }\n\n  request(pathname) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const registry = (0, (_misc || _load_misc()).addSuffix)(this.getRegistry(pathname), '/');\n    const requestUrl = url.resolve(registry, pathname);\n    const alwaysAuth = this.getScopedOption(registry.replace(/^https?:/, ''), 'always-auth') || this.getOption('always-auth') || (0, (_misc || _load_misc()).removePrefix)(requestUrl, registry)[0] === '@';\n\n    const headers = {};\n    if (this.token || alwaysAuth && (0, (_isRequestToRegistry || _load_isRequestToRegistry()).default)(requestUrl, registry)) {\n      const authorization = this.getAuth(pathname);\n      if (authorization) {\n        headers.authorization = authorization;\n      }\n    }\n\n    return this.requestManager.request({\n      url: requestUrl,\n      method: opts.method,\n      body: opts.body,\n      auth: opts.auth,\n      headers,\n      json: !opts.buffer,\n      buffer: opts.buffer,\n      process: opts.process,\n      gzip: true\n    });\n  }\n\n  checkOutdated(config, name, range) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const req = yield _this.request(NpmRegistry.escapeName(name));\n      if (!req) {\n        throw new Error('couldnt find ' + name);\n      }\n\n      const repository = req.repository,\n            homepage = req.homepage;\n\n      const url = homepage || repository && repository.url || '';\n\n      return {\n        latest: req['dist-tags'].latest,\n        wanted: (yield (_npmResolver || _load_npmResolver()).default.findVersionInRegistryResponse(config, range, req)).version,\n        url\n      };\n    })();\n  }\n\n  getPossibleConfigLocations(filename) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const possibles = [[false, path.join(_this2.cwd, filename)], [true, _this2.config.userconfig || path.join(userHome, filename)], [false, path.join(getGlobalPrefix(), filename)]];\n\n      const foldersFromRootToCwd = _this2.cwd.split(path.sep);\n      while (foldersFromRootToCwd.length > 1) {\n        possibles.push([false, path.join(foldersFromRootToCwd.join(path.sep), filename)]);\n        foldersFromRootToCwd.pop();\n      }\n\n      const actuals = [];\n      for (const _ref of possibles) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const isHome = _ref2[0];\n        const loc = _ref2[1];\n\n        if (yield (_fs || _load_fs()).exists(loc)) {\n          actuals.push([isHome, loc, yield (_fs || _load_fs()).readFile(loc)]);\n        }\n      }\n      return actuals;\n    })();\n  }\n\n  loadConfig() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // docs: https://docs.npmjs.com/misc/config\n      _this3.mergeEnv('npm_config_');\n\n      for (const _ref3 of yield _this3.getPossibleConfigLocations('.npmrc')) {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 3);\n\n        const loc = _ref4[1];\n        const file = _ref4[2];\n\n        const config = (_baseRegistry || _load_baseRegistry()).default.normalizeConfig(ini.parse(file));\n        for (const key in config) {\n          config[key] = (0, (_envReplace || _load_envReplace()).default)(config[key]);\n        }\n\n        // normalize offline mirror path relative to the current npmrc\n        const offlineLoc = config['yarn-offline-mirror'];\n        // don't normalize if we already have a mirror path\n        if (!_this3.config['yarn-offline-mirror'] && offlineLoc) {\n          const mirrorLoc = config['yarn-offline-mirror'] = path.resolve(path.dirname(loc), offlineLoc);\n          yield (_fs || _load_fs()).mkdirp(mirrorLoc);\n        }\n\n        _this3.config = Object.assign({}, config, _this3.config);\n      }\n    })();\n  }\n\n  getScope(packageName) {\n    return !packageName || packageName[0] !== '@' ? '' : packageName.split(/\\/|%2f/)[0];\n  }\n\n  getRegistry(packageName) {\n    // Try extracting registry from the url, then scoped registry, and default registry\n    if (packageName.match(/^https?:/)) {\n      const availableRegistries = this.getAvailableRegistries();\n      const registry = availableRegistries.find(registry => packageName.startsWith(registry));\n      if (registry) {\n        return registry;\n      }\n    }\n\n    for (const scope of [this.getScope(packageName), '']) {\n      const registry = this.getScopedOption(scope, 'registry') || this.registries.yarn.getScopedOption(scope, 'registry');\n      if (registry) {\n        return String(registry);\n      }\n    }\n\n    return DEFAULT_REGISTRY;\n  }\n\n  getAuth(packageName) {\n    if (this.token) {\n      return this.token;\n    }\n\n    for (let registry of [this.getRegistry(packageName), '', DEFAULT_REGISTRY]) {\n      registry = registry.replace(/^https?:/, '');\n\n      // Check for bearer token.\n      let auth = this.getScopedOption(registry.replace(/\\/?$/, '/'), '_authToken');\n      if (auth) {\n        return `Bearer ${String(auth)}`;\n      }\n\n      // Check for basic auth token.\n      auth = this.getScopedOption(registry, '_auth');\n      if (auth) {\n        return `Basic ${String(auth)}`;\n      }\n\n      // Check for basic username/password auth.\n      const username = this.getScopedOption(registry, 'username');\n      const password = this.getScopedOption(registry, '_password');\n      if (username && password) {\n        const pw = new Buffer(String(password), 'base64').toString();\n        return 'Basic ' + new Buffer(String(username) + ':' + pw).toString('base64');\n      }\n    }\n\n    return '';\n  }\n\n  getScopedOption(scope, option) {\n    return this.getOption(scope + (scope ? ':' : '') + option);\n  }\n}\nexports.default = NpmRegistry;\nNpmRegistry.filename = 'package.json';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/registries/base-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst objectPath = require('object-path');\nconst path = require('path');\n\nclass BaseRegistry {\n  constructor(cwd, registries, requestManager) {\n    this.requestManager = requestManager;\n    this.registries = registries;\n    this.config = {};\n    this.folder = '';\n    this.token = '';\n    this.loc = '';\n    this.cwd = cwd;\n  }\n\n  // the filename to use for package metadata\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  // absolute folder name to insert modules\n\n\n  // relative folder name to put these modules\n\n\n  setToken(token) {\n    this.token = token;\n  }\n\n  getOption(key) {\n    return this.config[key];\n  }\n\n  getAvailableRegistries() {\n    const config = this.config;\n    return Object.keys(config).reduce((registries, option) => {\n      if (option === 'registry' || option.split(':')[1] === 'registry') {\n        registries.push(config[option]);\n      }\n      return registries;\n    }, []);\n  }\n\n  loadConfig() {\n    return Promise.resolve();\n  }\n\n  checkOutdated(config, name, range) {\n    return Promise.reject(new Error('unimplemented'));\n  }\n\n  saveHomeConfig(config) {\n    return Promise.reject(new Error('unimplemented'));\n  }\n\n  request(pathname) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return this.requestManager.request((0, (_extends2 || _load_extends()).default)({\n      url: pathname\n    }, opts));\n  }\n\n  init() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this.mergeEnv('yarn_');\n      yield _this.loadConfig();\n      _this.loc = path.join(_this.cwd, _this.folder);\n    })();\n  }\n\n  static normalizeConfig(config) {\n    for (const key in config) {\n      config[key] = BaseRegistry.normalizeConfigOption(config[key]);\n    }\n    return config;\n  }\n\n  static normalizeConfigOption(val) {\n    if (val === 'true') {\n      return true;\n    } else if (val === 'false') {\n      return false;\n    } else {\n      return val;\n    }\n  }\n\n  mergeEnv(prefix) {\n    // try environment variables\n    for (let key in process.env) {\n      key = key.toLowerCase();\n\n      // only accept keys prefixed with the prefix\n      if (key.indexOf(prefix) < 0) {\n        continue;\n      }\n\n      const val = BaseRegistry.normalizeConfigOption(process.env[key]);\n\n      // remove config prefix\n      key = (0, (_misc || _load_misc()).removePrefix)(key, prefix);\n\n      // replace dunders with dots\n      key = key.replace(/__/g, '.');\n\n      // replace underscores with dashes\n      key = key.replace(/_/g, '-');\n\n      // set it via a path\n      objectPath.set(this.config, key, val);\n    }\n  }\n}\nexports.default = BaseRegistry;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/registries/yarn-registry.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULTS = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../constants.js');\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('./npm-registry.js'));\n}\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = _interopRequireDefault(require('../lockfile/stringify.js'));\n}\n\nvar _parse;\n\nfunction _load_parse() {\n  return _parse = _interopRequireDefault(require('../lockfile/parse.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst userHome = require('../util/user-home-dir').default;\n\nconst path = require('path');\nconst pkg = require('../../package.json');\n\nconst DEFAULTS = exports.DEFAULTS = {\n  'version-tag-prefix': 'v',\n  'version-git-tag': true,\n  'version-git-sign': false,\n  'version-git-message': 'v%s',\n\n  'init-version': '1.0.0',\n  'init-license': 'MIT',\n\n  'save-prefix': '^',\n  'ignore-scripts': false,\n  'ignore-optional': false,\n  registry: (_constants || _load_constants()).YARN_REGISTRY,\n  'strict-ssl': true,\n  'user-agent': [`yarn/${pkg.version}`, 'npm/?', `node/${process.version}`, process.platform, process.arch].join(' ')\n};\n\nconst npmMap = {\n  'version-git-sign': 'sign-git-tag',\n  'version-tag-prefix': 'tag-version-prefix',\n  'version-git-tag': 'git-tag-version',\n  'version-git-message': 'message'\n};\n\nclass YarnRegistry extends (_npmRegistry || _load_npmRegistry()).default {\n  constructor(cwd, registries, requestManager) {\n    super(cwd, registries, requestManager);\n\n    this.homeConfigLoc = path.join(userHome, '.yarnrc');\n    this.homeConfig = {};\n  }\n\n  getOption(key) {\n    let val = this.config[key];\n\n    // if this isn't set in a yarn config, then use npm\n    if (typeof val === 'undefined') {\n      val = this.registries.npm.getOption(npmMap[key]);\n    }\n\n    if (typeof val === 'undefined') {\n      val = this.registries.npm.getOption(key);\n    }\n\n    // if this isn't set in a yarn config or npm config, then use the default (or undefined)\n    if (typeof val === 'undefined') {\n      val = DEFAULTS[key];\n    }\n\n    return val;\n  }\n\n  loadConfig() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      for (const _ref of yield _this.getPossibleConfigLocations('.yarnrc')) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 3);\n\n        const isHome = _ref2[0];\n        const loc = _ref2[1];\n        const file = _ref2[2];\n\n        const config = (0, (_parse || _load_parse()).default)(file, loc);\n\n        if (isHome) {\n          _this.homeConfig = config;\n        }\n\n        // normalize offline mirror path relative to the current yarnrc\n        const offlineLoc = config['yarn-offline-mirror'];\n\n        // don't normalize if we already have a mirror path\n        if (!_this.config['yarn-offline-mirror'] && offlineLoc) {\n          const mirrorLoc = config['yarn-offline-mirror'] = path.resolve(path.dirname(loc), offlineLoc);\n          yield (_fs || _load_fs()).mkdirp(mirrorLoc);\n        }\n\n        _this.config = Object.assign({}, config, _this.config);\n      }\n\n      // default yarn config\n      _this.config = Object.assign({}, DEFAULTS, _this.config);\n    })();\n  }\n\n  saveHomeConfig(config) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      YarnRegistry.normalizeConfig(config);\n\n      for (const key in config) {\n        const val = config[key];\n\n        // if the current config key was taken from home config then update\n        // the global config\n        if (_this2.homeConfig[key] === _this2.config[key]) {\n          _this2.config[key] = val;\n        }\n\n        // update just the home config\n        _this2.homeConfig[key] = config[key];\n      }\n\n      yield (_fs || _load_fs()).writeFilePreservingEol(_this2.homeConfigLoc, `${(0, (_stringify || _load_stringify()).default)(_this2.homeConfig)}\\n`);\n    })();\n  }\n}\nexports.default = YarnRegistry;\nYarnRegistry.filename = 'yarn.json';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/env-replace.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = envReplace;\nconst ENV_EXPR = /(\\\\*)\\$\\{([^}]+)\\}/g;\n\nfunction envReplace(value) {\n  let env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.env;\n\n  if (typeof value !== 'string' || !value) {\n    return value;\n  }\n\n  return value.replace(ENV_EXPR, (match, esc, envVarName) => {\n    if (esc.length && esc.length % 2) {\n      return match;\n    }\n    if (undefined === env[envVarName]) {\n      throw new Error('Failed to replace env in config: ' + match);\n    }\n    return env[envVarName] || '';\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/lockfile/wrapper.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringify = exports.parse = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _parse;\n\nfunction _load_parse() {\n  return _parse = require('./parse');\n}\n\nObject.defineProperty(exports, 'parse', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_parse || _load_parse()).default;\n  }\n});\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = require('./stringify');\n}\n\nObject.defineProperty(exports, 'stringify', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_stringify || _load_stringify()).default;\n  }\n});\nexports.implodeEntry = implodeEntry;\nexports.explodeEntry = explodeEntry;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('../package-request.js'));\n}\n\nvar _parse2;\n\nfunction _load_parse2() {\n  return _parse2 = _interopRequireDefault(require('./parse.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nfunction getName(pattern) {\n  return (_packageRequest || _load_packageRequest()).default.normalizePattern(pattern).name;\n}\n\nfunction blankObjectUndefined(obj) {\n  return obj && Object.keys(obj).length ? obj : undefined;\n}\n\nfunction implodeEntry(pattern, obj) {\n  const inferredName = getName(pattern);\n  return {\n    name: inferredName === obj.name ? undefined : obj.name,\n    version: obj.version,\n    uid: obj.uid === obj.version ? undefined : obj.uid,\n    resolved: obj.resolved,\n    registry: obj.registry === 'npm' ? undefined : obj.registry,\n    dependencies: blankObjectUndefined(obj.dependencies),\n    optionalDependencies: blankObjectUndefined(obj.optionalDependencies),\n    permissions: blankObjectUndefined(obj.permissions)\n  };\n}\n\nfunction explodeEntry(pattern, obj) {\n  obj.optionalDependencies = obj.optionalDependencies || {};\n  obj.dependencies = obj.dependencies || {};\n  obj.uid = obj.uid || obj.version;\n  obj.permissions = obj.permissions || {};\n  obj.registry = obj.registry || 'npm';\n  obj.name = obj.name || getName(pattern);\n  return obj;\n}\n\nclass Lockfile {\n  constructor(cache, source) {\n    this.source = source || '';\n    this.cache = cache;\n  }\n\n  // source string if the `cache` was parsed\n\n\n  static fromDirectory(dir, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // read the manifest in this directory\n      const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);\n      let lockfile;\n      let rawLockfile = '';\n\n      if (yield (_fs || _load_fs()).exists(lockfileLoc)) {\n        rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);\n        lockfile = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);\n      } else {\n        if (reporter) {\n          reporter.info(reporter.lang('noLockfileFound'));\n        }\n      }\n\n      return new Lockfile(lockfile, rawLockfile);\n    })();\n  }\n\n  getLocked(pattern) {\n    const cache = this.cache;\n    if (!cache) {\n      return undefined;\n    }\n\n    const shrunk = pattern in cache && cache[pattern];\n\n    if (typeof shrunk === 'string') {\n      return this.getLocked(shrunk);\n    } else if (shrunk) {\n      explodeEntry(pattern, shrunk);\n      return shrunk;\n    }\n\n    return undefined;\n  }\n\n  getLockfile(patterns) {\n    const lockfile = {};\n    const seen = new Map();\n\n    // order by name so that lockfile manifest is assigned to the first dependency with this manifest\n    // the others that have the same remote.resolved will just refer to the first\n    // ordering allows for consistency in lockfile when it is serialized\n    const sortedPatternsKeys = Object.keys(patterns).sort((_misc || _load_misc()).sortAlpha);\n\n    for (const pattern of sortedPatternsKeys) {\n      const pkg = patterns[pattern];\n      const remote = pkg._remote,\n            ref = pkg._reference;\n\n      invariant(ref, 'Package is missing a reference');\n      invariant(remote, 'Package is missing a remote');\n\n      const seenPattern = remote.resolved && seen.get(remote.resolved);\n      if (seenPattern) {\n        // no point in duplicating it\n        lockfile[pattern] = seenPattern;\n\n        // if we're relying on our name being inferred and two of the patterns have\n        // different inferred names then we need to set it\n        if (!seenPattern.name && getName(pattern) !== pkg.name) {\n          seenPattern.name = pkg.name;\n        }\n        continue;\n      }\n\n      const obj = implodeEntry(pattern, {\n        name: pkg.name,\n        version: pkg.version,\n        uid: pkg._uid,\n        resolved: remote.resolved,\n        registry: remote.registry,\n        dependencies: pkg.dependencies,\n        peerDependencies: pkg.peerDependencies,\n        optionalDependencies: pkg.optionalDependencies,\n        permissions: ref.permissions\n      });\n      lockfile[pattern] = obj;\n\n      if (remote.resolved) {\n        seen.set(remote.resolved, obj);\n      }\n    }\n\n    return lockfile;\n  }\n}\nexports.default = Lockfile;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/lang/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.en = undefined;\n\nvar _en;\n\nfunction _load_en() {\n  return _en = _interopRequireDefault(require('./en.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.en = (_en || _load_en()).default;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/lang/en.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/* eslint max-len: 0 */\n\nconst messages = {\n  upToDate: 'Already up-to-date.',\n  folderInSync: 'Folder in sync.',\n  nothingToInstall: 'Nothing to install.',\n  resolvingPackages: 'Resolving packages',\n  fetchingPackages: 'Fetching packages',\n  linkingDependencies: 'Linking dependencies',\n  rebuildingPackages: 'Rebuilding all packages',\n  buildingFreshPackages: 'Building fresh packages',\n  cleaningModules: 'Cleaning modules',\n  bumpingVersion: 'Bumping version',\n  savingHar: 'Saving HAR file: $0',\n  answer: 'Answer?',\n  usage: 'Usage',\n  installCommandRenamed: '`install` has been replaced with `add` to add new dependencies. Run $0 instead.',\n  waitingInstance: 'Waiting for the other yarn instance to finish',\n  offlineRetrying: 'There appears to be trouble with your network connection. Retrying...',\n  clearedCache: 'Cleared cache.',\n  packWroteTarball: 'Wrote tarball to $0.',\n\n  manifestPotentialTypo: 'Potential typo $0, did you mean $1?',\n  manifestBuiltinModule: '$0 is also the name of a node core module',\n  manifestNameDot: \"Name can't start with a dot\",\n  manifestNameIllegalChars: 'Name contains illegal characters',\n  manifestNameBlacklisted: 'Name is blacklisted',\n  manifestLicenseInvalid: 'License should be a valid SPDX license expression',\n  manifestLicenseNone: 'No license field',\n  manifestStringExpected: '$0 is not a string',\n  manifestDependencyCollision: '$0 has dependency $1 with range $2 that collides with a dependency in $3 of the same name with version $4',\n  manifestDirectoryNotFound: 'Unable to read $0 directory of module $1',\n\n  verboseFileCopy: 'Copying $0 to $1.',\n  verboseFileLink: 'Creating hardlink at $0 to $1.',\n  verboseFileSymlink: 'Creating symlink at $0 to $1.',\n  verboseFileSkip: 'Skipping copying of file $0 as the file at $1 is the same size ($2) and mtime ($3).',\n  verboseFileSkipSymlink: 'Skipping copying of $0 as the file at $1 is the same symlink ($2).',\n  verboseFileSkipHardlink: 'Skipping copying of $0 as the file at $1 is the same hardlink ($2).',\n  verboseFileRemoveExtraneous: 'Removing extraneous file $0.',\n  verboseFilePhantomExtraneous: \"File $0 would be marked as extraneous but has been removed as it's listed as a phantom file.\",\n  verboseFileFolder: 'Creating directory $0.',\n\n  verboseRequestStart: 'Performing $0 request to $1.',\n  verboseRequestFinish: 'Request $0 finished with status code $1.',\n\n  configSet: 'Set $0 to $1.',\n  configDelete: 'Deleted $0.',\n  configNpm: 'npm config',\n  configYarn: 'yarn config',\n\n  couldntFindPackagejson: \"Couldn't find a package.json file in $0\",\n  couldntFindMatch: \"Couldn't find match for $0 in $1 for $2.\",\n  couldntFindPackageInCache: \"Couldn't find any versions for $0 that matches $1 in our cache. Possible versions: $2\",\n  couldntFindVersionThatMatchesRange: \"Couldn't find any versions for $0 that matches $1\",\n  chooseVersionFromList: 'Please choose a version from this list:',\n  moduleNotInManifest: \"This module isn't specified in a manifest.\",\n  unknownFolderOrTarball: \"Passed folder/tarball doesn't exist,\",\n  unknownPackage: \"Couldn't find package $0.\",\n  unknownPackageName: \"Couldn't find package name.\",\n  unknownUser: \"Couldn't find user $0.\",\n  unknownRegistryResolver: 'Unknown registry resolver $0',\n  userNotAnOwner: \"User $0 isn't an owner of this package.\",\n  invalidVersionArgument: 'Use the $0 flag to create a new version.',\n  invalidVersion: 'Invalid version supplied.',\n  requiredVersionInRange: 'Required version in range.',\n  packageNotFoundRegistry: \"Couldn't find package $0 on the $1 registry.\",\n  doesntExist: \"$0 doesn't exist.\",\n  missingRequiredPackageKey: `Package $0 doesn't have a $1.`,\n  invalidAccess: 'Invalid argument for access, expected public or restricted.',\n  invalidCommand: 'Invalid subcommand. Try $0',\n  invalidGistFragment: 'Invalid gist fragment $0.',\n  invalidHostedGitFragment: 'Invalid hosted git fragment $0.',\n  invalidFragment: 'Invalid fragment $0.',\n  invalidPackageName: 'Invalid package name.',\n  couldntFindManifestIn: \"Couldn't find manifest in $0.\",\n  shrinkwrapWarning: 'npm-shrinkwrap.json found. This will not be updated or respected. See https://yarnpkg.com/en/docs/migrating-from-npm for more information.',\n  lockfileOutdated: 'Outdated lockfile. Please run `yarn install` and try again.',\n  ignoredScripts: 'Ignored scripts due to flag.',\n  missingAddDependencies: 'Missing list of packages to add to your project.',\n  yesWarning: 'The yes flag has been set. This will automatically answer yes to all questions which may have security implications.',\n  networkWarning: \"You don't appear to have an internet connection. Try the --offline flag to use the cache for registry queries.\",\n  flatGlobalError: 'The package $0@$1 requires a flat dependency graph. Add `\"flat\": true` to your package.json and try again.',\n  noName: `Package doesn't have a name.`,\n  noVersion: `Package doesn't have a version.`,\n  answerRequired: 'An answer is required.',\n  missingWhyDependency: 'Missing package name, folder or path to file to identify why a package has been installed',\n  bugReport: 'If you think this is a bug, please open a bug report with the information provided in $0.',\n  unexpectedError: 'An unexpected error occurred: $0.',\n  jsonError: 'Error parsing JSON at $0, $1.',\n  noFilePermission: \"We don't have permissions to touch the file $0.\",\n  allDependenciesUpToDate: 'All of your dependencies are up to date.',\n  frozenLockfileError: 'Your lockfile needs to be updated, but yarn was run with `--frozen-lockfile`.',\n  fileWriteError: 'Could not write file $0: $1',\n\n  yarnOutdated: \"Your current version of Yarn is out of date. The latest version is $0 while you're on $1.\",\n  yarnOutdatedInstaller: 'To upgrade, download the latest installer at $0.',\n  yarnOutdatedCommand: 'To upgrade, run the following command:',\n\n  tooManyArguments: 'Too many arguments, maximum of $0.',\n  tooFewArguments: 'Not enough arguments, expected at least $0.',\n  noArguments: \"This command doesn't require any arguments.\",\n\n  ownerRemoving: 'Removing owner $0 from package $1.',\n  ownerRemoved: 'Owner removed.',\n  ownerRemoveError: \"Couldn't remove owner.\",\n  ownerGetting: 'Getting owners for package $0',\n  ownerGettingFailed: \"Couldn't get list of owners.\",\n  ownerAlready: 'This user is already an owner of this package.',\n  ownerAdded: 'Added owner.',\n  ownerAdding: 'Adding owner $0 to package $1',\n  ownerAddingFailed: \"Couldn't add owner.\",\n  ownerNone: 'No owners.',\n\n  teamCreating: 'Creating team',\n  teamRemoving: 'Removing team',\n  teamAddingUser: 'Adding user to team',\n  teamRemovingUser: 'Removing user from team',\n  teamListing: 'Listing teams',\n\n  cleaning: 'Cleaning modules',\n  cleanCreatingFile: 'Creating $0',\n\n  binLinkCollision: \"There's already a linked binary called $0 in your global Yarn bin. Could not link this package's $0 bin entry.\",\n  linkCollision: \"There's already a module called $0 registered.\",\n  linkMissing: 'No registered module found called $0.',\n  linkInstallMessage: 'You can now run `yarn link $0` in the projects where you want to use this module and it will be used instead.',\n  linkRegistered: 'Registered $0.',\n  linkUnregistered: 'Unregistered $0.',\n  linkUsing: 'Using linked module for $0.',\n\n  commandNotSpecified: 'No command specified.',\n  binCommands: 'Commands available from binary scripts: ',\n  possibleCommands: 'Project commands',\n  commandQuestion: 'Which command would you like to run?',\n  commandFailed: 'Command failed with exit code $0.',\n\n  foundIncompatible: 'Found incompatible module',\n  incompatibleEngine: 'The engine $0 is incompatible with this module. Expected version $1.',\n  incompatibleCPU: 'The CPU architecture $0 is incompatible with this module.',\n  incompatibleOS: 'The platform $0 is incompatible with this module.',\n  invalidEngine: 'The engine $0 appears to be invalid.',\n\n  selfUpdateReleased: 'Replaced current release with $0.',\n  selfUpdateDownloading: 'Downloading yarn version $0.',\n  selfUpdateNoNewer: 'Yarn is already using the latest version.',\n\n  optionalCompatibilityExcluded: '$0 is an optional dependency and failed compatibility check. Excluding it from installation.',\n  optionalModuleFail: 'This module is OPTIONAL, you can safely ignore this error',\n  optionalModuleScriptFail: 'Error running install script for optional dependency: $0',\n  optionalModuleCleanupFail: 'Could not cleanup build artifacts from failed install: $0',\n\n  unmetPeer: '$0 has unmet peer dependency $1.',\n  incorrectPeer: '$0 has incorrect peer dependency $1.',\n\n  savedNewDependency: 'Saved 1 new dependency.',\n  savedNewDependencies: 'Saved $0 new dependencies.',\n\n  foundWarnings: 'Found $0 warnings.',\n  foundErrors: 'Found $0 errors.',\n\n  savedLockfile: 'Saved lockfile.',\n  noRequiredLockfile: 'No lockfile in this directory. Run `yarn install` to generate one.',\n  noLockfileFound: 'No lockfile found.',\n\n  invalidSemver: 'Invalid semver version',\n  newVersion: 'New version',\n  currentVersion: 'Current version',\n\n  manualVersionResolution: 'Unable to find a suitable version for $0, please choose one by typing one of the numbers below:',\n  manualVersionResolutionOption: '$0 which resolved to $1',\n\n  createdTag: 'Created tag.',\n  createdTagFail: \"Couldn't add tag.\",\n  deletedTag: 'Deleted tag.',\n  deletedTagFail: \"Couldn't delete tag.\",\n  gettingTags: 'Getting tags',\n  deletingTags: 'Deleting tag',\n  creatingTag: 'Creating tag $0 = $1',\n\n  whyStart: 'Why do we have the module $0?',\n  whyFinding: 'Finding dependency',\n  whyCalculating: 'Calculating file sizes',\n  whyUnknownMatch: \"We couldn't find a match!\",\n  whyInitGraph: 'Initialising dependency graph',\n  whyWhoKnows: \"We don't know why this module exists\",\n  whyDiskSizeWithout: 'Disk size without dependencies: $0',\n  whyDiskSizeUnique: 'Disk size with unique dependencies: $0',\n  whyDiskSizeTransitive: 'Disk size with transitive dependencies: $0',\n  whySharedDependencies: 'Amount of shared dependencies: $0',\n  whyHoistedTo: `Has been hoisted to $0`,\n\n  whyHoistedFromSimple: `This module exists because it's hoisted from $0.`,\n  whyDependedOnSimple: `This module exists because $0 depends on it.`,\n  whySpecifiedSimple: `This module exists because it's specified in $0.`,\n  whyReasons: 'Reasons this module exists',\n  whyHoistedFrom: 'Hoisted from $0',\n  whyDependedOn: '$0 depends on it',\n  whySpecified: `Specified in $0`,\n\n  uninstalledPackages: 'Uninstalled packages.',\n  uninstallRegenerate: 'Regenerating lockfile and installing missing dependencies',\n\n  cleanRemovedFiles: 'Removed $0 files',\n  cleanSavedSize: 'Saved $0 MB.',\n\n  npmUsername: 'npm username',\n  npmPassword: 'npm password',\n  npmEmail: 'npm email',\n\n  loggingIn: 'Logging in',\n  loggedIn: 'Logged in.',\n  notRevokingEnvToken: 'Not revoking login token, specified via environment variable.',\n  notRevokingConfigToken: 'Not revoking login token, specified via config file.',\n  noTokenToRevoke: 'No login token to revoke.',\n  revokingToken: 'Revoking token',\n  revokedToken: 'Revoked login token.',\n\n  loginAsPublic: 'Logging in as public',\n  incorrectCredentials: 'Incorrect username or password.',\n  clearedCredentials: 'Cleared login credentials.',\n\n  publishSame: 'New version is the same as the current version.',\n  publishFail: \"Couldn't publish package.\",\n  publishPrivate: 'Package marked as private, not publishing.',\n  published: 'Published.',\n  publishing: 'Publishing',\n\n  infoFail: 'Received invalid response from npm.',\n  malformedRegistryResponse: 'Received malformed response from registry for $0. The registry may be down.',\n\n  cantRequestOffline: 'Can\\'t make a request in offline mode',\n  requestManagerNotSetupHAR: 'RequestManager was not setup to capture HAR files',\n  requestError: 'Request $0 returned a $1',\n  requestFailed: 'Request failed $0',\n  tarballNotInNetworkOrCache: '$0: Tarball is not in network and can not be located in cache ($1)',\n  fetchBadHash: 'Bad hash. Expected $0 but got $1 ',\n  fetchErrorCorrupt: '$0. Mirror tarball appears to be corrupt. You can resolve this by running:\\n\\n  rm -rf $1\\n  yarn install',\n  errorDecompressingTarball: '$0. Error decompressing $1, it appears to be corrupt.',\n  updateInstalling: 'Installing $0...',\n  hostedGitResolveError: 'Error connecting to repository. Please, check the url.',\n\n  unknownFetcherFor: 'Unknown fetcher for $0',\n\n  refusingDownloadGitWithoutCommit: 'Refusing to download the git repo $0 over plain git without a commit hash',\n  refusingDownloadHTTPWithoutCommit: 'Refusing to download the git repo $0 over HTTP without a commit hash',\n  refusingDownloadHTTPSWithoutCommit: 'Refusing to download the git repo $0 over HTTPS without a commit hash - possible certificate error?',\n\n  packageInstalledWithBinaries: 'Installed $0 with binaries:',\n  packageHasBinaries: '$0 has binaries:',\n  packageHasNoBinaries: '$0 has no binaries',\n\n  couldBeDeduped: '$0 could be deduped from $1 to $2',\n  lockfileNotContainPatter: 'Lockfile does not contain pattern: $0',\n  integrityHashesDontMatch: 'Integrity hashes don\\'t match, expected $0 but got $1',\n  noIntegirtyHashFile: 'Couldn\\'t find an integrity hash file',\n  packageNotInstalled: '$0 not installed',\n  optionalDepNotInstalled: 'Optional dependency $0 not installed',\n  packageWrongVersion: '$0 is wrong version: expected $1, got $2',\n  packageDontSatisfy: '$0 doesn\\'t satisfy found match of $1',\n\n  lockfileExists: 'Lockfile already exists, not importing.',\n  skippingImport: 'Skipping import of $0 for $1',\n  importFailed: 'Import of $0 for $1 failed, resolving normally.',\n  importResolveFailed: 'Import of $0 failed starting in $1',\n  importResolvedRangeMatch: 'Using version $0 of $1 instead of $2 for $3'\n};\n\nexports.default = messages;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/execute-lifecycle-script.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.execCommand = exports.execFromManifest = exports.executeLifecycleScript = undefined;\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet makeEnv = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, cwd, config) {\n    const env = Object.assign({}, process.env);\n\n    env.npm_lifecycle_event = stage;\n    env.npm_node_execpath = env.NODE || process.execPath;\n    env.npm_execpath = path.join(__dirname, '..', '..', 'bin', 'yarn.js');\n\n    // Set the env to production for npm compat if production mode.\n    // https://github.com/npm/npm/blob/30d75e738b9cb7a6a3f9b50e971adcbe63458ed3/lib/utils/lifecycle.js#L336\n    if (config.production) {\n      env.NODE_ENV = 'production';\n    }\n\n    // Note: npm_config_argv environment variable contains output of nopt - command-line\n    // parser used by npm. Since we use other parser, we just roughly emulate it's output. (See: #684)\n    env.npm_config_argv = JSON.stringify({ remain: [], cooked: [config.commandName], original: [config.commandName] });\n\n    // add npm_package_*\n    const manifest = yield config.maybeReadManifest(cwd);\n    if (manifest) {\n      const queue = [['', manifest]];\n      while (queue.length) {\n        var _queue$pop = queue.pop(),\n            _queue$pop2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_queue$pop, 2);\n\n        const key = _queue$pop2[0],\n              val = _queue$pop2[1];\n\n        if (key[0] === '_') {\n          continue;\n        }\n\n        if (typeof val === 'object') {\n          for (const subKey in val) {\n            const completeKey = [key, subKey].filter(function (part) {\n              return !!part;\n            }).join('_');\n            queue.push([completeKey, val[subKey]]);\n          }\n        } else if (IGNORE_MANIFEST_KEYS.indexOf(key) < 0) {\n          let cleanVal = String(val);\n          if (cleanVal.indexOf('\\n') >= 0) {\n            cleanVal = JSON.stringify(cleanVal);\n          }\n          env[`npm_package_${key}`] = cleanVal;\n        }\n      }\n    }\n\n    // add npm_config_*\n    const keys = new Set([...Object.keys(config.registries.yarn.config), ...Object.keys(config.registries.npm.config)]);\n    for (const key of keys) {\n      if (key.match(/:_/) || IGNORE_CONFIG_KEYS.indexOf(key) >= 0) {\n        continue;\n      }\n\n      let val = config.getOption(key);\n\n      if (!val) {\n        val = '';\n      } else if (typeof val === 'number') {\n        val = '' + val;\n      } else if (typeof val !== 'string') {\n        val = JSON.stringify(val);\n      }\n\n      if (val.indexOf('\\n') >= 0) {\n        val = JSON.stringify(val);\n      }\n\n      const cleanKey = key.replace(/^_+/, '');\n      const envKey = `npm_config_${cleanKey}`.replace(/[^a-zA-Z0-9_]/g, '_');\n      env[envKey] = val;\n    }\n\n    return env;\n  });\n\n  return function makeEnv(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet executeLifecycleScript = exports.executeLifecycleScript = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, config, cwd, cmd, spinner) {\n    // if we don't have a spinner then pipe everything to the terminal\n    const stdio = spinner ? undefined : 'inherit';\n\n    const env = yield makeEnv(stage, cwd, config);\n\n    // split up the path\n    const pathParts = (env[(_constants || _load_constants()).ENV_PATH_KEY] || '').split(path.delimiter);\n\n    // add node-gyp\n    pathParts.unshift(path.join(__dirname, '..', '..', 'bin', 'node-gyp-bin'));\n\n    // add .bin folders to PATH\n    for (const registry of Object.keys((_index || _load_index()).registries)) {\n      const binFolder = path.join(config.registries[registry].folder, '.bin');\n      pathParts.unshift(path.join(config.linkFolder, binFolder));\n      pathParts.unshift(path.join(cwd, binFolder));\n    }\n\n    // join path back together\n    env[(_constants || _load_constants()).ENV_PATH_KEY] = pathParts.join(path.delimiter);\n\n    // get shell\n    const conf = { windowsVerbatimArguments: false };\n    let sh = 'sh';\n    let shFlag = '-c';\n    if (process.platform === 'win32') {\n      // cmd or command.com\n      sh = process.env.comspec || 'cmd';\n\n      // d - Ignore registry AutoRun commands\n      // s - Strip \" quote characters from command.\n      // c - Run Command and then terminate\n      shFlag = '/d /s /c';\n\n      // handle windows run scripts starting with a relative path\n      cmd = (0, (_fixCmdWinSlashes || _load_fixCmdWinSlashes()).fixCmdWinSlashes)(cmd);\n\n      // handle quotes properly in windows environments - https://github.com/nodejs/node/issues/5060\n      conf.windowsVerbatimArguments = true;\n    }\n\n    const stdout = yield (_child || _load_child()).spawn(sh, [shFlag, cmd], (0, (_extends2 || _load_extends()).default)({ cwd, env, stdio }, conf), function (data) {\n      if (spinner) {\n        const line = data.toString() // turn buffer into string\n        .trim() // trim whitespace\n        .split('\\n') // split into lines\n        .pop() // use only the last line\n        .replace(/\\t/g, ' '); // change tabs to spaces as they can interfere with the console\n\n        if (line) {\n          spinner.tick(line);\n        }\n      }\n    });\n\n    return { cwd, command: cmd, stdout };\n  });\n\n  return function executeLifecycleScript(_x4, _x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet execFromManifest = exports.execFromManifest = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (config, commandName, cwd) {\n    const pkg = yield config.maybeReadManifest(cwd);\n    if (!pkg || !pkg.scripts) {\n      return;\n    }\n\n    const cmd = pkg.scripts[commandName];\n    if (cmd) {\n      yield execCommand(commandName, config, cmd, cwd);\n    }\n  });\n\n  return function execFromManifest(_x9, _x10, _x11) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nlet execCommand = exports.execCommand = (() => {\n  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (stage, config, cmd, cwd) {\n    const reporter = config.reporter;\n\n    try {\n      reporter.command(cmd);\n      yield executeLifecycleScript(stage, config, cwd, cmd);\n      return Promise.resolve();\n    } catch (err) {\n      if (err instanceof (_errors || _load_errors()).SpawnError) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('commandFailed', err.EXIT_CODE));\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  return function execCommand(_x12, _x13, _x14, _x15) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _child;\n\nfunction _load_child() {\n  return _child = _interopRequireWildcard(require('./child.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../resolvers/index.js');\n}\n\nvar _fixCmdWinSlashes;\n\nfunction _load_fixCmdWinSlashes() {\n  return _fixCmdWinSlashes = require('./fix-cmd-win-slashes.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst IGNORE_MANIFEST_KEYS = ['readme'];\n\n// We treat these configs as internal, thus not expose them to process.env.\n// This helps us avoid some gyp issues when building native modules.\n// See https://github.com/yarnpkg/yarn/issues/2286.\nconst IGNORE_CONFIG_KEYS = ['lastUpdateCheck'];\n\nexports.default = executeLifecycleScript;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = _interopRequireDefault(require('./validate.js'));\n}\n\nvar _fix;\n\nfunction _load_fix() {\n  return _fix = _interopRequireDefault(require('./fix.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nexports.default = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (info, moduleLoc, config, isRoot) {\n    // create human readable name\n    const name = info.name,\n          version = info.version;\n\n    let human;\n    if (typeof name === 'string') {\n      human = name;\n    }\n    if (human && typeof version === 'string' && version) {\n      human += `@${version}`;\n    }\n    if (isRoot && info._loc) {\n      human = path.relative(config.cwd, info._loc);\n    }\n\n    function warn(msg) {\n      if (human) {\n        msg = `${human}: ${msg}`;\n      }\n      config.reporter.warn(msg);\n    }\n\n    yield (0, (_fix || _load_fix()).default)(info, moduleLoc, config.reporter, warn, config.looseSemver);\n    try {\n      (0, (_validate || _load_validate()).default)(info, isRoot, config.reporter, warn);\n    } catch (err) {\n      if (human) {\n        err.message = `${human}: ${err.message}`;\n      }\n      throw err;\n    }\n\n    return info;\n  });\n\n  return function (_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/fix.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toArray2;\n\nfunction _load_toArray() {\n  return _toArray2 = _interopRequireDefault(require('babel-runtime/helpers/toArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../resolvers/index.js');\n}\n\nvar _inferLicense;\n\nfunction _load_inferLicense() {\n  return _inferLicense = _interopRequireDefault(require('./infer-license.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst semver = require('semver');\nconst path = require('path');\nconst url = require('url');\n\nconst LICENSE_RENAMES = {\n  'MIT/X11': 'MIT',\n  X11: 'MIT'\n};\n\nexports.default = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (info, moduleLoc, reporter, warn, looseSemver) {\n    const files = yield (_fs || _load_fs()).readdir(moduleLoc);\n\n    // clean info.version\n    if (typeof info.version === 'string' && !semver.valid(info.version)) {\n      info.version = semver.clean(info.version, looseSemver) || info.version;\n    }\n\n    // if name or version aren't set then set them to empty strings\n    info.name = info.name || '';\n    info.version = info.version || '';\n\n    // if the man field is a string then coerce it to an array\n    if (typeof info.man === 'string') {\n      info.man = [info.man];\n    }\n\n    // if the keywords field is a string then split it on any whitespace\n    if (typeof info.keywords === 'string') {\n      info.keywords = info.keywords.split(/\\s+/g);\n    }\n\n    // if there's no contributors field but an authors field then expand it\n    if (!info.contributors && files.indexOf('AUTHORS') >= 0) {\n      const authorsFilepath = path.join(moduleLoc, 'AUTHORS');\n      const authorsFilestats = yield (_fs || _load_fs()).stat(authorsFilepath);\n      if (authorsFilestats.isFile()) {\n        let authors = yield (_fs || _load_fs()).readFile(authorsFilepath);\n        authors = authors.split(/\\r?\\n/g) // split on lines\n        .map(function (line) {\n          return line.replace(/^\\s*#.*$/, '').trim();\n        }) // remove comments\n        .filter(function (line) {\n          return !!line;\n        }); // remove empty lines\n        info.contributors = authors;\n      }\n    }\n\n    // expand people fields to objects\n    if (typeof info.author === 'string' || typeof info.author === 'object') {\n      info.author = (0, (_util || _load_util()).normalizePerson)(info.author);\n    }\n    if (Array.isArray(info.contributors)) {\n      info.contributors = info.contributors.map((_util || _load_util()).normalizePerson);\n    }\n    if (Array.isArray(info.maintainers)) {\n      info.maintainers = info.maintainers.map((_util || _load_util()).normalizePerson);\n    }\n\n    // if there's no readme field then load the README file from the cwd\n    if (!info.readme) {\n      const readmeCandidates = files.filter(function (filename) {\n        const lower = filename.toLowerCase();\n        return lower === 'readme' || lower.indexOf('readme.') === 0;\n      }).sort(function (filename1, filename2) {\n        // favor files with extensions\n        return filename2.indexOf('.') - filename1.indexOf('.');\n      });\n\n      for (const readmeFilename of readmeCandidates) {\n        const readmeFilepath = path.join(moduleLoc, readmeFilename);\n        const readmeFileStats = yield (_fs || _load_fs()).stat(readmeFilepath);\n        if (readmeFileStats.isFile()) {\n          info.readmeFilename = readmeFilename;\n          info.readme = yield (_fs || _load_fs()).readFile(readmeFilepath);\n          break;\n        }\n      }\n    }\n\n    // if there's no description then take the first paragraph from the readme\n    if (!info.description && info.readme) {\n      const desc = (0, (_util || _load_util()).extractDescription)(info.readme);\n      if (desc) {\n        info.description = desc;\n      }\n    }\n\n    // support array of engine keys\n    if (Array.isArray(info.engines)) {\n      const engines = {};\n      for (const str of info.engines) {\n        if (typeof str === 'string') {\n          var _str$trim$split = str.trim().split(/ +/g),\n              _str$trim$split2 = (0, (_toArray2 || _load_toArray()).default)(_str$trim$split);\n\n          const name = _str$trim$split2[0],\n                patternParts = _str$trim$split2.slice(1);\n\n          engines[name] = patternParts.join(' ');\n        }\n      }\n      info.engines = engines;\n    }\n\n    // if the repository field is a string then assume it's a git repo and expand it\n    if (typeof info.repository === 'string') {\n      info.repository = {\n        type: 'git',\n        url: info.repository\n      };\n    }\n\n    const repo = info.repository;\n\n    // explode info.repository.url if it's a hosted git shorthand\n    if (repo && typeof repo === 'object' && typeof repo.url === 'string') {\n      repo.url = (0, (_index || _load_index()).hostedGitFragmentToGitUrl)(repo.url, reporter);\n    }\n\n    // allow bugs to be specified as a string, expand it to an object with a single url prop\n    if (typeof info.bugs === 'string') {\n      info.bugs = { url: info.bugs };\n    }\n\n    // normalize homepage url to http\n    if (typeof info.homepage === 'string') {\n      const parts = url.parse(info.homepage);\n      parts.protocol = parts.protocol || 'http:';\n      if (parts.pathname && !parts.hostname) {\n        parts.hostname = parts.pathname;\n        parts.pathname = '';\n      }\n      info.homepage = url.format(parts);\n    }\n\n    // if the `bin` field is as string then expand it to an object with a single property\n    // based on the original `bin` field and `name field`\n    // { name: \"foo\", bin: \"cli.js\" } -> { name: \"foo\", bin: { foo: \"cli.js\" } }\n    if (typeof info.name === 'string' && typeof info.bin === 'string') {\n      // Remove scoped package name for consistency with NPM's bin field fixing behaviour\n      const name = info.name.replace(/^@[^\\/]+\\//, '');\n      info.bin = { [name]: info.bin };\n    }\n\n    // bundleDependencies is an alias for bundledDependencies\n    if (info.bundledDependencies) {\n      info.bundleDependencies = info.bundledDependencies;\n      delete info.bundledDependencies;\n    }\n\n    let scripts;\n\n    // dummy script object to shove file inferred scripts onto\n    if (info.scripts && typeof info.scripts === 'object') {\n      scripts = info.scripts;\n    } else {\n      scripts = {};\n    }\n\n    // if there's a server.js file and no start script then set it to `node server.js`\n    if (!scripts.start && files.indexOf('server.js') >= 0) {\n      scripts.start = 'node server.js';\n    }\n\n    // if there's a binding.gyp file and no install script then set it to `node-gyp rebuild`\n    if (!scripts.install && files.indexOf('binding.gyp') >= 0) {\n      scripts.install = 'node-gyp rebuild';\n    }\n\n    // set scripts if we've polluted the empty object\n    if (Object.keys(scripts).length) {\n      info.scripts = scripts;\n    }\n\n    const dirs = info.directories;\n\n    if (dirs && typeof dirs === 'object') {\n      const binDir = dirs.bin;\n\n      if (!info.bin && binDir && typeof binDir === 'string') {\n        const bin = info.bin = {};\n        const fullBinDir = path.join(moduleLoc, binDir);\n\n        if (yield (_fs || _load_fs()).exists(fullBinDir)) {\n          for (const scriptName of yield (_fs || _load_fs()).readdir(fullBinDir)) {\n            if (scriptName[0] === '.') {\n              continue;\n            }\n            bin[scriptName] = path.join('.', binDir, scriptName);\n          }\n        } else {\n          warn(reporter.lang('manifestDirectoryNotFound', binDir, info.name));\n        }\n      }\n\n      const manDir = dirs.man;\n\n      if (!info.man && typeof manDir === 'string') {\n        const man = info.man = [];\n        const fullManDir = path.join(moduleLoc, manDir);\n\n        if (yield (_fs || _load_fs()).exists(fullManDir)) {\n          for (const filename of yield (_fs || _load_fs()).readdir(fullManDir)) {\n            if (/^(.*?)\\.[0-9]$/.test(filename)) {\n              man.push(path.join('.', manDir, filename));\n            }\n          }\n        } else {\n          warn(reporter.lang('manifestDirectoryNotFound', manDir, info.name));\n        }\n      }\n    }\n\n    delete info.directories;\n\n    // normalize licenses field\n    const licenses = info.licenses;\n    if (Array.isArray(licenses) && !info.license) {\n      let licenseTypes = [];\n\n      for (let license of licenses) {\n        if (license && typeof license === 'object') {\n          license = license.type;\n        }\n        if (typeof license === 'string') {\n          licenseTypes.push(license);\n        }\n      }\n\n      licenseTypes = licenseTypes.filter((_util || _load_util()).isValidLicense);\n\n      if (licenseTypes.length === 1) {\n        info.license = licenseTypes[0];\n      } else if (licenseTypes.length) {\n        info.license = `(${licenseTypes.join(' OR ')})`;\n      }\n    }\n\n    const license = info.license;\n\n    // normalize license\n    if (license && typeof license === 'object') {\n      info.license = license.type;\n    }\n\n    // get license file\n    const licenseFile = files.find(function (filename) {\n      const lower = filename.toLowerCase();\n      return lower === 'license' || lower.startsWith('license.') || lower === 'unlicense' || lower.startsWith('unlicense.');\n    });\n    if (licenseFile) {\n      const licenseFilepath = path.join(moduleLoc, licenseFile);\n      const licenseFileStats = yield (_fs || _load_fs()).stat(licenseFilepath);\n      if (licenseFileStats.isFile()) {\n        const licenseContent = yield (_fs || _load_fs()).readFile(licenseFilepath);\n        const inferredLicense = (0, (_inferLicense || _load_inferLicense()).default)(licenseContent);\n        info.licenseText = licenseContent;\n\n        const license = info.license;\n\n        if (typeof license === 'string') {\n          if (inferredLicense && (0, (_util || _load_util()).isValidLicense)(inferredLicense) && !(0, (_util || _load_util()).isValidLicense)(license)) {\n            // some packages don't specify their license version but we can infer it based on their license file\n            const basicLicense = license.toLowerCase().replace(/(-like|\\*)$/g, '');\n            const expandedLicense = inferredLicense.toLowerCase();\n            if (expandedLicense.startsWith(basicLicense)) {\n              // TODO consider doing something to notify the user\n              info.license = inferredLicense;\n            }\n          }\n        } else if (inferredLicense) {\n          // if there's no license then infer it based on the license file\n          info.license = inferredLicense;\n        } else {\n          // valid expression to refer to a license in a file\n          info.license = `SEE LICENSE IN ${licenseFile}`;\n        }\n      }\n    }\n\n    if (typeof info.license === 'string') {\n      // sometimes licenses are known by different names, reduce them\n      info.license = LICENSE_RENAMES[info.license] || info.license;\n    } else if (typeof info.readme === 'string') {\n      // the license might be at the bottom of the README\n      const inferredLicense = (0, (_inferLicense || _load_inferLicense()).default)(info.readme);\n      if (inferredLicense) {\n        info.license = inferredLicense;\n      }\n    }\n  });\n\n  return function (_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n})();","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/util.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidLicense = isValidLicense;\nexports.stringifyPerson = stringifyPerson;\nexports.parsePerson = parsePerson;\nexports.normalizePerson = normalizePerson;\nexports.extractDescription = extractDescription;\nexports.extractRepositoryUrl = extractRepositoryUrl;\n\n\nconst validateLicense = require('validate-npm-package-license');\n\nfunction isValidLicense(license) {\n  return !!license && validateLicense(license).validForNewPackages;\n}\n\nfunction stringifyPerson(person) {\n  if (!person || typeof person !== 'object') {\n    return person;\n  }\n\n  const parts = [];\n  if (person.name) {\n    parts.push(person.name);\n  }\n\n  const email = person.email || person.mail;\n  if (typeof email === 'string') {\n    parts.push(`<${email}>`);\n  }\n\n  const url = person.url || person.web;\n  if (typeof url === 'string') {\n    parts.push(`(${url})`);\n  }\n\n  return parts.join(' ');\n}\n\nfunction parsePerson(person) {\n  if (typeof person !== 'string') {\n    return person;\n  }\n\n  // format: name (url) <email>\n  const obj = {};\n\n  let name = person.match(/^([^\\(<]+)/);\n  if (name) {\n    name = name[0].trim();\n    if (name) {\n      obj.name = name;\n    }\n  }\n\n  const email = person.match(/<([^>]+)>/);\n  if (email) {\n    obj.email = email[1];\n  }\n\n  const url = person.match(/\\(([^\\)]+)\\)/);\n  if (url) {\n    obj.url = url[1];\n  }\n\n  return obj;\n}\n\nfunction normalizePerson(person) {\n  return parsePerson(stringifyPerson(person));\n}\n\nfunction extractDescription(readme) {\n  if (typeof readme !== 'string' || readme === '') {\n    return undefined;\n  }\n\n  // split into lines\n  const lines = readme.trim().split('\\n').map(line => line.trim());\n\n  // find the start of the first paragraph, ignore headings\n  let start = 0;\n  for (; start < lines.length; start++) {\n    const line = lines[start];\n    if (line && line.match(/^(#|$)/)) {\n      // line isn't empty and isn't a heading so this is the start of a paragraph\n      start++;\n      break;\n    }\n  }\n\n  // skip newlines from the header to the first line\n  while (start < lines.length && !lines[start]) {\n    start++;\n  }\n\n  // continue to the first non empty line\n  let end = start;\n  while (end < lines.length && lines[end]) {\n    end++;\n  }\n\n  return lines.slice(start, end).join(' ');\n}\n\nfunction extractRepositoryUrl(repository) {\n  if (!repository || typeof repository !== 'object') {\n    return repository;\n  }\n  return repository.url;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hostedGit = exports.exotics = exports.registries = undefined;\nexports.hostedGitFragmentToGitUrl = hostedGitFragmentToGitUrl;\n\nvar _npmResolver;\n\nfunction _load_npmResolver() {\n  return _npmResolver = _interopRequireDefault(require('./registries/npm-resolver.js'));\n}\n\nvar _yarnResolver;\n\nfunction _load_yarnResolver() {\n  return _yarnResolver = _interopRequireDefault(require('./registries/yarn-resolver.js'));\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./exotics/git-resolver.js'));\n}\n\nvar _tarballResolver;\n\nfunction _load_tarballResolver() {\n  return _tarballResolver = _interopRequireDefault(require('./exotics/tarball-resolver.js'));\n}\n\nvar _githubResolver;\n\nfunction _load_githubResolver() {\n  return _githubResolver = _interopRequireDefault(require('./exotics/github-resolver.js'));\n}\n\nvar _fileResolver;\n\nfunction _load_fileResolver() {\n  return _fileResolver = _interopRequireDefault(require('./exotics/file-resolver.js'));\n}\n\nvar _gitlabResolver;\n\nfunction _load_gitlabResolver() {\n  return _gitlabResolver = _interopRequireDefault(require('./exotics/gitlab-resolver.js'));\n}\n\nvar _gistResolver;\n\nfunction _load_gistResolver() {\n  return _gistResolver = _interopRequireDefault(require('./exotics/gist-resolver.js'));\n}\n\nvar _bitbucketResolver;\n\nfunction _load_bitbucketResolver() {\n  return _bitbucketResolver = _interopRequireDefault(require('./exotics/bitbucket-resolver.js'));\n}\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = require('./exotics/hosted-git-resolver.js');\n}\n\nvar _registryResolver;\n\nfunction _load_registryResolver() {\n  return _registryResolver = _interopRequireDefault(require('./exotics/registry-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst registries = exports.registries = {\n  npm: (_npmResolver || _load_npmResolver()).default,\n  yarn: (_yarnResolver || _load_yarnResolver()).default\n};\n\n//\n\nconst exotics = exports.exotics = {\n  git: (_gitResolver || _load_gitResolver()).default,\n  tarball: (_tarballResolver || _load_tarballResolver()).default,\n  github: (_githubResolver || _load_githubResolver()).default,\n  file: (_fileResolver || _load_fileResolver()).default,\n  gitlab: (_gitlabResolver || _load_gitlabResolver()).default,\n  gist: (_gistResolver || _load_gistResolver()).default,\n  bitbucket: (_bitbucketResolver || _load_bitbucketResolver()).default\n};\n\n//\n\nconst hostedGit = exports.hostedGit = {\n  github: (_githubResolver || _load_githubResolver()).default,\n  gitlab: (_gitlabResolver || _load_gitlabResolver()).default,\n  bitbucket: (_bitbucketResolver || _load_bitbucketResolver()).default\n};\n\nfunction hostedGitFragmentToGitUrl(fragment, reporter) {\n  for (const key in hostedGit) {\n    const Resolver = hostedGit[key];\n    if (Resolver.isVersion(fragment)) {\n      return Resolver.getGitHTTPUrl((0, (_hostedGitResolver || _load_hostedGitResolver()).explodeHostedGitFragment)(fragment, reporter));\n    }\n  }\n\n  return fragment;\n}\n\n//\n\nfor (const key in registries) {\n  var _class, _temp;\n\n  const RegistryResolver = registries[key];\n\n  exotics[key] = (_temp = _class = class extends (_registryResolver || _load_registryResolver()).default {}, _class.protocol = key, _class.factory = RegistryResolver, _temp);\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/registries/npm-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _registryResolver;\n\nfunction _load_registryResolver() {\n  return _registryResolver = _interopRequireDefault(require('./registry-resolver.js'));\n}\n\nvar _npmRegistry;\n\nfunction _load_npmRegistry() {\n  return _npmRegistry = _interopRequireDefault(require('../../registries/npm-registry.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('../../util/map.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../../constants.js');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst inquirer = require('inquirer');\n\nconst tty = require('tty');\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst NPM_REGISTRY = /http[s]:\\/\\/registry.npmjs.org/g;\n\nclass NpmResolver extends (_registryResolver || _load_registryResolver()).default {\n\n  static findVersionInRegistryResponse(config, range, body, request) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (!body['dist-tags']) {\n        throw new (_errors || _load_errors()).MessageError(config.reporter.lang('malformedRegistryResponse', body.name));\n      }\n\n      if (range in body['dist-tags']) {\n        range = body['dist-tags'][range];\n      }\n\n      const satisfied = yield config.resolveConstraints(Object.keys(body.versions), range);\n      if (satisfied) {\n        return body.versions[satisfied];\n      } else if (request && !config.nonInteractive) {\n        if (request.resolver && request.resolver.activity) {\n          request.resolver.activity.end();\n        }\n        config.reporter.log(config.reporter.lang('couldntFindVersionThatMatchesRange', body.name, range));\n        let pageSize;\n        if (process.stdout instanceof tty.WriteStream) {\n          pageSize = process.stdout.rows - 2;\n        }\n        const response = yield inquirer.prompt([{\n          name: 'package',\n          type: 'list',\n          message: config.reporter.lang('chooseVersionFromList'),\n          choices: Object.keys(body.versions).reverse(),\n          pageSize\n        }]);\n        if (response && response.package) {\n          return body.versions[response.package];\n        }\n      }\n      throw new (_errors || _load_errors()).MessageError(config.reporter.lang('couldntFindVersionThatMatchesRange', body.name, range));\n    })();\n  }\n\n  resolveRequest() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (_this.config.offline) {\n        const res = _this.resolveRequestOffline();\n        if (res != null) {\n          return res;\n        }\n      }\n\n      const body = yield _this.config.registries.npm.request((_npmRegistry || _load_npmRegistry()).default.escapeName(_this.name));\n\n      if (body) {\n        return yield NpmResolver.findVersionInRegistryResponse(_this.config, _this.range, body, _this.request);\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  resolveRequestOffline() {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n\n      const scope = _this2.config.registries.npm.getScope(_this2.name);\n      // find modules of this name\n      const prefix = scope ? _this2.name.split(/\\/|%2f/)[1] : `npm-${_this2.name}-`;\n\n      invariant(_this2.config.cacheFolder, 'expected packages root');\n      const cacheFolder = path.join(_this2.config.cacheFolder, scope ? 'npm-' + scope : '');\n\n      const files = yield _this2.config.getCache('cachedPackages', (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n        const files = yield (_fs || _load_fs()).readdir(cacheFolder);\n        const validFiles = [];\n\n        for (const name of files) {\n          // no hidden files\n          if (name[0] === '.') {\n            continue;\n          }\n\n          // ensure valid module cache\n          const dir = path.join(cacheFolder, name);\n          if (yield _this2.config.isValidModuleDest(dir)) {\n            validFiles.push(name);\n          }\n        }\n\n        return validFiles;\n      }));\n\n      const versions = (0, (_map || _load_map()).default)();\n\n      for (const name of files) {\n        // check if folder starts with our prefix\n        if (name.indexOf(prefix) !== 0) {\n          continue;\n        }\n\n        const dir = path.join(cacheFolder, name);\n\n        // read manifest and validate correct name\n        const pkg = yield _this2.config.readManifest(dir, 'npm');\n        if (pkg.name !== _this2.name) {\n          continue;\n        }\n\n        // read package metadata\n        const metadata = yield _this2.config.readPackageMetadata(dir);\n        if (!metadata.remote) {\n          continue; // old yarn metadata\n        }\n\n        versions[pkg.version] = Object.assign({}, pkg, { _remote: metadata.remote });\n      }\n\n      const satisfied = yield _this2.config.resolveConstraints(Object.keys(versions), _this2.range);\n      if (satisfied) {\n        return versions[satisfied];\n      } else if (!_this2.config.preferOffline) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('couldntFindPackageInCache', _this2.name, _this2.range, Object.keys(versions).join(', ')));\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  cleanRegistry(url) {\n    if (this.config.getOption('registry') === (_constants || _load_constants()).YARN_REGISTRY) {\n      return url.replace(NPM_REGISTRY, (_constants || _load_constants()).YARN_REGISTRY);\n    } else {\n      return url;\n    }\n  }\n\n  resolve() {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // lockfile\n      const shrunk = _this3.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const info = yield _this3.resolveRequest();\n      if (info == null) {\n        throw new (_errors || _load_errors()).MessageError(_this3.reporter.lang('packageNotFoundRegistry', _this3.name, 'npm'));\n      }\n\n      const deprecated = info.deprecated,\n            dist = info.dist;\n\n      if (typeof deprecated === 'string') {\n        let human = `${info.name}@${info.version}`;\n        const parentNames = _this3.request.getParentNames();\n        if (parentNames.length) {\n          human = parentNames.concat(human).join(' > ');\n        }\n        _this3.reporter.warn(`${human}: ${deprecated}`);\n      }\n\n      if (dist != null && dist.tarball) {\n        info._remote = {\n          resolved: `${_this3.cleanRegistry(dist.tarball)}#${dist.shasum}`,\n          type: 'tarball',\n          reference: _this3.cleanRegistry(dist.tarball),\n          hash: dist.shasum,\n          registry: 'npm'\n        };\n      }\n\n      info._uid = info.version;\n\n      return info;\n    })();\n  }\n}\nexports.default = NpmResolver;\nNpmResolver.registry = 'npm';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/registries/registry-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _baseResolver;\n\nfunction _load_baseResolver() {\n  return _baseResolver = _interopRequireDefault(require('../base-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass RegistryResolver extends (_baseResolver || _load_baseResolver()).default {\n  constructor(request, name, range) {\n    super(request, `${name}@${range}`);\n    this.name = name;\n    this.range = range;\n\n    this.registryConfig = request.config.registries[this.constructor.registry].config;\n  }\n\n}\nexports.default = RegistryResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/registries/yarn-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _npmResolver;\n\nfunction _load_npmResolver() {\n  return _npmResolver = _interopRequireDefault(require('./npm-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass YarnResolver extends (_npmResolver || _load_npmResolver()).default {}\nexports.default = YarnResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/git-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../index.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('../../util/version.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('../../registries/index.js');\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _git;\n\nfunction _load_git() {\n  return _git = _interopRequireDefault(require('../../util/git.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst urlParse = require('url').parse;\n\nconst urlFormat = require('url').format;\n\n// we purposefully omit https and http as those are only valid if they end in the .git extension\nconst GIT_PROTOCOLS = ['git:', 'git+ssh:', 'git+https:', 'ssh:'];\n\nconst GIT_HOSTS = ['github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org'];\n\nclass GitResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    var _versionUtil$explodeH = (_version || _load_version()).explodeHashedUrl(fragment);\n\n    const url = _versionUtil$explodeH.url,\n          hash = _versionUtil$explodeH.hash;\n\n    this.url = url;\n    this.hash = hash;\n  }\n\n  static isVersion(pattern) {\n    const parts = urlParse(pattern);\n\n    // this pattern hasn't been exploded yet, we'll hit this code path again later once\n    // we've been normalized #59\n    if (!parts.protocol) {\n      return false;\n    }\n\n    const pathname = parts.pathname;\n    if (pathname && pathname.endsWith('.git')) {\n      // ends in .git\n      return true;\n    }\n\n    if (GIT_PROTOCOLS.indexOf(parts.protocol) >= 0) {\n      return true;\n    }\n\n    if (parts.hostname && parts.path) {\n      const path = parts.path;\n      if (GIT_HOSTS.indexOf(parts.hostname) >= 0) {\n        // only if dependency is pointing to a git repo,\n        // e.g. facebook/flow and not file in a git repo facebook/flow/archive/v1.0.0.tar.gz\n        return path.split('/').filter(p => !!p).length === 2;\n      }\n    }\n\n    return false;\n  }\n\n  // This transformUrl util is here to replace colon separators in the pathname\n  // from private urls. It takes the url parts retrieved using urlFormat and\n  // returns the associated url. Related to #573, introduced in #2519.\n  static transformUrl(parts) {\n    const pathname = parts.pathname ? parts.pathname.replace(/^\\/:/, '/') : '';\n    return urlFormat((0, (_extends2 || _load_extends()).default)({}, parts, { pathname }));\n  }\n\n  resolve(forked) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let tryRegistry = (() => {\n        var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (registry) {\n          const filename = (_index2 || _load_index2()).registries[registry].filename;\n\n          const file = yield client.getFile(filename);\n          if (!file) {\n            return null;\n          }\n\n          const json = yield config.readJson(`${transformedUrl}/${filename}`, function () {\n            return JSON.parse(file);\n          });\n          json._uid = commit;\n          json._remote = {\n            resolved: `${transformedUrl}#${commit}`,\n            type: 'git',\n            reference: transformedUrl,\n            hash: commit,\n            registry\n          };\n          return json;\n        });\n\n        return function tryRegistry(_x) {\n          return _ref.apply(this, arguments);\n        };\n      })();\n\n      const url = _this.url;\n\n      // shortcut for hosted git. we will fallback to a GitResolver if the hosted git\n      // optimisations fail which the `forked` flag indicates so we don't get into an\n      // infinite loop\n\n      const parts = urlParse(url);\n      if (false && !forked && !parts.auth && parts.pathname) {\n        // check if this git url uses any of the hostnames defined in our hosted git resolvers\n        for (const name in (_index || _load_index()).hostedGit) {\n          const Resolver = (_index || _load_index()).hostedGit[name];\n          if (Resolver.hostname !== parts.hostname) {\n            continue;\n          }\n\n          // we have a match! clean up the pathname of url artifacts\n          let pathname = parts.pathname;\n          pathname = (_misc || _load_misc()).removePrefix(pathname, '/'); // remove prefixed slash\n          pathname = (_misc || _load_misc()).removeSuffix(pathname, '.git'); // remove .git suffix if present\n\n          const url = `${pathname}${_this.hash ? '#' + decodeURIComponent(_this.hash) : ''}`;\n          return _this.fork(Resolver, false, url);\n        }\n      }\n\n      // get from lockfile\n      const shrunk = _this.request.getLocked('git');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const config = _this.config;\n\n\n      const transformedUrl = GitResolver.transformUrl(parts);\n\n      const client = new (_git || _load_git()).default(config, transformedUrl, _this.hash);\n      const commit = yield client.init();\n\n      const file = yield tryRegistry(_this.registry);\n      if (file) {\n        return file;\n      }\n\n      for (const registry in (_index2 || _load_index2()).registries) {\n        if (registry === _this.registry) {\n          continue;\n        }\n\n        const file = yield tryRegistry(registry);\n        if (file) {\n          return file;\n        }\n      }\n\n      throw new (_errors || _load_errors()).MessageError(_this.reporter.lang('couldntFindManifestIn', transformedUrl));\n    })();\n  }\n}\nexports.default = GitResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/exotic-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _baseResolver;\n\nfunction _load_baseResolver() {\n  return _baseResolver = _interopRequireDefault(require('../base-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ExoticResolver extends (_baseResolver || _load_baseResolver()).default {\n\n  static isVersion(pattern) {\n    const proto = this.protocol;\n    if (proto) {\n      return pattern.startsWith(`${proto}:`);\n    } else {\n      throw new Error('No protocol specified');\n    }\n  }\n}\nexports.default = ExoticResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/tarball-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _tarballFetcher;\n\nfunction _load_tarballFetcher() {\n  return _tarballFetcher = _interopRequireDefault(require('../../fetchers/tarball-fetcher.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../../util/misc.js');\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('../../util/version.js'));\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('../../util/crypto.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nclass TarballResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    var _versionUtil$explodeH = (_version || _load_version()).explodeHashedUrl(fragment);\n\n    const hash = _versionUtil$explodeH.hash,\n          url = _versionUtil$explodeH.url;\n\n    this.hash = hash;\n    this.url = url;\n  }\n\n  static isVersion(pattern) {\n    // we can sometimes match git urls which we don't want\n    if ((_gitResolver || _load_gitResolver()).default.isVersion(pattern)) {\n      return false;\n    }\n\n    // full http url\n    if (pattern.startsWith('http://') || pattern.startsWith('https://')) {\n      return true;\n    }\n\n    // local file reference - ignore patterns with names\n    if (pattern.indexOf('@') < 0) {\n      if (pattern.endsWith('.tgz') || pattern.endsWith('.tar.gz')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  resolve() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const shrunk = _this.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const url = (0, (_misc || _load_misc()).removePrefix)(_this.url, 'file:');\n      let hash = _this.hash,\n          registry = _this.registry;\n\n      let pkgJson;\n\n      // generate temp directory\n      const dest = _this.config.getTemp((_crypto || _load_crypto()).hash(url));\n\n      if (yield _this.config.isValidModuleDest(dest)) {\n        var _ref = yield _this.config.readPackageMetadata(dest);\n        // load from local cache\n\n\n        pkgJson = _ref.package;\n        hash = _ref.hash;\n        registry = _ref.registry;\n      } else {\n        // delete if invalid\n        yield (_fs || _load_fs()).unlink(dest);\n\n        const fetcher = new (_tarballFetcher || _load_tarballFetcher()).default(dest, {\n          type: 'tarball',\n          reference: url,\n          registry,\n          hash\n        }, _this.config, false);\n\n        // fetch file and get it's hash\n        const fetched = yield fetcher.fetch();\n        pkgJson = fetched.package;\n        hash = fetched.hash;\n\n        registry = pkgJson._registry;\n        invariant(registry, 'expected registry');\n      }\n\n      // use the commit/tarball hash as the uid as we can't rely on the version as it's not\n      // in the registry\n      pkgJson._uid = hash;\n\n      // set remote so it can be \"fetched\"\n      pkgJson._remote = {\n        type: 'copy',\n        resolved: `${url}#${hash}`,\n        hash,\n        registry,\n        reference: dest\n      };\n\n      return pkgJson;\n    })();\n  }\n}\nexports.default = TarballResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/github-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass GitHubResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static isVersion(pattern) {\n    // github proto\n    if (pattern.startsWith('github:')) {\n      return true;\n    }\n\n    // github shorthand\n    if (/^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(pattern)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  static getTarballUrl(parts, hash) {\n    return `https://codeload.${this.hostname}/${parts.user}/${parts.repo}/tar.gz/${hash}`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://raw.githubusercontent.com/${parts.user}/${parts.repo}/${commit}/${filename}`;\n  }\n}\nexports.default = GitHubResolver;\nGitHubResolver.protocol = 'github';\nGitHubResolver.hostname = 'github.com';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/hosted-git-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nexports.explodeHostedGitFragment = explodeHostedGitFragment;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = require('../../registries/index.js');\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _git;\n\nfunction _load_git() {\n  return _git = _interopRequireDefault(require('../../util/git.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction explodeHostedGitFragment(fragment, reporter) {\n\n  const preParts = fragment.split('@');\n  if (preParts.length > 2) {\n    fragment = preParts[1] + '@' + preParts[2];\n  }\n\n  const parts = fragment.split(':');\n\n  if (parts.length == 3) {\n    // protocol + host + folder\n    parts[1] = parts[1].indexOf('//') >= 0 ? parts[1].substr(2) : parts[1];\n    fragment = parts[1] + '/' + parts[2];\n  } else if (parts.length == 2) {\n    if (parts[0].indexOf('@') == -1) {\n      // protocol + host\n      fragment = parts[1];\n    } else {\n      // host + folder\n      fragment = parts[0] + '/' + parts[1];\n    }\n  } else if (parts.length == 1) {\n    fragment = parts[0];\n  } else {\n    throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidHostedGitFragment', fragment));\n  }\n\n  const userParts = fragment.split('/');\n\n  if (userParts.length >= 2) {\n\n    if (userParts[0].indexOf('@') >= 0) {\n      userParts.shift();\n    }\n\n    const user = userParts.shift();\n    const repoParts = userParts.join('/').split(/(?:[.]git)?#(.*)/);\n\n    if (repoParts.length <= 3) {\n      return {\n        user,\n        repo: repoParts[0].replace('.git', ''),\n        hash: repoParts[1] || ''\n      };\n    }\n  }\n\n  throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidHostedGitFragment', fragment));\n}\n\nclass HostedGitResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    const exploded = this.exploded = explodeHostedGitFragment(fragment, this.reporter);\n    const user = exploded.user,\n          repo = exploded.repo,\n          hash = exploded.hash;\n\n    this.user = user;\n    this.repo = repo;\n    this.hash = hash;\n  }\n\n  static getTarballUrl(exploded, commit) {\n    exploded;\n    commit;\n    throw new Error('Not implemented');\n  }\n\n  static getGitHTTPUrl(exploded) {\n    exploded;\n    throw new Error('Not implemented');\n  }\n\n  static getGitSSHUrl(exploded) {\n    exploded;\n    throw new Error('Not implemented');\n  }\n\n  static getHTTPFileUrl(exploded, filename, commit) {\n    exploded;\n    filename;\n    commit;\n    throw new Error('Not implemented');\n  }\n\n  getRefOverHTTP(url) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const client = new (_git || _load_git()).default(_this.config, url, _this.hash);\n\n      let out = yield _this.config.requestManager.request({\n        url: `${url}/info/refs?service=git-upload-pack`,\n        queue: _this.resolver.fetchingQueue\n      });\n\n      if (out) {\n        // clean up output\n        let lines = out.trim().split('\\n');\n\n        // remove first two lines which contains compatibility info etc\n        lines = lines.slice(2);\n\n        // remove last line which contains the terminator \"0000\"\n        lines.pop();\n\n        // remove line lengths from start of each line\n        lines = lines.map(function (line) {\n          return line.slice(4);\n        });\n\n        out = lines.join('\\n');\n      } else {\n        throw new Error(_this.reporter.lang('hostedGitResolveError'));\n      }\n\n      const refs = (_git || _load_git()).default.parseRefs(out);\n      return yield client.setRef(refs);\n    })();\n  }\n\n  resolveOverHTTP(url) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const shrunk = _this2.request.getLocked('tarball');\n      if (shrunk) {\n        return shrunk;\n      }\n\n      const commit = yield _this2.getRefOverHTTP(url);\n      const config = _this2.config;\n\n\n      const tryRegistry = (() => {\n        var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (registry) {\n          const filename = (_index || _load_index()).registries[registry].filename;\n\n          const href = _this2.constructor.getHTTPFileUrl(_this2.exploded, filename, commit);\n          const file = yield config.requestManager.request({\n            url: href,\n            queue: _this2.resolver.fetchingQueue\n          });\n          if (!file) {\n            return null;\n          }\n\n          const tarballUrl = _this2.constructor.getTarballUrl(_this2.exploded, commit);\n          const json = yield config.readJson(href, function () {\n            return JSON.parse(file);\n          });\n          json._uid = commit;\n          json._remote = {\n            resolved: tarballUrl,\n            type: 'tarball',\n            reference: tarballUrl,\n            registry\n          };\n          return json;\n        });\n\n        return function tryRegistry(_x) {\n          return _ref.apply(this, arguments);\n        };\n      })();\n\n      const file = yield tryRegistry(_this2.registry);\n      if (file) {\n        return file;\n      }\n\n      for (const registry in (_index || _load_index()).registries) {\n        if (registry === _this2.registry) {\n          continue;\n        }\n\n        const file = yield tryRegistry(registry);\n        if (file) {\n          return file;\n        }\n      }\n\n      throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('couldntFindManifestIn', url));\n    })();\n  }\n\n  hasHTTPCapability(url) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      return (yield _this3.config.requestManager.request({\n        url,\n        method: 'HEAD',\n        queue: _this3.resolver.fetchingQueue,\n        followRedirect: false\n      })) !== false;\n    })();\n  }\n\n  resolve() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const httpUrl = _this4.constructor.getGitHTTPUrl(_this4.exploded);\n      const sshUrl = _this4.constructor.getGitSSHUrl(_this4.exploded);\n\n      // If we can access the files over HTTP then we should as it's MUCH faster than git\n      // archive and tarball unarchiving. The HTTP API is only available for public repos\n      // though.\n      if (yield _this4.hasHTTPCapability(httpUrl)) {\n        return yield _this4.resolveOverHTTP(httpUrl);\n      }\n\n      // If the url is accessible over git archive then we should immediately delegate to\n      // the git resolver.\n      //\n      // NOTE: Here we use a different url than when we delegate to the git resolver later on.\n      // This is because `git archive` requires access over ssh and github only allows that\n      // if you have write permissions\n      if (yield (_git || _load_git()).default.hasArchiveCapability(sshUrl)) {\n        const archiveClient = new (_git || _load_git()).default(_this4.config, sshUrl, _this4.hash);\n        const commit = yield archiveClient.init();\n        return yield _this4.fork((_gitResolver || _load_gitResolver()).default, true, `${sshUrl}#${commit}`);\n      }\n\n      // fallback to the plain git resolver\n      return yield _this4.fork((_gitResolver || _load_gitResolver()).default, true, sshUrl);\n    })();\n  }\n}\nexports.default = HostedGitResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/file-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../../util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nclass FileResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n    this.loc = (_misc || _load_misc()).removePrefix(fragment, 'file:');\n  }\n\n  resolve() {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let loc = _this.loc;\n      if (!path.isAbsolute(loc)) {\n        loc = path.join(_this.config.cwd, loc);\n      }\n      if (!(yield (_fs || _load_fs()).exists(loc))) {\n        throw new (_errors || _load_errors()).MessageError(_this.reporter.lang('doesntExist', loc));\n      }\n\n      const manifest = yield _this.config.readManifest(loc, _this.registry);\n      const registry = manifest._registry;\n      invariant(registry, 'expected registry');\n\n      manifest._remote = {\n        type: 'copy',\n        registry,\n        hash: null,\n        reference: loc\n      };\n\n      manifest._uid = manifest.version;\n\n      // Normalize relative paths; if anything changes, make a copy of the manifest\n      const dependencies = _this.normalizeDependencyPaths(manifest.dependencies, loc);\n      const optionalDependencies = _this.normalizeDependencyPaths(manifest.optionalDependencies, loc);\n\n      if (dependencies !== manifest.dependencies || optionalDependencies !== manifest.optionalDependencies) {\n        const _manifest = Object.assign({}, manifest);\n        if (dependencies != null) {\n          _manifest.dependencies = dependencies;\n        }\n        if (optionalDependencies != null) {\n          _manifest.optionalDependencies = optionalDependencies;\n        }\n        return _manifest;\n      } else {\n        return manifest;\n      }\n    })();\n  }\n\n  normalizeDependencyPaths(section, loc) {\n    if (section == null) {\n      return section;\n    }\n\n    let temp = section;\n\n    for (const _ref of (_misc || _load_misc()).entries(section)) {\n      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n      const k = _ref2[0];\n      const v = _ref2[1];\n\n      if (typeof v === 'string' && v.startsWith('file:') && !path.isAbsolute(v)) {\n        if (temp === section) {\n          temp = Object.assign({}, section);\n        }\n        temp[k] = `file:${path.relative(this.config.cwd, path.join(loc, (_misc || _load_misc()).removePrefix(v, 'file:')))}`;\n      }\n    }\n\n    return temp;\n  }\n}\nexports.default = FileResolver;\nFileResolver.protocol = 'file';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/gitlab-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass GitLabResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static getTarballUrl(parts, hash) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/repository/archive.tar.gz?ref=${hash}`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/raw/${commit}/${filename}`;\n  }\n}\nexports.default = GitLabResolver;\nGitLabResolver.hostname = 'gitlab.com';\nGitLabResolver.protocol = 'gitlab';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/gist-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explodeGistFragment = explodeGistFragment;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _gitResolver;\n\nfunction _load_gitResolver() {\n  return _gitResolver = _interopRequireDefault(require('./git-resolver.js'));\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = _interopRequireWildcard(require('../../util/misc.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction explodeGistFragment(fragment, reporter) {\n  fragment = (_misc || _load_misc()).removePrefix(fragment, 'gist:');\n\n  const parts = fragment.split('#');\n\n  if (parts.length <= 2) {\n    return {\n      id: parts[0],\n      hash: parts[1] || ''\n    };\n  } else {\n    throw new (_errors || _load_errors()).MessageError(reporter.lang('invalidGistFragment', fragment));\n  }\n}\n\nclass GistResolver extends (_exoticResolver || _load_exoticResolver()).default {\n\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    var _explodeGistFragment = explodeGistFragment(fragment, this.reporter);\n\n    const id = _explodeGistFragment.id,\n          hash = _explodeGistFragment.hash;\n\n    this.id = id;\n    this.hash = hash;\n  }\n\n  resolve() {\n    return this.fork((_gitResolver || _load_gitResolver()).default, false, `https://gist.github.com/${this.id}.git#${this.hash}`);\n  }\n}\nexports.default = GistResolver;\nGistResolver.protocol = 'gist';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/bitbucket-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hostedGitResolver;\n\nfunction _load_hostedGitResolver() {\n  return _hostedGitResolver = _interopRequireDefault(require('./hosted-git-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass BitbucketResolver extends (_hostedGitResolver || _load_hostedGitResolver()).default {\n\n  static getTarballUrl(parts, hash) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/get/${hash}.tar.gz`;\n  }\n\n  static getGitHTTPUrl(parts) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}.git`;\n  }\n\n  static getGitSSHUrl(parts) {\n    return `git+ssh://git@${this.hostname}/${parts.user}/${parts.repo}.git` + `${parts.hash ? '#' + decodeURIComponent(parts.hash) : ''}`;\n  }\n\n  static getHTTPFileUrl(parts, filename, commit) {\n    return `https://${this.hostname}/${parts.user}/${parts.repo}/raw/${commit}/${filename}`;\n  }\n}\nexports.default = BitbucketResolver;\nBitbucketResolver.hostname = 'bitbucket.org';\nBitbucketResolver.protocol = 'bitbucket';","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/resolvers/exotics/registry-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _exoticResolver;\n\nfunction _load_exoticResolver() {\n  return _exoticResolver = _interopRequireDefault(require('./exotic-resolver.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass RegistryResolver extends (_exoticResolver || _load_exoticResolver()).default {\n  constructor(request, fragment) {\n    super(request, fragment);\n\n    const match = fragment.match(/^(\\S+):(.*?)(@(.*?)|)$/);\n    if (match) {\n      this.range = match[4] || 'latest';\n      this.name = match[2];\n    } else {\n      throw new (_errors || _load_errors()).MessageError(this.reporter.lang('invalidFragment', fragment));\n    }\n\n    // $FlowFixMe\n    this.registry = this.constructor.protocol;\n  }\n\n  resolve() {\n    return this.fork(this.constructor.factory, false, this.name, this.range);\n  }\n}\nexports.default = RegistryResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/infer-license.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inferLicense;\n\nvar _licenses;\n\nfunction _load_licenses() {\n  return _licenses = _interopRequireDefault(require('./licenses.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction clean(str) {\n  return str.replace(/[^A-Za-z\\s]/g, ' ').replace(/[\\s]+/g, ' ').trim().toLowerCase();\n}\n\nconst REGEXES = {\n  Unlicense: [/http:\\/\\/unlicense.org\\//],\n  WTFPL: [/DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE/, /WTFPL\\b/],\n  ISC: [/The ISC License/, /ISC\\b/],\n  Apache: [/Apache License\\b/],\n  MIT: [/MIT\\b/],\n  BSD: [/BSD\\b/]\n};\n\nfunction inferLicense(license) {\n  // check if we have any explicit licenses\n  const cleanLicense = clean(license);\n  for (const licenseName in (_licenses || _load_licenses()).default) {\n    const testLicense = (_licenses || _load_licenses()).default[licenseName];\n    if (cleanLicense.search(testLicense) >= 0) {\n      return licenseName;\n    }\n  }\n\n  // infer based on some keywords\n  for (const licenseName in REGEXES) {\n    for (const regex of REGEXES[licenseName]) {\n      if (license.search(regex) >= 0) {\n        return `${licenseName}*`;\n      }\n    }\n  }\n\n  return null;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/licenses.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n\n/* eslint-disable max-len */\n\n/**\n * DO NOT EDIT THIS FILE MANUALLY.\n * THIS FILE WAS GENERATED BY \"generate-licenses-js.js\".\n */\n\nexports.default = {\n  'Apache-2.0': new RegExp('(licensed under the apache license version the license you may not use this file except in compliance with the license you may obtain a copy of the license at http www apache org licenses license unless required by applicable law or agreed to in writing software distributed under the license is distributed on an as is basis without warranties or conditions of any kind either express or implied see the license for the specific language governing permissions and limitations under the license$|apache license version january http www apache org licenses terms and conditions for use reproduction and distribution definitions license shall mean the terms and conditions for use reproduction and distribution as defined by sections through of this document licensor shall mean the copyright owner or entity authorized by the copyright owner that is granting the license legal entity shall mean the union of the acting entity and all other entities that control are controlled by or are under common control with that entity for the purposes of this definition control means i the power direct or indirect to cause the direction or management of such entity whether by contract or otherwise or ii ownership of fifty percent or more of the outstanding shares or iii beneficial ownership of such entity you or your shall mean an individual or legal entity exercising permissions granted by this license source form shall mean the preferred form for making modifications including but not limited to software source code documentation source and configuration files object form shall mean any form resulting from mechanical transformation or translation of a source form including but not limited to compiled object code generated documentation and conversions to other media types work shall mean the work of authorship whether in source or object form made available under the license as indicated by a copyright notice that is included in or attached to the work an example is provided in the appendix below derivative works shall mean any work whether in source or object form that is based on or derived from the work and for which the editorial revisions annotations elaborations or other modifications represent as a whole an original work of authorship for the purposes of this license derivative works shall not include works that remain separable from or merely link or bind by name to the interfaces of the work and derivative works thereof contribution shall mean any work of authorship including the original version of the work and any modifications or additions to that work or derivative works thereof that is intentionally submitted to licensor for inclusion in the work by the copyright owner or by an individual or legal entity authorized to submit on behalf of the copyright owner for the purposes of this definition submitted means any form of electronic verbal or written communication sent to the licensor or its representatives including but not limited to communication on electronic mailing lists source code control systems and issue tracking systems that are managed by or on behalf of the licensor for the purpose of discussing and improving the work but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as not a contribution contributor shall mean licensor and any individual or legal entity on behalf of whom a contribution has been received by licensor and subsequently incorporated within the work grant of copyright license subject to the terms and conditions of this license each contributor hereby grants to you a perpetual worldwide non exclusive no charge royalty free irrevocable copyright license to reproduce prepare derivative works of publicly display publicly perform sublicense and distribute the work and such derivative works in source or object form grant of patent license subject to the terms and conditions of this license each contributor hereby grants to you a perpetual worldwide non exclusive no charge royalty free irrevocable except as stated in this section patent license to make have made use offer to sell sell import and otherwise transfer the work where such license applies only to those patent claims licensable by such contributor that are necessarily infringed by their contribution s alone or by combination of their contribution s with the work to which such contribution s was submitted if you institute patent litigation against any entity including a cross claim or counterclaim in a lawsuit alleging that the work or a contribution incorporated within the work constitutes direct or contributory patent infringement then any patent licenses granted to you under this license for that work shall terminate as of the date such litigation is filed redistribution you may reproduce and distribute copies of the work or derivative works thereof in any medium with or without modifications and in source or object form provided that you meet the following conditions a you must give any other recipients of the work or derivative works a copy of this license and b you must cause any modified files to carry prominent notices stating that you changed the files and c you must retain in the source form of any derivative works that you distribute all copyright patent trademark and attribution notices from the source form of the work excluding those notices that do not pertain to any part of the derivative works and d if the work includes a notice text file as part of its distribution then any derivative works that you distribute must include a readable copy of the attribution notices contained within such notice file excluding those notices that do not pertain to any part of the derivative works in at least one of the following places within a notice text file distributed as part of the derivative works within the source form or documentation if provided along with the derivative works or within a display generated by the derivative works if and wherever such third party notices normally appear the contents of the notice file are for informational purposes only and do not modify the license you may add your own attribution notices within derivative works that you distribute alongside or as an addendum to the notice text from the work provided that such additional attribution notices cannot be construed as modifying the license you may add your own copyright statement to your modifications and may provide additional or different license terms and conditions for use reproduction or distribution of your modifications or for any such derivative works as a whole provided your use reproduction and distribution of the work otherwise complies with the conditions stated in this license submission of contributions unless you explicitly state otherwise any contribution intentionally submitted for inclusion in the work by you to the licensor shall be under the terms and conditions of this license without any additional terms or conditions notwithstanding the above nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with licensor regarding such contributions trademarks this license does not grant permission to use the trade names trademarks service marks or product names of the licensor except as required for reasonable and customary use in describing the origin of the work and reproducing the content of the notice file disclaimer of warranty unless required by applicable law or agreed to in writing licensor provides the work and each contributor provides its contributions on an as is basis without warranties or conditions of any kind either express or implied including without limitation any warranties or conditions of title non infringement merchantability or fitness for a particular purpose you are solely responsible for determining the appropriateness of using or redistributing the work and assume any risks associated with your exercise of permissions under this license limitation of liability in no event and under no legal theory whether in tort including negligence contract or otherwise unless required by applicable law such as deliberate and grossly negligent acts or agreed to in writing shall any contributor be liable to you for damages including any direct indirect special incidental or consequential damages of any character arising as a result of this license or out of the use or inability to use the work including but not limited to damages for loss of goodwill work stoppage computer failure or malfunction or any and all other commercial damages or losses even if such contributor has been advised of the possibility of such damages accepting warranty or additional liability while redistributing the work or derivative works thereof you may choose to offer and charge a fee for acceptance of support warranty indemnity or other liability obligations and or rights consistent with this license however in accepting such obligations you may act only on your own behalf and on your sole responsibility not on behalf of any other contributor and only if you agree to indemnify defend and hold each contributor harmless for any liability incurred by or claims asserted against such contributor by reason of your accepting any such warranty or additional liability end of terms and conditions$)', 'g'),\n  'BSD-2-Clause': new RegExp('(redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution this(.*?| )is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall(.*?| )be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this(.*?| )even if advised of the possibility of such damage$|redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall(.*?| )be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage$)', 'g'),\n  'BSD-3-Clause': new RegExp('(redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of(.*?| )nor the names of the contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall(.*?| )be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage$|(redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution the names of any contributors may not be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright holders and contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage$|redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name(.*?| )nor the names of(.*?| )contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by(.*?| )as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall(.*?| )be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage$))', 'g'),\n  'MIT': new RegExp('permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software$', 'g'),\n  'Unlicense': new RegExp('this is free and unencumbered software released into the public domain anyone is free to copy modify publish use compile sell or distribute this software either in source code form or as a compiled binary for any purpose commercial or non commercial and by any means in jurisdictions that recognize copyright laws the author or authors of this software dedicate any and all copyright interest in the software to the public domain we make this dedication for the benefit of the public at large and to the detriment of our heirs and successors we intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software for more information please refer to wildcard$', 'g')\n};","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/validate.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nexports.isValidPackageName = isValidPackageName;\n\nexports.default = function (info, isRoot, reporter, warn) {\n  if (isRoot) {\n    for (const key in (_typos || _load_typos()).default) {\n      if (key in info) {\n        warn(reporter.lang('manifestPotentialTypo', key, (_typos || _load_typos()).default[key]));\n      }\n    }\n  }\n\n  // validate name\n  const name = info.name;\n\n  if (typeof name === 'string') {\n    if (isRoot && isBuiltinModule(name)) {\n      warn(reporter.lang('manifestBuiltinModule', name));\n    }\n\n    // cannot start with a dot\n    if (name[0] === '.') {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('manifestNameDot'));\n    }\n\n    // cannot contain the following characters\n    if (!isValidPackageName(name)) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('manifestNameIllegalChars'));\n    }\n\n    // cannot equal node_modules or favicon.ico\n    const lower = name.toLowerCase();\n    if (lower === 'node_modules' || lower === 'favicon.ico') {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('manifestNameBlacklisted'));\n    }\n  }\n\n  // validate license\n  if (isRoot && !info.private) {\n    if (typeof info.license === 'string') {\n      const license = info.license.replace(/\\*$/g, '');\n      if (!(0, (_util || _load_util()).isValidLicense)(license)) {\n        warn(reporter.lang('manifestLicenseInvalid'));\n      }\n    } else {\n      warn(reporter.lang('manifestLicenseNone'));\n    }\n  }\n\n  // validate strings\n  for (const key of strings) {\n    const val = info[key];\n    if (val && typeof val !== 'string') {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('manifestStringExpected', key));\n    }\n  }\n\n  cleanDependencies(info, isRoot, reporter, warn);\n};\n\nexports.cleanDependencies = cleanDependencies;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../../errors.js');\n}\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nvar _typos;\n\nfunction _load_typos() {\n  return _typos = _interopRequireDefault(require('./typos.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst isBuiltinModule = require('is-builtin-module');\n\nconst strings = ['name', 'version'];\n\nconst dependencyKeys = [\n// npm registry will include optionalDependencies in dependencies and we'll want to dedupe them from the\n// other fields first\n'optionalDependencies',\n\n// it's seemingly common to include a dependency in dependencies and devDependencies of the same name but\n// different ranges, this can cause a lot of issues with our determinism and the behaviour of npm is\n// currently unspecified.\n'dependencies', 'devDependencies'];\n\nfunction isValidName(name) {\n  return !name.match(/[\\/@\\s\\+%:]/) && encodeURIComponent(name) === name;\n}\n\nfunction isValidScopedName(name) {\n  if (name[0] !== '@') {\n    return false;\n  }\n\n  const parts = name.slice(1).split('/');\n  return parts.length === 2 && isValidName(parts[0]) && isValidName(parts[1]);\n}\n\nfunction isValidPackageName(name) {\n  return isValidName(name) || isValidScopedName(name);\n}\n\nfunction cleanDependencies(info, isRoot, reporter, warn) {\n  // get dependency objects\n  const depTypes = [];\n  for (const type of dependencyKeys) {\n    const deps = info[type];\n    if (!deps || typeof deps !== 'object') {\n      continue;\n    }\n    depTypes.push([type, deps]);\n  }\n\n  // ensure that dependencies don't have ones that can collide\n  for (const _ref of depTypes) {\n    var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n    const type = _ref2[0];\n    const deps = _ref2[1];\n\n    for (const name in deps) {\n      const version = deps[name];\n\n      // check collisions\n      for (const _ref3 of depTypes) {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 2);\n\n        const type2 = _ref4[0];\n        const deps2 = _ref4[1];\n\n        const version2 = deps2[name];\n        if (deps === deps2 || !version2 || version2 === '*') {\n          continue;\n        }\n\n        if (version !== version2 && isRoot) {\n          // only throw a warning when at the root\n          warn(reporter.lang('manifestDependencyCollision', type, name, version, type2, version2));\n        }\n\n        delete deps2[name];\n      }\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./fetchers/index.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageFetcher {\n  constructor(config, resolver) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n  }\n\n  fetchCache(dest, fetcher) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref = yield _this.config.readPackageMetadata(dest);\n\n      const hash = _ref.hash,\n            pkg = _ref.package;\n\n      return {\n        package: pkg,\n        resolved: yield fetcher.getResolvedFromCached(hash),\n        hash,\n        dest,\n        cached: true\n      };\n    })();\n  }\n\n  fetch(ref) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const dest = _this2.config.generateHardModulePath(ref);\n\n      const remote = ref.remote;\n      const Fetcher = (_index || _load_index())[remote.type];\n      if (!Fetcher) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('unknownFetcherFor', remote.type));\n      }\n\n      const fetcher = new Fetcher(dest, remote, _this2.config);\n\n      if (yield _this2.config.isValidModuleDest(dest)) {\n        return _this2.fetchCache(dest, fetcher);\n      }\n\n      // remove as the module may be invalid\n      yield (_fs || _load_fs()).unlink(dest);\n\n      try {\n        return yield fetcher.fetch();\n      } catch (err) {\n        try {\n          yield (_fs || _load_fs()).unlink(dest);\n        } catch (err2) {\n          // what do?\n        }\n        throw err;\n      }\n    })();\n  }\n\n  maybeFetch(ref) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield _this3.fetch(ref);\n      } catch (err) {\n        if (ref.optional) {\n          _this3.reporter.error(err.message);\n          return null;\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  init() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const pkgs = _this4.resolver.getPackageReferences();\n      const tick = _this4.reporter.progress(pkgs.length);\n\n      yield (_promise || _load_promise()).queue(pkgs, (() => {\n        var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (ref) {\n          const res = yield _this4.maybeFetch(ref);\n          let newPkg;\n\n          if (res) {\n            newPkg = res.package;\n\n            // update with new remote\n            // but only if there was a hash previously as the tarball fetcher does not provide a hash.\n            if (ref.remote.hash) {\n              ref.remote.hash = res.hash;\n            }\n\n            if (res.resolved) {\n              ref.remote.resolved = res.resolved;\n            }\n          }\n\n          if (newPkg) {\n            // update with fresh manifest\n            yield _this4.resolver.updateManifest(ref, newPkg);\n          }\n\n          if (tick) {\n            tick(ref.name);\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      })(), _this4.config.networkConcurrency);\n    })();\n  }\n}\nexports.default = PackageFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-compatibility.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testEngine = testEngine;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst semver = require('semver');\n\nconst VERSIONS = Object.assign({}, process.versions, {\n  yarn: require('../package.json').version\n});\n\nfunction isValid(items, actual) {\n  let isNotWhitelist = true;\n  let isBlacklist = false;\n\n  for (const item of items) {\n    // blacklist\n    if (item[0] === '!') {\n      isBlacklist = true;\n\n      if (actual === item.slice(1)) {\n        return false;\n      }\n      // whitelist\n    } else {\n      isNotWhitelist = false;\n\n      if (item === actual) {\n        return true;\n      }\n    }\n  }\n\n  // npm allows blacklists and whitelists to be mixed. Blacklists with\n  // whitelisted items should be treated as whitelists.\n  return isBlacklist && isNotWhitelist;\n}\n\nconst aliases = (0, (_map || _load_map()).default)({\n  iojs: 'node' });\n\nconst ignore = ['npm', // we'll never satisfy this for obvious reasons\n'teleport', // a module bundler used by some modules\n'rhino'];\n\nfunction testEngine(name, range, versions, looseSemver) {\n  const actual = versions[name];\n  if (!actual) {\n    return false;\n  }\n\n  if (!semver.valid(actual, looseSemver)) {\n    return false;\n  }\n\n  if (semver.satisfies(actual, range, looseSemver)) {\n    return true;\n  }\n\n  if (name === 'node' && semver.gt(actual, '1.0.0', looseSemver)) {\n    // WARNING: this is a massive hack and is super gross but necessary for compatibility\n    // some modules have the `engines.node` field set to a caret version below semver major v1\n    // eg. ^0.12.0. this is problematic as we enforce engines checks and node is now on version >=1\n    // to allow this pattern we transform the node version to fake ones in the minor range 10-13\n    const major = semver.major(actual, looseSemver);\n    const fakes = [`0.10.${major}`, `0.11.${major}`, `0.12.${major}`, `0.13.${major}`];\n    for (const actualFake of fakes) {\n      if (semver.satisfies(actualFake, range, looseSemver)) {\n        return true;\n      }\n    }\n  }\n\n  // incompatible version\n  return false;\n}\n\nclass PackageCompatibility {\n  constructor(config, resolver, ignoreEngines) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n    this.ignoreEngines = ignoreEngines;\n  }\n\n  static isValidArch(archs) {\n    return isValid(archs, process.arch);\n  }\n\n  static isValidPlatform(platforms) {\n    return isValid(platforms, process.platform);\n  }\n\n  check(info) {\n    let didIgnore = false;\n    let didError = false;\n    const reporter = this.reporter;\n    const human = `${info.name}@${info.version}`;\n\n    const pushError = msg => {\n      const ref = info._reference;\n      invariant(ref, 'expected package reference');\n\n      if (ref.optional) {\n        ref.ignore = true;\n\n        reporter.warn(`${human}: ${msg}`);\n        if (!didIgnore) {\n          reporter.info(reporter.lang('optionalCompatibilityExcluded', human));\n          didIgnore = true;\n        }\n      } else {\n        reporter.error(`${human}: ${msg}`);\n        didError = true;\n      }\n    };\n\n    const invalidPlatform = !this.config.ignorePlatform && Array.isArray(info.os) && info.os.length > 0 && !PackageCompatibility.isValidPlatform(info.os);\n    if (invalidPlatform) {\n      pushError(this.reporter.lang('incompatibleOS', process.platform));\n    }\n\n    const invalidCpu = !this.config.ignorePlatform && Array.isArray(info.cpu) && info.cpu.length > 0 && !PackageCompatibility.isValidArch(info.cpu);\n    if (invalidCpu) {\n      pushError(this.reporter.lang('incompatibleCPU', process.arch));\n    }\n\n    if (!this.ignoreEngines && typeof info.engines === 'object') {\n      for (const entry of (0, (_misc || _load_misc()).entries)(info.engines)) {\n        let name = entry[0];\n        const range = entry[1];\n\n        if (aliases[name]) {\n          name = aliases[name];\n        }\n\n        if (VERSIONS[name]) {\n          if (!testEngine(name, range, VERSIONS, this.config.looseSemver)) {\n            pushError(this.reporter.lang('incompatibleEngine', name, range));\n          }\n        } else if (ignore.indexOf(name) < 0) {\n          this.reporter.warn(`${human}: ${this.reporter.lang('invalidEngine', name)}`);\n        }\n      }\n    }\n\n    if (didError) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundIncompatible'));\n    }\n  }\n\n  init() {\n    const infos = this.resolver.getManifests();\n    for (const info of infos) {\n      this.check(info);\n    }\n    return Promise.resolve();\n  }\n}\nexports.default = PackageCompatibility;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-linker.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linkBin = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet linkBin = exports.linkBin = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    if (process.platform === 'win32') {\n      const unlockMutex = yield (0, (_mutex || _load_mutex()).default)(src);\n      try {\n        yield cmdShim(src, dest);\n      } finally {\n        unlockMutex();\n      }\n    } else {\n      yield (_fs || _load_fs()).mkdirp(path.dirname(dest));\n      yield (_fs || _load_fs()).symlink(src, dest);\n      yield (_fs || _load_fs()).chmod(dest, '755');\n    }\n  });\n\n  return function linkBin(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _packageHoister;\n\nfunction _load_packageHoister() {\n  return _packageHoister = _interopRequireDefault(require('./package-hoister.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _mutex;\n\nfunction _load_mutex() {\n  return _mutex = _interopRequireDefault(require('./util/mutex.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst cmdShim = (_promise || _load_promise()).promisify(require('cmd-shim'));\nconst semver = require('semver');\nconst path = require('path');\n\nclass PackageLinker {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n  }\n\n  linkSelfDependencies(pkg, pkgLoc, targetBinLoc) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      targetBinLoc = yield (_fs || _load_fs()).realpath(targetBinLoc);\n      pkgLoc = yield (_fs || _load_fs()).realpath(pkgLoc);\n      for (const _ref2 of (0, (_misc || _load_misc()).entries)(pkg.bin)) {\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 2);\n\n        const scriptName = _ref3[0];\n        const scriptCmd = _ref3[1];\n\n        const dest = path.join(targetBinLoc, scriptName);\n        const src = path.join(pkgLoc, scriptCmd);\n        if (!(yield (_fs || _load_fs()).exists(src))) {\n          // TODO maybe throw an error\n          continue;\n        }\n        yield linkBin(src, dest);\n      }\n    })();\n  }\n\n  linkBinDependencies(pkg, dir) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const deps = [];\n\n      const ref = pkg._reference;\n      invariant(ref, 'Package reference is missing');\n\n      const remote = pkg._remote;\n      invariant(remote, 'Package remote is missing');\n\n      // link up `bin scripts` in `dependencies`\n      for (const pattern of ref.dependencies) {\n        const dep = _this.resolver.getStrictResolvedPattern(pattern);\n        if (dep.bin && Object.keys(dep.bin).length) {\n          deps.push({ dep, loc: _this.config.generateHardModulePath(dep._reference) });\n        }\n      }\n\n      // link up the `bin` scripts in bundled dependencies\n      if (pkg.bundleDependencies) {\n        for (const depName of pkg.bundleDependencies) {\n          const loc = path.join(_this.config.generateHardModulePath(ref), _this.config.getFolder(pkg), depName);\n\n          const dep = yield _this.config.readManifest(loc, remote.registry);\n\n          if (dep.bin && Object.keys(dep.bin).length) {\n            deps.push({ dep, loc });\n          }\n        }\n      }\n\n      // no deps to link\n      if (!deps.length) {\n        return;\n      }\n\n      // ensure our .bin file we're writing these to exists\n      const binLoc = path.join(dir, '.bin');\n      yield (_fs || _load_fs()).mkdirp(binLoc);\n\n      // write the executables\n      for (const _ref4 of deps) {\n        const dep = _ref4.dep,\n              loc = _ref4.loc;\n\n        yield _this.linkSelfDependencies(dep, loc, binLoc);\n      }\n    })();\n  }\n\n  getFlatHoistedTree(patterns) {\n    const hoister = new (_packageHoister || _load_packageHoister()).default(this.config, this.resolver);\n    hoister.seed(patterns);\n    return Promise.resolve(hoister.init());\n  }\n\n  copyModules(patterns, linkDuplicates) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let flatTree = yield _this2.getFlatHoistedTree(patterns);\n\n      // sorted tree makes file creation and copying not to interfere with each other\n      flatTree = flatTree.sort(function (dep1, dep2) {\n        return dep1[0].localeCompare(dep2[0]);\n      });\n\n      // list of artifacts in modules to remove from extraneous removal\n      const artifactFiles = [];\n\n      const copyQueue = new Map();\n      const hardlinkQueue = new Map();\n      const hardlinksEnabled = linkDuplicates && (yield (_fs || _load_fs()).hardlinksWork(_this2.config.cwd));\n\n      const copiedSrcs = new Map();\n      for (const _ref5 of flatTree) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const dest = _ref6[0];\n        var _ref6$ = _ref6[1];\n        const pkg = _ref6$.pkg;\n        const src = _ref6$.loc;\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected package reference');\n        ref.setLocation(dest);\n\n        // get a list of build artifacts contained in this module so we can prevent them from being marked as\n        // extraneous\n        const metadata = yield _this2.config.readPackageMetadata(src);\n        for (const file of metadata.artifacts) {\n          artifactFiles.push(path.join(dest, file));\n        }\n\n        const copiedDest = copiedSrcs.get(src);\n        if (!copiedDest) {\n          if (hardlinksEnabled) {\n            copiedSrcs.set(src, dest);\n          }\n          copyQueue.set(dest, {\n            src,\n            dest,\n            onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        } else {\n          hardlinkQueue.set(dest, {\n            src: copiedDest,\n            dest,\n            onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        }\n      }\n\n      // keep track of all scoped paths to remove empty scopes after copy\n      const scopedPaths = new Set();\n\n      // register root & scoped packages as being possibly extraneous\n      const possibleExtraneous = new Set();\n      for (const folder of _this2.config.registryFolders) {\n        const loc = path.join(_this2.config.cwd, folder);\n\n        if (yield (_fs || _load_fs()).exists(loc)) {\n          const files = yield (_fs || _load_fs()).readdir(loc);\n          let filepath;\n          for (const file of files) {\n            filepath = path.join(loc, file);\n            if (file[0] === '@') {\n              // it's a scope, not a package\n              scopedPaths.add(filepath);\n              const subfiles = yield (_fs || _load_fs()).readdir(filepath);\n              for (const subfile of subfiles) {\n                possibleExtraneous.add(path.join(filepath, subfile));\n              }\n            } else {\n              possibleExtraneous.add(filepath);\n            }\n          }\n        }\n      }\n\n      // linked modules\n      for (const loc of possibleExtraneous) {\n        const stat = yield (_fs || _load_fs()).lstat(loc);\n        if (stat.isSymbolicLink()) {\n          possibleExtraneous.delete(loc);\n          copyQueue.delete(loc);\n        }\n      }\n\n      //\n      let tick;\n      yield (_fs || _load_fs()).copyBulk(Array.from(copyQueue.values()), _this2.reporter, {\n        possibleExtraneous,\n        artifactFiles,\n\n        ignoreBasenames: [(_constants || _load_constants()).METADATA_FILENAME, (_constants || _load_constants()).TARBALL_FILENAME],\n\n        onStart: function (num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n      yield (_fs || _load_fs()).hardlinkBulk(Array.from(hardlinkQueue.values()), _this2.reporter, {\n        possibleExtraneous,\n        artifactFiles,\n\n        onStart: function (num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n\n      // remove all extraneous files that weren't in the tree\n      for (const loc of possibleExtraneous) {\n        _this2.reporter.verbose(_this2.reporter.lang('verboseFileRemoveExtraneous', loc));\n        yield (_fs || _load_fs()).unlink(loc);\n      }\n\n      // remove any empty scoped directories\n      for (const scopedPath of scopedPaths) {\n        const files = yield (_fs || _load_fs()).readdir(scopedPath);\n        if (files.length === 0) {\n          yield (_fs || _load_fs()).unlink(scopedPath);\n        }\n      }\n\n      //\n      if (_this2.config.binLinks) {\n        const tickBin = _this2.reporter.progress(flatTree.length);\n        yield (_promise || _load_promise()).queue(flatTree, (() => {\n          var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref8) {\n            var _ref9 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref8, 2);\n\n            let dest = _ref9[0],\n                pkg = _ref9[1].pkg;\n\n            const binLoc = path.join(dest, _this2.config.getFolder(pkg));\n            yield _this2.linkBinDependencies(pkg, binLoc);\n            tickBin(dest);\n          });\n\n          return function (_x3) {\n            return _ref7.apply(this, arguments);\n          };\n        })(), 4);\n      }\n    })();\n  }\n\n  resolvePeerModules() {\n    for (const pkg of this.resolver.getManifests()) {\n      this._resolvePeerModules(pkg);\n    }\n  }\n\n  _resolvePeerModules(pkg) {\n    const peerDeps = pkg.peerDependencies;\n    if (!peerDeps) {\n      return;\n    }\n\n    const ref = pkg._reference;\n    invariant(ref, 'Package reference is missing');\n\n    for (const name in peerDeps) {\n      const range = peerDeps[name];\n      const patterns = this.resolver.patternsByPackage[name] || [];\n      const foundPattern = patterns.find(pattern => {\n        const resolvedPattern = this.resolver.getResolvedPattern(pattern);\n        return resolvedPattern ? this._satisfiesPeerDependency(range, resolvedPattern.version) : false;\n      });\n\n      if (foundPattern) {\n        ref.addDependencies([foundPattern]);\n      } else {\n        const depError = patterns.length > 0 ? 'incorrectPeer' : 'unmetPeer';\n        const pkgHuman = `${pkg.name}@${pkg.version}`,\n              depHuman = `${name}@${range}`;\n\n        this.reporter.warn(this.reporter.lang(depError, pkgHuman, depHuman));\n      }\n    }\n  }\n\n  _satisfiesPeerDependency(range, version) {\n    return range === '*' || semver.satisfies(version, range, this.config.looseSemver);\n  }\n\n  init(patterns, linkDuplicates) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this3.resolvePeerModules();\n      yield _this3.copyModules(patterns, linkDuplicates);\n      yield _this3.saveAll(patterns);\n    })();\n  }\n\n  save(pattern) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const resolved = _this4.resolver.getResolvedPattern(pattern);\n      invariant(resolved, `Couldn't find resolved name/version for ${pattern}`);\n\n      const ref = resolved._reference;\n      invariant(ref, 'Missing reference');\n\n      //\n      const src = _this4.config.generateHardModulePath(ref);\n\n      // link bins\n      if (_this4.config.binLinks && resolved.bin && Object.keys(resolved.bin).length && !ref.ignore) {\n        const folder = _this4.config.modulesFolder || path.join(_this4.config.cwd, _this4.config.getFolder(resolved));\n        const binLoc = path.join(folder, '.bin');\n        yield (_fs || _load_fs()).mkdirp(binLoc);\n        yield _this4.linkSelfDependencies(resolved, src, binLoc);\n      }\n    })();\n  }\n\n  saveAll(deps) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      deps = _this5.resolver.dedupePatterns(deps);\n      yield (_promise || _load_promise()).queue(deps, function (dep) {\n        return _this5.save(dep);\n      });\n    })();\n  }\n}\nexports.default = PackageLinker;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-install-scripts.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = _interopRequireDefault(require('./util/execute-lifecycle-script.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst INSTALL_STAGES = ['preinstall', 'install', 'postinstall'];\n\nclass PackageInstallScripts {\n  constructor(config, resolver, force) {\n    this.installed = 0;\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n    this.force = force;\n  }\n\n  getInstallCommands(pkg) {\n    const scripts = pkg.scripts;\n    if (scripts) {\n      const cmds = [];\n      for (const stage of INSTALL_STAGES) {\n        const cmd = scripts[stage];\n        if (cmd) {\n          cmds.push([stage, cmd]);\n        }\n      }\n      return cmds;\n    } else {\n      return [];\n    }\n  }\n\n  walk(loc) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const files = yield (_fs || _load_fs()).walk(loc, null, new Set(_this.config.registryFolders));\n      const mtimes = new Map();\n      for (const file of files) {\n        mtimes.set(file.relative, file.mtime);\n      }\n      return mtimes;\n    })();\n  }\n\n  saveBuildArtifacts(loc, pkg, beforeFiles, spinner) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const afterFiles = yield _this2.walk(loc);\n\n      // work out what files have been created/modified\n      const buildArtifacts = [];\n      for (const _ref of afterFiles) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const file = _ref2[0];\n        const mtime = _ref2[1];\n\n        if (!beforeFiles.has(file) || beforeFiles.get(file) !== mtime) {\n          buildArtifacts.push(file);\n        }\n      }\n\n      if (!buildArtifacts.length) {\n        // nothing else to do here since we have no build artifacts\n        return;\n      }\n\n      // if the process is killed while copying over build artifacts then we'll leave\n      // the cache in a bad state. remove the metadata file and add it back once we've\n      // done our copies to ensure cache integrity.\n      const cachedLoc = _this2.config.generateHardModulePath(pkg._reference, true);\n      const metadata = yield _this2.config.readPackageMetadata(cachedLoc);\n      metadata.artifacts = buildArtifacts;\n\n      const metadataLoc = path.join(cachedLoc, (_constants || _load_constants()).METADATA_FILENAME);\n      yield (_fs || _load_fs()).writeFile(metadataLoc, JSON.stringify((0, (_extends2 || _load_extends()).default)({}, metadata, {\n\n        // config.readPackageMetadata also returns the package manifest but that's not in the original\n        // metadata json\n        package: undefined\n      }), null, '  '));\n    })();\n  }\n\n  install(cmds, pkg, spinner) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const loc = _this3.config.generateHardModulePath(ref);\n\n      try {\n        for (const _ref3 of cmds) {\n          var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 2);\n\n          const stage = _ref4[0];\n          const cmd = _ref4[1];\n\n          yield (0, (_executeLifecycleScript || _load_executeLifecycleScript()).default)(stage, _this3.config, loc, cmd, spinner);\n        }\n      } catch (err) {\n        err.message = `${loc}: ${err.message}`;\n\n        invariant(ref, 'expected reference');\n\n        if (ref.optional) {\n          ref.ignore = true;\n          _this3.reporter.warn(_this3.reporter.lang('optionalModuleScriptFail', err.message));\n          _this3.reporter.info(_this3.reporter.lang('optionalModuleFail'));\n\n          // Cleanup node_modules\n          try {\n            yield (_fs || _load_fs()).unlink(loc);\n          } catch (e) {\n            _this3.reporter.error(_this3.reporter.lang('optionalModuleCleanupFail', e.message));\n          }\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  packageCanBeInstalled(pkg) {\n    const cmds = this.getInstallCommands(pkg);\n    if (!cmds.length) {\n      return false;\n    }\n    const ref = pkg._reference;\n    invariant(ref, 'Missing package reference');\n    if (!ref.fresh && !this.force) {\n      // this package hasn't been touched\n      return false;\n    }\n\n    // we haven't actually written this module out\n    if (ref.ignore) {\n      return false;\n    }\n    return true;\n  }\n\n  runCommand(spinner, pkg) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const cmds = _this4.getInstallCommands(pkg);\n      spinner.setPrefix(++_this4.installed, pkg.name);\n      yield _this4.install(cmds, pkg, spinner);\n    })();\n  }\n\n  // detect if there is a circularDependency in the dependency tree\n  detectCircularDependencies(root, seenManifests, pkg) {\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    const deps = ref.dependencies;\n    for (const dep of deps) {\n      const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n      if (seenManifests.has(pkgDep)) {\n        // there is a cycle but not with the root\n        continue;\n      }\n      seenManifests.add(pkgDep);\n      // found a dependency pointing to root\n      if (pkgDep == root) {\n        return true;\n      }\n      if (this.detectCircularDependencies(root, seenManifests, pkgDep)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // find the next package to be installed\n  findInstallablePackage(workQueue, installed) {\n    for (const pkg of workQueue) {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const deps = ref.dependencies;\n\n      let dependenciesFullfilled = true;\n      for (const dep of deps) {\n        const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n        if (!installed.has(pkgDep)) {\n          dependenciesFullfilled = false;\n          break;\n        }\n      }\n\n      // all depedencies are installed\n      if (dependenciesFullfilled) {\n        return pkg;\n      }\n\n      // detect circular dependency, mark this pkg as installable to break the circle\n      if (this.detectCircularDependencies(pkg, new Set(), pkg)) {\n        return pkg;\n      }\n    }\n    return null;\n  }\n\n  worker(spinner, workQueue, installed, waitQueue) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      while (true) {\n        // No more work to be done\n        if (workQueue.size == 0) {\n          break;\n        }\n\n        // find a installable package\n        const pkg = _this5.findInstallablePackage(workQueue, installed);\n\n        // can't find a package to install, register into waitQueue\n        if (pkg == null) {\n          spinner.clear();\n          yield new Promise(function (resolve) {\n            return waitQueue.add(resolve);\n          });\n          continue;\n        }\n\n        // found a package to install\n        workQueue.delete(pkg);\n        if (_this5.packageCanBeInstalled(pkg)) {\n          yield _this5.runCommand(spinner, pkg);\n        }\n        installed.add(pkg);\n        for (const workerResolve of waitQueue) {\n          workerResolve();\n        }\n        waitQueue.clear();\n      }\n    })();\n  }\n\n  init(seedPatterns) {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const workQueue = new Set();\n      const installed = new Set();\n      const pkgs = _this6.resolver.getTopologicalManifests(seedPatterns);\n      let installablePkgs = 0;\n      // A map to keep track of what files exist before installation\n      const beforeFilesMap = new Map();\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          beforeFilesMap.set(loc, (yield _this6.walk(loc)));\n          installablePkgs += 1;\n        }\n        workQueue.add(pkg);\n      }\n\n      // waitQueue acts like a semaphore to allow workers to register to be notified\n      // when there are more work added to the work queue\n      const waitQueue = new Set();\n      const workers = [];\n\n      const set = _this6.reporter.activitySet(installablePkgs, Math.min((_constants || _load_constants()).CHILD_CONCURRENCY, workQueue.size));\n\n      for (const spinner of set.spinners) {\n        workers.push(_this6.worker(spinner, workQueue, installed, waitQueue));\n      }\n\n      yield Promise.all(workers);\n\n      // cache all build artifacts\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          const beforeFiles = beforeFilesMap.get(loc);\n          invariant(beforeFiles, 'files before installation should always be recorded');\n          yield _this6.saveBuildArtifacts(loc, pkg, beforeFiles, set.spinners[0]);\n        }\n      }\n\n      set.end();\n    })();\n  }\n}\nexports.default = PackageInstallScripts;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/normalize-manifest/typos.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  dependancies: 'dependencies',\n  dependecies: 'dependencies',\n  depdenencies: 'dependencies',\n  devEependencies: 'devDependencies',\n  depends: 'dependencies',\n  'dev-dependencies': 'devDependencies',\n  devDependences: 'devDependencies',\n  devDepenencies: 'devDependencies',\n  devdependencies: 'devDependencies',\n  repostitory: 'repository',\n  repo: 'repository',\n  prefereGlobal: 'preferGlobal',\n  hompage: 'homepage',\n  hampage: 'homepage',\n  autohr: 'author',\n  autor: 'author',\n  contributers: 'contributors',\n  publicationConfig: 'publishConfig',\n  script: 'scripts'\n};","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/reporters/console/spinner-progress.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util;\n\nfunction _load_util() {\n  return _util = require('./util.js');\n}\n\nclass Spinner {\n  constructor() {\n    let stdout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.stderr;\n    let lineNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this.current = 0;\n    this.prefix = '';\n    this.lineNumber = lineNumber;\n    this.stdout = stdout;\n    this.delay = 60;\n    this.chars = Spinner.spinners[28].split('');\n    this.text = '';\n    this.id = null;\n  }\n\n  setPrefix(prefix) {\n    this.prefix = prefix;\n  }\n\n  setText(text) {\n    this.text = text;\n  }\n\n  start() {\n    this.current = 0;\n    this.render();\n  }\n\n  render() {\n    if (this.id) {\n      clearTimeout(this.id);\n    }\n\n    // build line ensuring we don't wrap to the next line\n    let msg = `${this.prefix}${this.chars[this.current]} ${this.text}`;\n    const columns = typeof this.stdout.columns === 'number' ? this.stdout.columns : 100;\n    msg = msg.slice(0, columns);\n\n    (0, (_util || _load_util()).writeOnNthLine)(this.stdout, this.lineNumber, msg);\n\n    this.current = ++this.current % this.chars.length;\n    this.id = setTimeout(() => this.render(), this.delay);\n  }\n\n  stop() {\n    if (this.id) {\n      clearTimeout(this.id);\n      this.id = null;\n    }\n\n    (0, (_util || _load_util()).clearNthLine)(this.stdout, this.lineNumber);\n  }\n}\nexports.default = Spinner;\nSpinner.spinners = ['|/-\\\\', '⠂-–—–-', '◐◓◑◒', '◴◷◶◵', '◰◳◲◱', '▖▘▝▗', '■□▪▫', '▌▀▐▄', '▉▊▋▌▍▎▏▎▍▌▋▊▉', '▁▃▄▅▆▇█▇▆▅▄▃', '←↖↑↗→↘↓↙', '┤┘┴└├┌┬┐', '◢◣◤◥', '.oO°Oo.', '.oO@*', '🌍🌎🌏', '◡◡ ⊙⊙ ◠◠', '☱☲☴', '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏', '⠋⠙⠚⠞⠖⠦⠴⠲⠳⠓', '⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆', '⠋⠙⠚⠒⠂⠂⠒⠲⠴⠦⠖⠒⠐⠐⠒⠓⠋', '⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠴⠲⠒⠂⠂⠒⠚⠙⠉⠁', '⠈⠉⠋⠓⠒⠐⠐⠒⠖⠦⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈', '⠁⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈⠈', '⢄⢂⢁⡁⡈⡐⡠', '⢹⢺⢼⣸⣇⡧⡗⡏', '⣾⣽⣻⢿⡿⣟⣯⣷', '⠁⠂⠄⡀⢀⠠⠐⠈'];","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-reference.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageReference {\n  constructor(request, info, remote) {\n    this.resolver = request.resolver;\n    this.lockfile = request.lockfile;\n    this.requests = [];\n    this.config = request.config;\n\n    this.registry = remote.registry;\n    this.version = info.version;\n    this.name = info.name;\n    this.uid = info._uid;\n\n    this.remote = remote;\n\n    this.dependencies = [];\n\n    this.permissions = {};\n    this.patterns = [];\n    this.optional = null;\n    this.root = false;\n    this.ignore = false;\n    this.fresh = false;\n    this.location = null;\n    this.addRequest(request);\n  }\n\n  setFresh(fresh) {\n    this.fresh = fresh;\n  }\n\n  setLocation(loc) {\n    return this.location = loc;\n  }\n\n  addRequest(request) {\n    this.requests.push(request);\n\n    if (!request.parentRequest) {\n      this.root = true;\n    }\n  }\n\n  prune() {\n    for (const selfPattern of this.patterns) {\n      // remove ourselves from the resolver\n      this.resolver.removePattern(selfPattern);\n    }\n  }\n\n  addDependencies(deps) {\n    this.dependencies = this.dependencies.concat(deps);\n  }\n\n  setPermission(key, val) {\n    this.permissions[key] = val;\n  }\n\n  hasPermission(key) {\n    if (key in this.permissions) {\n      return this.permissions[key];\n    } else {\n      return false;\n    }\n  }\n\n  addPattern(pattern, manifest) {\n    this.resolver.addPattern(pattern, manifest);\n\n    this.patterns.push(pattern);\n\n    const shrunk = this.lockfile.getLocked(pattern);\n    if (shrunk && shrunk.permissions) {\n      for (const _ref of (0, (_misc || _load_misc()).entries)(shrunk.permissions)) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const key = _ref2[0];\n        const perm = _ref2[1];\n\n        this.setPermission(key, perm);\n      }\n    }\n  }\n\n  addOptional(optional) {\n    if (this.optional == null) {\n      // optional is uninitialised\n      this.optional = optional;\n    } else if (!optional) {\n      // otherwise, ignore all subsequent optional assignments and only accept ones making\n      // this not optional\n      this.optional = false;\n    }\n  }\n}\nexports.default = PackageReference;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/git.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./misc.js');\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('./crypto.js'));\n}\n\nvar _child;\n\nfunction _load_child() {\n  return _child = _interopRequireWildcard(require('./child.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./fs.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./map.js'));\n}\n\nvar _fs2;\n\nfunction _load_fs2() {\n  return _fs2 = require('fs');\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst semver = require('semver');\nconst url = require('url');\nconst tar = require('tar');\n\n\nconst supportsArchiveCache = (0, (_map || _load_map()).default)({\n  'github.com': false });\n\nclass Git {\n  constructor(config, url, hash) {\n    this.supportsArchive = false;\n    this.fetched = false;\n    this.config = config;\n    this.reporter = config.reporter;\n    this.hash = hash;\n    this.ref = hash;\n    this.url = Git.cleanUrl(url);\n    this.cwd = this.config.getTemp((_crypto || _load_crypto()).hash(this.url));\n  }\n\n  static cleanUrl(url) {\n    return url.replace(/^git\\+/, '');\n  }\n\n  /**\n   * Check if the host specified in the input `gitUrl` has archive capability.\n   */\n\n  static hasArchiveCapability(gitUrl) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // USER@HOSTNAME:PATHNAME\n      const match = gitUrl.match(/^(.*?)@(.*?):(.*?)$/);\n      if (!match) {\n        return false;\n      }\n\n      var _match = (0, (_slicedToArray2 || _load_slicedToArray()).default)(match, 3);\n\n      const hostname = _match[2];\n\n      const cached = supportsArchiveCache[hostname];\n      if (cached != null) {\n        return cached;\n      }\n\n      try {\n        yield (_child || _load_child()).spawn('git', ['archive', `--remote=${gitUrl}`, 'HEAD', Date.now() + '']);\n        throw new Error();\n      } catch (err) {\n        const supports = err.message.indexOf('did not match any files') >= 0;\n        return supportsArchiveCache[hostname] = supports;\n      }\n    })();\n  }\n\n  /**\n   * Check if the input `target` is a 5-40 character hex commit hash.\n   */\n\n  static isCommitHash(target) {\n    return !!target && /^[a-f0-9]{5,40}$/.test(target);\n  }\n\n  static repoExists(gitUrl) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        yield (_child || _load_child()).spawn('git', ['ls-remote', '-t', gitUrl]);\n        return true;\n      } catch (err) {\n        return false;\n      }\n    })();\n  }\n\n  /**\n   * Attempt to upgrade insecure protocols to secure protocol\n   */\n\n  static secureUrl(ref, hash, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (Git.isCommitHash(hash)) {\n        // this is cryptographically secure\n        return ref;\n      }\n\n      const parts = url.parse(ref);\n\n      if (parts.protocol === 'git:') {\n        const secureUrl = ref.replace(/^git:/, 'https:');\n        if (yield Git.repoExists(secureUrl)) {\n          return secureUrl;\n        } else {\n          throw new (_errors || _load_errors()).SecurityError(reporter.lang('refusingDownloadGitWithoutCommit', ref));\n        }\n      }\n\n      if (parts.protocol === 'http:') {\n        const secureUrl = ref.replace(/^http:/, 'https:');\n        if (yield Git.repoExists(secureUrl)) {\n          return secureUrl;\n        } else {\n          if (yield Git.repoExists(ref)) {\n            return ref;\n          } else {\n            throw new (_errors || _load_errors()).SecurityError(reporter.lang('refusingDownloadHTTPWithoutCommit', ref));\n          }\n        }\n      }\n\n      if (parts.protocol === 'https:') {\n        if (yield Git.repoExists(ref)) {\n          return ref;\n        } else {\n          throw new (_errors || _load_errors()).SecurityError(reporter.lang('refusingDownloadHTTPSWithoutCommit', ref));\n        }\n      }\n\n      return ref;\n    })();\n  }\n\n  /**\n   * Archive a repo to destination\n   */\n\n  archive(dest) {\n    if (this.supportsArchive) {\n      return this._archiveViaRemoteArchive(dest);\n    } else {\n      return this._archiveViaLocalFetched(dest);\n    }\n  }\n\n  _archiveViaRemoteArchive(dest) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const hashStream = new (_crypto || _load_crypto()).HashStream();\n      yield (_child || _load_child()).spawn('git', ['archive', `--remote=${_this.url}`, _this.ref], {\n        process(proc, resolve, reject, done) {\n          const writeStream = (0, (_fs2 || _load_fs2()).createWriteStream)(dest);\n          proc.on('error', reject);\n          writeStream.on('error', reject);\n          writeStream.on('end', done);\n          writeStream.on('open', function () {\n            proc.stdout.pipe(hashStream).pipe(writeStream);\n          });\n          writeStream.once('finish', done);\n        }\n      });\n      return hashStream.getHash();\n    })();\n  }\n\n  _archiveViaLocalFetched(dest) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const hashStream = new (_crypto || _load_crypto()).HashStream();\n      yield (_child || _load_child()).spawn('git', ['archive', _this2.hash], {\n        cwd: _this2.cwd,\n        process(proc, resolve, reject, done) {\n          const writeStream = (0, (_fs2 || _load_fs2()).createWriteStream)(dest);\n          proc.on('error', reject);\n          writeStream.on('error', reject);\n          writeStream.on('open', function () {\n            proc.stdout.pipe(hashStream).pipe(writeStream);\n          });\n          writeStream.once('finish', done);\n        }\n      });\n      return hashStream.getHash();\n    })();\n  }\n\n  /**\n   * Clone a repo to the input `dest`. Use `git archive` if it's available, otherwise fall\n   * back to `git clone`.\n   */\n\n  clone(dest) {\n    if (this.supportsArchive) {\n      return this._cloneViaRemoteArchive(dest);\n    } else {\n      return this._cloneViaLocalFetched(dest);\n    }\n  }\n\n  _cloneViaRemoteArchive(dest) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield (_child || _load_child()).spawn('git', ['archive', `--remote=${_this3.url}`, _this3.ref], {\n        process(proc, update, reject, done) {\n          const extractor = tar.Extract({ path: dest });\n          extractor.on('error', reject);\n          extractor.on('end', done);\n\n          proc.stdout.pipe(extractor);\n          proc.on('error', reject);\n        }\n      });\n    })();\n  }\n\n  _cloneViaLocalFetched(dest) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      yield (_child || _load_child()).spawn('git', ['archive', _this4.hash], {\n        cwd: _this4.cwd,\n        process(proc, resolve, reject, done) {\n          const extractor = tar.Extract({ path: dest });\n          extractor.on('error', reject);\n          extractor.on('end', done);\n\n          proc.stdout.pipe(extractor);\n        }\n      });\n    })();\n  }\n\n  /**\n   * Clone this repo.\n   */\n\n  fetch() {\n    var _this5 = this;\n\n    const url = this.url,\n          cwd = this.cwd;\n\n\n    return (_fs || _load_fs()).lockQueue.push(url, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (yield (_fs || _load_fs()).exists(cwd)) {\n        yield (_child || _load_child()).spawn('git', ['pull'], { cwd });\n      } else {\n        yield (_child || _load_child()).spawn('git', ['clone', url, cwd]);\n      }\n\n      _this5.fetched = true;\n    }));\n  }\n\n  /**\n   * Given a list of tags/branches from git, check if they match an input range.\n   */\n\n  findResolution(range, tags) {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // If there are no tags and target is *, fallback to the latest commit on master\n      // or if we have no target.\n      if (!range || !tags.length && range === '*') {\n        return 'master';\n      }\n\n      return (yield _this6.config.resolveConstraints(tags.filter(function (tag) {\n        return !!semver.valid(tag, _this6.config.looseSemver);\n      }), range)) || range;\n    })();\n  }\n\n  /**\n   * Fetch the file by cloning the repo and reading it.\n   */\n\n  getFile(filename) {\n    if (this.supportsArchive) {\n      return this._getFileFromArchive(filename);\n    } else {\n      return this._getFileFromClone(filename);\n    }\n  }\n\n  _getFileFromArchive(filename) {\n    var _this7 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield (_child || _load_child()).spawn('git', ['archive', `--remote=${_this7.url}`, _this7.ref, filename], {\n          process(proc, update, reject, done) {\n            const parser = tar.Parse();\n\n            parser.on('error', reject);\n            parser.on('end', done);\n\n            parser.on('data', entry => {\n              update(entry.toString());\n            });\n\n            proc.stdout.pipe(parser);\n          }\n        });\n      } catch (err) {\n        if (err.message.indexOf('did not match any files') >= 0) {\n          return false;\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  _getFileFromClone(filename) {\n    var _this8 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      invariant(_this8.fetched, 'Repo not fetched');\n\n      try {\n        return yield (_child || _load_child()).spawn('git', ['show', `${_this8.hash}:${filename}`], { cwd: _this8.cwd });\n      } catch (err) {\n        // file doesn't exist\n        return false;\n      }\n    })();\n  }\n\n  /**\n   * Initialize the repo, find a secure url to use and\n   * set the ref to match an input `target`.\n   */\n  init() {\n    var _this9 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this9.url = yield Git.secureUrl(_this9.url, _this9.hash, _this9.reporter);\n      // check capabilities\n      if (yield Git.hasArchiveCapability(_this9.url)) {\n        _this9.supportsArchive = true;\n      } else {\n        yield _this9.fetch();\n      }\n\n      return yield _this9.setRefRemote();\n    })();\n  }\n\n  setRefRemote() {\n    var _this10 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const stdout = yield (_child || _load_child()).spawn('git', ['ls-remote', '--tags', '--heads', _this10.url]);\n      const refs = Git.parseRefs(stdout);\n      return yield _this10.setRef(refs);\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  setRef(refs) {\n    var _this11 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // get commit ref\n      const hash = _this11.hash;\n\n\n      const names = Object.keys(refs);\n\n      if (Git.isCommitHash(hash)) {\n        for (const name in refs) {\n          if (refs[name] === hash) {\n            _this11.ref = name;\n            return hash;\n          }\n        }\n\n        // `git archive` only accepts a treeish and we have no ref to this commit\n        _this11.supportsArchive = false;\n\n        if (!_this11.fetched) {\n          // in fact, `git archive` can't be used, and we haven't fetched the project yet. Do it now.\n          yield _this11.fetch();\n        }\n        return _this11.ref = _this11.hash = hash;\n      }\n\n      const ref = yield _this11.findResolution(hash, names);\n      const commit = refs[ref];\n      if (commit) {\n        _this11.ref = ref;\n        return _this11.hash = commit;\n      } else {\n        throw new (_errors || _load_errors()).MessageError(_this11.reporter.lang('couldntFindMatch', ref, names.join(','), _this11.url));\n      }\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  static parseRefs(stdout) {\n    // store references\n    const refs = {};\n\n    // line delimited\n    const refLines = stdout.split('\\n');\n\n    for (const line of refLines) {\n      // line example: 64b2c0cee9e829f73c5ad32b8cc8cb6f3bec65bb refs/tags/v4.2.2\n      var _line$split = line.split(/\\s+/g),\n          _line$split2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_line$split, 2);\n\n      const sha = _line$split2[0],\n            id = _line$split2[1];\n\n      let name = id.split('/').slice(2).join('/');\n\n      // TODO: find out why this is necessary. idk it makes it work...\n      name = (0, (_misc || _load_misc()).removeSuffix)(name, '^{}');\n\n      refs[name] = sha;\n    }\n\n    return refs;\n  }\n}\nexports.default = Git;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/crypto.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hash = hash;\nconst crypto = require('crypto');\nconst stream = require('stream');\n\nfunction hash(content) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'md5';\n\n  return crypto.createHash(type).update(content).digest('hex');\n}\n\nclass HashStream extends stream.Transform {\n  constructor(options) {\n    super(options);\n    this._hash = crypto.createHash('sha1');\n    this._updated = false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    this._updated = true;\n    this._hash.update(chunk);\n    callback(null, chunk);\n  }\n\n  getHash() {\n    return this._hash.digest('hex');\n  }\n\n  test(sum) {\n    return this._updated && sum === this.getHash();\n  }\n}\nexports.HashStream = HashStream;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/fetchers/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tarball = exports.git = exports.copy = exports.base = undefined;\n\nvar _baseFetcher;\n\nfunction _load_baseFetcher() {\n  return _baseFetcher = _interopRequireDefault(require('./base-fetcher.js'));\n}\n\nvar _copyFetcher;\n\nfunction _load_copyFetcher() {\n  return _copyFetcher = _interopRequireDefault(require('./copy-fetcher.js'));\n}\n\nvar _gitFetcher;\n\nfunction _load_gitFetcher() {\n  return _gitFetcher = _interopRequireDefault(require('./git-fetcher.js'));\n}\n\nvar _tarballFetcher;\n\nfunction _load_tarballFetcher() {\n  return _tarballFetcher = _interopRequireDefault(require('./tarball-fetcher.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.base = (_baseFetcher || _load_baseFetcher()).default;\nexports.copy = (_copyFetcher || _load_copyFetcher()).default;\nexports.git = (_gitFetcher || _load_gitFetcher()).default;\nexports.tarball = (_tarballFetcher || _load_tarballFetcher()).default;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/fetchers/git-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _baseFetcher;\n\nfunction _load_baseFetcher() {\n  return _baseFetcher = _interopRequireDefault(require('./base-fetcher.js'));\n}\n\nvar _git;\n\nfunction _load_git() {\n  return _git = _interopRequireDefault(require('../util/git.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('../util/fs.js'));\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n  return _crypto = _interopRequireWildcard(require('../util/crypto.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst tar = require('tar');\n\nconst url = require('url');\nconst path = require('path');\nconst fs = require('fs');\n\nconst invariant = require('invariant');\n\nclass GitFetcher extends (_baseFetcher || _load_baseFetcher()).default {\n  _fetch() {\n    var _url$parse = url.parse(this.reference);\n\n    const protocol = _url$parse.protocol,\n          pathname = _url$parse.pathname;\n\n    if (protocol === null && typeof pathname === 'string') {\n      return this.fetchFromLocal(pathname);\n    } else {\n      return this.fetchFromExternal();\n    }\n  }\n\n  fetchFromLocal(pathname) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const ref = _this.reference,\n            config = _this.config;\n\n      const offlineMirrorPath = config.getOfflineMirrorPath() || '';\n      const localTarball = path.resolve(offlineMirrorPath, ref);\n      const reporter = config.reporter;\n\n      if (!(yield (_fs || _load_fs()).exists(localTarball))) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('tarballNotInNetworkOrCache', ref, localTarball));\n      }\n\n      return new Promise(function (resolve, reject) {\n        const untarStream = tar.Extract({ path: _this.dest });\n\n        const hashStream = new (_crypto || _load_crypto()).HashStream();\n\n        const cachedStream = fs.createReadStream(localTarball);\n        cachedStream.pipe(hashStream).pipe(untarStream).on('end', function () {\n          const expectHash = _this.hash;\n          const actualHash = hashStream.getHash();\n          if (!expectHash || expectHash === actualHash) {\n            resolve({\n              hash: actualHash,\n              resolved: `${pathname}#${actualHash}`\n            });\n          } else {\n            reject(new (_errors || _load_errors()).SecurityError(reporter.lang('fetchBadHash', expectHash, actualHash)));\n          }\n        }).on('error', function (err) {\n          reject(new (_errors || _load_errors()).MessageError(reporter.lang('fetchErrorCorrupt', err.message, localTarball)));\n        });\n      });\n    })();\n  }\n\n  fetchFromExternal() {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const commit = _this2.hash;\n      invariant(commit, 'Commit hash required');\n\n      const git = new (_git || _load_git()).default(_this2.config, _this2.reference, commit);\n      yield git.init();\n      yield git.clone(_this2.dest);\n\n      // Get the tarball filename from the url\n\n      var _url$parse2 = url.parse(_this2.reference);\n\n      const pathname = _url$parse2.pathname;\n\n      let tarballFilename;\n      if (pathname == null) {\n        tarballFilename = _this2.reference;\n      } else {\n        tarballFilename = path.basename(pathname);\n      }\n\n      let tarballInMirrorPath = _this2.config.getOfflineMirrorPath(tarballFilename);\n\n      const mirrorRootPath = _this2.config.getOfflineMirrorPath();\n      if (tarballInMirrorPath && _this2.hash && mirrorRootPath) {\n        tarballInMirrorPath = `${tarballInMirrorPath}-${commit}`;\n        const hash = yield git.archive(tarballInMirrorPath);\n        const relativeMirrorPath = path.relative(mirrorRootPath, tarballInMirrorPath);\n        return {\n          hash: commit,\n          resolved: relativeMirrorPath ? `${relativeMirrorPath}#${hash}` : null\n        };\n      }\n\n      return {\n        hash: commit,\n        resolved: null\n      };\n    })();\n  }\n}\nexports.default = GitFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/stream.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst invariant = require('invariant');\nconst stream = require('stream');\nconst zlib = require('zlib');\n\nfunction hasGzipHeader(chunk) {\n  return chunk[0] === 0x1F && chunk[1] === 0x8B && chunk[2] === 0x08;\n}\n\nclass UnpackStream extends stream.Transform {\n  constructor(options) {\n    super(options);\n    this._srcStream = null;\n    this._readHeader = false;\n    this.once('pipe', src => {\n      this._srcStream = src;\n    });\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!this._readHeader) {\n      this._readHeader = true;\n      invariant(chunk instanceof Buffer, 'Chunk must be a buffer');\n      if (hasGzipHeader(chunk)) {\n        // Stop receiving data from the src stream, and pipe it instead to zlib,\n        // then pipe it's output through us.\n        const unzipStream = zlib.createUnzip();\n        unzipStream.on('error', err => this.emit('error', err));\n\n        const srcStream = this._srcStream;\n        invariant(srcStream, 'How? To get here a stream must have been piped!');\n        srcStream.pipe(unzipStream).pipe(this);\n\n        // Unpipe after another stream has been piped so it's always piping to\n        // something, thus avoiding pausing it.\n        srcStream.unpipe(this);\n        unzipStream.write(chunk);\n        this._srcStream = null;\n        callback();\n        return;\n      }\n    }\n    callback(null, chunk);\n  }\n}\n\nexports.UnpackStream = UnpackStream;\nclass ConcatStream extends stream.Transform {\n  constructor(done) {\n    super();\n    this._data = [];\n    this._done = done;\n  }\n\n  _transform(chunk, encoding, callback) {\n    invariant(chunk instanceof Buffer, 'Chunk must be a buffer');\n    invariant(this._data != null, 'Missing data array');\n    this._data.push(chunk);\n    this.push(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    invariant(this._data != null, 'Missing data array');\n    this._done(Buffer.concat(this._data));\n    this._data = null;\n    callback();\n  }\n}\nexports.ConcatStream = ConcatStream;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-hoister.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HoistManifest = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nlet historyCounter = 0;\n\nclass HoistManifest {\n  constructor(key, parts, pkg, loc, isIgnored, inheritIsIgnored) {\n    this.isIgnored = isIgnored;\n    this.inheritIsIgnored = inheritIsIgnored;\n    this.loc = loc;\n    this.pkg = pkg;\n\n    this.key = key;\n    this.parts = parts;\n    this.originalKey = key;\n    this.previousKeys = [];\n\n    this.history = [];\n    this.addHistory(`Start position = ${key}`);\n  }\n\n  addHistory(msg) {\n    this.history.push(`${++historyCounter}: ${msg}`);\n  }\n}\n\nexports.HoistManifest = HoistManifest;\nclass PackageHoister {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.config = config;\n\n    this.taintedKeys = new Map();\n    this.levelQueue = [];\n    this.tree = new Map();\n  }\n\n  /**\n   * Taint this key and prevent any modules from being hoisted to it.\n   */\n\n  taintKey(key, info) {\n    const existingTaint = this.taintedKeys.get(key);\n    if (existingTaint && existingTaint.loc !== info.loc) {\n      return false;\n    } else {\n      this.taintedKeys.set(key, info);\n      return true;\n    }\n  }\n\n  /**\n   * Implode an array of ancestry parts into a key.\n   */\n\n  implodeKey(parts) {\n    return parts.join('#');\n  }\n\n  /**\n   * Seed the hoister with patterns taken from the included resolver.\n   */\n\n  seed(patterns) {\n    this.prepass(patterns);\n\n    for (const pattern of this.resolver.dedupePatterns(patterns)) {\n      this._seed(pattern);\n    }\n\n    while (true) {\n      let queue = this.levelQueue;\n      if (!queue.length) {\n        this._propagateNonIgnored();\n        return;\n      }\n\n      this.levelQueue = [];\n\n      // sort queue to get determinism between runs\n      queue = queue.sort((_ref, _ref2) => {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 1);\n\n        let aPattern = _ref4[0];\n\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 1);\n\n        let bPattern = _ref3[0];\n\n        return (0, (_misc || _load_misc()).sortAlpha)(aPattern, bPattern);\n      });\n\n      //\n      const infos = [];\n      for (const _ref5 of queue) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const pattern = _ref6[0];\n        const parents = _ref6[1];\n\n        const info = this._seed(pattern, parents);\n        if (info) {\n          infos.push(info);\n        }\n      }\n\n      //\n      for (const info of infos) {\n        this.hoist(info);\n      }\n    }\n  }\n\n  /**\n   * Seed the hoister with a specific pattern.\n   */\n\n  _seed(pattern, parent) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(pattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    let parentParts = [];\n    let isIgnored = ref.ignore;\n    let inheritIsIgnored = false;\n\n    if (parent) {\n      if (!this.tree.get(parent.key)) {\n        return null;\n      }\n      // non ignored dependencies inherit parent's ignored status\n      // parent may transition from ignored to non ignored when hoisted if it is used in another non ignored branch\n      if (!isIgnored && parent.isIgnored) {\n        isIgnored = parent.isIgnored;\n        inheritIsIgnored = true;\n      }\n      parentParts = parent.parts;\n    }\n\n    //\n    const loc = this.config.generateHardModulePath(ref);\n    const parts = parentParts.concat(pkg.name);\n    const key = this.implodeKey(parts);\n    const info = new HoistManifest(key, parts, pkg, loc, isIgnored, inheritIsIgnored);\n\n    //\n    this.tree.set(key, info);\n    this.taintKey(key, info);\n\n    //\n    for (const depPattern of ref.dependencies) {\n      this.levelQueue.push([depPattern, info]);\n    }\n\n    return info;\n  }\n\n  /**\n   * Propagate inherited ignore statuses from non-ignored to ignored packages\n  */\n\n  _propagateNonIgnored() {\n    //\n    const toVisit = [];\n\n    // enumerate all non-ignored packages\n    for (const entry of this.tree.entries()) {\n      if (!entry[1].isIgnored) {\n        toVisit.push(entry[1]);\n      }\n    }\n\n    // visit them\n    while (toVisit.length) {\n      const info = toVisit.shift();\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      for (const depPattern of ref.dependencies) {\n        const depinfo = this._lookupDependency(info, depPattern);\n        if (depinfo && depinfo.isIgnored && depinfo.inheritIsIgnored) {\n          depinfo.isIgnored = false;\n          info.addHistory(`Mark as non-ignored because of usage by ${info.key}`);\n          toVisit.push(depinfo);\n        }\n      }\n    }\n  }\n\n  /**\n   * Looks up the package a dependency resolves to\n  */\n\n  _lookupDependency(info, depPattern) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(depPattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    for (let i = info.parts.length; i >= 0; i--) {\n      const checkParts = info.parts.slice(0, i).concat(pkg.name);\n      const checkKey = this.implodeKey(checkParts);\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the highest position we can hoist this module to.\n   */\n\n  getNewParts(key, info, parts) {\n    let stepUp = false;\n\n    const fullKey = this.implodeKey(parts);\n    const stack = []; // stack of removed parts\n    const name = parts.pop();\n\n    //\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const checkParts = parts.slice(0, i).concat(name);\n      const checkKey = this.implodeKey(checkParts);\n      info.addHistory(`Looked at ${checkKey} for a match`);\n\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        if (existing.loc === info.loc) {\n          // switch to non ignored if earlier deduped version was ignored\n          if (existing.isIgnored && !info.isIgnored) {\n            existing.isIgnored = info.isIgnored;\n          }\n\n          existing.addHistory(`Deduped ${fullKey} to this item`);\n          return { parts: checkParts, duplicate: true };\n        } else {\n          // everything above will be shadowed and this is a conflict\n          info.addHistory(`Found a collision at ${checkKey}`);\n          break;\n        }\n      }\n\n      const existingTaint = this.taintedKeys.get(checkKey);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        info.addHistory(`Broken by ${checkKey}`);\n        break;\n      }\n    }\n\n    // remove redundant parts that wont collide\n    while (parts.length) {\n      const checkParts = parts.concat(name);\n      const checkKey = this.implodeKey(checkParts);\n\n      //\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        stepUp = true;\n        break;\n      }\n\n      // check if we're trying to hoist ourselves to a previously unflattened module key,\n      // this will result in a conflict and we'll need to move ourselves up\n      if (key !== checkKey && this.taintedKeys.has(checkKey)) {\n        stepUp = true;\n        break;\n      }\n\n      //\n      stack.push(parts.pop());\n    }\n\n    //\n    parts.push(name);\n\n    //\n    const isValidPosition = parts => {\n      const key = this.implodeKey(parts);\n      const existing = this.tree.get(key);\n      if (existing && existing.loc === info.loc) {\n        return true;\n      }\n\n      // ensure there's no taint or the taint is us\n      const existingTaint = this.taintedKeys.get(key);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        return false;\n      }\n\n      return true;\n    };\n\n    // we need to special case when we attempt to hoist to the top level as the `existing` logic\n    // wont be hit in the above `while` loop and we could conflict\n    if (!isValidPosition(parts)) {\n      stepUp = true;\n    }\n\n    // sometimes we need to step up to a parent module to install ourselves\n    while (stepUp && stack.length) {\n      info.addHistory(`Stepping up from ${this.implodeKey(parts)}`);\n\n      parts.pop(); // remove `name`\n      parts.push(stack.pop(), name);\n\n      if (isValidPosition(parts)) {\n        info.addHistory(`Found valid position ${this.implodeKey(parts)}`);\n        stepUp = false;\n      }\n    }\n\n    return { parts, duplicate: false };\n  }\n\n  /**\n   * Hoist all seeded patterns to their highest positions.\n   */\n\n  hoist(info) {\n    const key = info.key,\n          rawParts = info.parts;\n\n    // remove this item from the `tree` map so we can ignore it\n\n    this.tree.delete(key);\n\n    var _getNewParts = this.getNewParts(key, info, rawParts.slice());\n\n    const parts = _getNewParts.parts,\n          duplicate = _getNewParts.duplicate;\n\n    const newKey = this.implodeKey(parts);\n    const oldKey = key;\n    if (duplicate) {\n      info.addHistory(`Satisfied from above by ${newKey}`);\n      this.declareRename(info, rawParts, parts);\n      return;\n    }\n\n    // update to the new key\n    if (oldKey === newKey) {\n      info.addHistory(\"Didn't hoist - conflicts above\");\n      this.setKey(info, oldKey, parts);\n      return;\n    }\n\n    //\n    this.declareRename(info, rawParts, parts);\n    this.setKey(info, newKey, parts);\n  }\n\n  /**\n   * Declare that a module has been hoisted and update our internal references.\n   */\n\n  declareRename(info, oldParts, newParts) {\n    // go down the tree from our new position reserving our name\n    this.taintParents(info, oldParts.slice(0, -1), newParts.length - 1);\n  }\n\n  /**\n   * Crawl upwards through a list of ancestry parts and taint a package name.\n   */\n\n  taintParents(info, processParts, start) {\n    for (let i = start; i < processParts.length; i++) {\n      const parts = processParts.slice(0, i).concat(info.pkg.name);\n      const key = this.implodeKey(parts);\n\n      if (this.taintKey(key, info)) {\n        info.addHistory(`Tainted ${key} to prevent collisions`);\n      }\n    }\n  }\n\n  /**\n   * Update the key of a module and update our references.\n   */\n\n  setKey(info, newKey, parts) {\n    const oldKey = info.key;\n\n    info.key = newKey;\n    info.parts = parts;\n    this.tree.set(newKey, info);\n\n    if (oldKey === newKey) {\n      return;\n    }\n\n    info.previousKeys.push(newKey);\n    info.addHistory(`New position = ${newKey}`);\n  }\n\n  /**\n   * Perform a prepass and if there's multiple versions of the same package, hoist the one with\n   * the most dependents to the top.\n   */\n\n  prepass(patterns) {\n    patterns = this.resolver.dedupePatterns(patterns).sort();\n\n    const occurences = {};\n\n    // add an occuring package to the above data structure\n    const add = (pattern, ancestry) => {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      if (ancestry.indexOf(pkg) >= 0) {\n        // prevent recursive dependencies\n        return;\n      }\n\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n\n      const versions = occurences[pkg.name] = occurences[pkg.name] || {};\n      const version = versions[pkg.version] = versions[pkg.version] || { occurences: new Set(), pattern };\n      version.occurences.add(ancestry[ancestry.length - 1]);\n\n      for (const depPattern of ref.dependencies) {\n        add(depPattern, ancestry.concat(pkg));\n      }\n    };\n\n    // get a list of root package names since we can't hoist other dependencies to these spots!\n    const rootPackageNames = new Set();\n    for (const pattern of patterns) {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      rootPackageNames.add(pkg.name);\n    }\n\n    // seed occurences\n    for (const pattern of patterns) {\n      add(pattern, []);\n    }\n\n    for (const packageName of Object.keys(occurences).sort()) {\n      const versionOccurences = occurences[packageName];\n      const versions = Object.keys(versionOccurences);\n\n      if (versions.length === 1) {\n        // only one package type so we'll hoist this to the top anyway\n        continue;\n      }\n\n      if (this.tree.get(packageName)) {\n        // a transitive dependency of a previously hoisted dependency exists\n        continue;\n      }\n\n      if (rootPackageNames.has(packageName)) {\n        // can't replace top level packages\n        continue;\n      }\n\n      let mostOccurenceCount;\n      let mostOccurencePattern;\n      for (const version of Object.keys(versionOccurences).sort()) {\n        var _versionOccurences$ve = versionOccurences[version];\n        const occurences = _versionOccurences$ve.occurences,\n              pattern = _versionOccurences$ve.pattern;\n\n        const occurenceCount = occurences.size;\n\n        if (!mostOccurenceCount || occurenceCount > mostOccurenceCount) {\n          mostOccurenceCount = occurenceCount;\n          mostOccurencePattern = pattern;\n        }\n      }\n      invariant(mostOccurencePattern, 'expected most occuring pattern');\n      invariant(mostOccurenceCount, 'expected most occuring count');\n\n      // only hoist this module if it occured more than once\n      if (mostOccurenceCount > 1) {\n        this._seed(mostOccurencePattern);\n      }\n    }\n  }\n\n  /**\n   * Produce a flattened list of module locations and manifests.\n   */\n\n  init() {\n    const flatTree = [];\n\n    //\n    for (const _ref7 of this.tree.entries()) {\n      var _ref8 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref7, 2);\n\n      const key = _ref8[0];\n      const info = _ref8[1];\n\n      // decompress the location and push it to the flat tree. this path could be made\n      const parts = [];\n      const keyParts = key.split('#');\n      for (let i = 0; i < keyParts.length; i++) {\n        const key = keyParts.slice(0, i + 1).join('#');\n        const hoisted = this.tree.get(key);\n        invariant(hoisted, 'expected hoisted manifest');\n        parts.push(this.config.getFolder(hoisted.pkg));\n        parts.push(keyParts[i]);\n      }\n\n      if (this.config.modulesFolder) {\n        // remove the first part which will be the folder name and replace it with a\n        // hardcoded modules folder\n        parts.shift();\n        const modulesFolder = this.config.modulesFolder == null ? '' : this.config.modulesFolder;\n        parts.unshift(modulesFolder);\n      } else {\n        // first part will be the registry-specific module folder\n        const cwd = this.config.cwd == null ? '' : this.config.cwd;\n        parts.unshift(cwd);\n      }\n\n      const loc = path.join(...parts);\n      flatTree.push([loc, info]);\n    }\n\n    // remove ignored modules from the tree\n    const visibleFlatTree = [];\n    for (const _ref9 of flatTree) {\n      var _ref10 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref9, 2);\n\n      const loc = _ref10[0];\n      const info = _ref10[1];\n\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      if (info.isIgnored) {\n        info.addHistory('Deleted as this module was ignored');\n      } else {\n        visibleFlatTree.push([loc, info]);\n      }\n    }\n    return visibleFlatTree;\n  }\n}\n\nexports.default = PackageHoister;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/child.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exec = exports.queue = undefined;\nexports.spawn = spawn;\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('../constants.js'));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./blocking-queue.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('../errors.js');\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = require('./promise.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* global child_process$spawnOpts */\n\nconst child = require('child_process');\n\nconst queue = exports.queue = new (_blockingQueue || _load_blockingQueue()).default('child', (_constants || _load_constants()).CHILD_CONCURRENCY);\n\n// TODO: this uid check is kinda whack\nlet uid = 0;\n\nconst exec = exports.exec = (0, (_promise || _load_promise()).promisify)(child.exec);\n\nfunction spawn(program, args) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let onData = arguments[3];\n\n  return queue.push(opts.cwd || String(++uid), () => new Promise((resolve, reject) => {\n    const proc = child.spawn(program, args, opts);\n\n    let processingDone = false;\n    let processClosed = false;\n    let err = null;\n\n    let stdout = '';\n\n    proc.on('error', err => {\n      if (err.code === 'ENOENT') {\n        reject(new (_errors || _load_errors()).MessageError(`Couldn't find the binary ${program}`));\n      } else {\n        reject(err);\n      }\n    });\n\n    function updateStdout(chunk) {\n      stdout += chunk;\n      if (onData) {\n        onData(chunk);\n      }\n    }\n\n    function finish() {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stdout.trim());\n      }\n    }\n\n    if (typeof opts.process === 'function') {\n      opts.process(proc, updateStdout, reject, function () {\n        if (processClosed) {\n          finish();\n        } else {\n          processingDone = true;\n        }\n      });\n    } else {\n      if (proc.stderr) {\n        proc.stderr.on('data', updateStdout);\n      }\n\n      if (proc.stdout) {\n        proc.stdout.on('data', updateStdout);\n      }\n\n      processingDone = true;\n    }\n\n    proc.on('close', code => {\n      if (code >= 1) {\n        // TODO make this output nicer\n        err = new (_errors || _load_errors()).SpawnError(['Command failed.', `Exit code: ${code}`, `Command: ${program}`, `Arguments: ${args.join(' ')}`, `Directory: ${opts.cwd || process.cwd()}`, `Output:\\n${stdout.trim()}`].join('\\n'));\n        err.EXIT_CODE = code;\n      }\n\n      if (processingDone || err) {\n        finish();\n      } else {\n        processClosed = true;\n      }\n    });\n  }));\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/lockfile/stringify.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = stringify;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('../util/misc.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = require('../constants.js');\n}\n\nfunction shouldWrapKey(str) {\n  return str.indexOf('true') === 0 || str.indexOf('false') === 0 || /[:\\s\\n\\\\\",\\[\\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);\n}\n\nfunction maybeWrap(str) {\n  if (typeof str === 'boolean' || typeof str === 'number' || shouldWrapKey(str)) {\n    return JSON.stringify(str);\n  } else {\n    return str;\n  }\n}\n\nconst priorities = {\n  name: 1,\n  version: 2,\n  uid: 3,\n  resolved: 4,\n  registry: 5,\n  dependencies: 6\n};\n\nfunction priorityThenAlphaSort(a, b) {\n  if (priorities[a] || priorities[b]) {\n    return (priorities[a] || 100) > (priorities[b] || 100) ? 1 : -1;\n  } else {\n    return (0, (_misc || _load_misc()).sortAlpha)(a, b);\n  }\n}\n\nfunction _stringify(obj, options) {\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  }\n\n  const indent = options.indent;\n  const lines = [];\n\n  // Sorting order needs to be consistent between runs, we run native sort by name because there are no\n  // problems with it being unstable because there are no to keys the same\n  // However priorities can be duplicated and native sort can shuffle things from run to run\n  const keys = Object.keys(obj).sort(priorityThenAlphaSort);\n\n  let addedKeys = [];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const val = obj[key];\n    if (val == null || addedKeys.indexOf(key) >= 0) {\n      continue;\n    }\n\n    //\n    const valKeys = [key];\n\n    // get all keys that have the same value equality, we only want this for objects\n    if (typeof val === 'object') {\n      for (let j = i + 1; j < keys.length; j++) {\n        const key = keys[j];\n        if (val === obj[key]) {\n          valKeys.push(key);\n        }\n      }\n    }\n\n    //\n    const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(', ');\n\n    if (typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number') {\n      lines.push(`${keyLine} ${maybeWrap(val)}`);\n    } else if (typeof val === 'object') {\n      lines.push(`${keyLine}:\\n${_stringify(val, { indent: indent + '  ' })}` + (options.topLevel ? '\\n' : ''));\n    } else {\n      throw new TypeError();\n    }\n\n    addedKeys = addedKeys.concat(valKeys);\n  }\n\n  return indent + lines.join(`\\n${indent}`);\n}\n\nfunction stringify(obj, noHeader) {\n  const val = _stringify(obj, {\n    indent: '',\n    topLevel: true\n  });\n  if (noHeader) {\n    return val;\n  }\n\n  return ['# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.', `# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`, '\\n', val].join('\\n');\n}"}