{"/home/travis/build/npmtest/node-npmtest-yarn/test.js":"/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/lib.npmtest_yarn.js":"/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_yarn = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_yarn = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-yarn && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_yarn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_yarn\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_yarn.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_yarn.rollup.js'] =\n            local.assetsDict['/assets.npmtest_yarn.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_yarn.__dirname +\n                    '/lib.npmtest_yarn.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/api.js":"\"use strict\";","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/config.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = require('./util/execute-lifecycle-script.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireDefault(require('./util/normalize-manifest/index.js'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _packageConstraintResolver;\n\nfunction _load_packageConstraintResolver() {\n  return _packageConstraintResolver = _interopRequireDefault(require('./package-constraint-resolver.js'));\n}\n\nvar _requestManager;\n\nfunction _load_requestManager() {\n  return _requestManager = _interopRequireDefault(require('./util/request-manager.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('./registries/index.js');\n}\n\nvar _index3;\n\nfunction _load_index3() {\n  return _index3 = require('./reporters/index.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst detectIndent = require('detect-indent');\nconst invariant = require('invariant');\nconst path = require('path');\n\nfunction sortObject(object) {\n  const sortedObject = {};\n  Object.keys(object).sort().forEach(item => {\n    sortedObject[item] = object[item];\n  });\n  return sortedObject;\n}\n\nclass Config {\n  constructor(reporter) {\n    this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).default(this, reporter);\n    this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);\n    this.reporter = reporter;\n    this._init({});\n  }\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  // Whether we should ignore executing lifecycle scripts\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  //\n\n\n  /**\n   * Execute a promise produced by factory if it doesn't exist in our cache with\n   * the associated key.\n   */\n\n  getCache(key, factory) {\n    const cached = this.cache[key];\n    if (cached) {\n      return cached;\n    }\n\n    return this.cache[key] = factory().catch(err => {\n      this.cache[key] = null;\n      throw err;\n    });\n  }\n\n  /**\n   * Get a config option from our yarn config.\n   */\n\n  getOption(key) {\n    return this.registries.yarn.getOption(key);\n  }\n\n  /**\n   * Reduce a list of versions to a single one based on an input range.\n   */\n\n  resolveConstraints(versions, range) {\n    return this.constraintResolver.reduce(versions, range);\n  }\n\n  /**\n   * Initialise config. Fetch registry options, find package roots.\n   */\n\n  init() {\n    var _this = this;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this._init(opts);\n\n      yield (_fs || _load_fs()).mkdirp(_this.globalFolder);\n      yield (_fs || _load_fs()).mkdirp(_this.linkFolder);\n\n      _this.linkedModules = [];\n\n      const linkedModules = yield (_fs || _load_fs()).readdir(_this.linkFolder);\n\n      for (const dir of linkedModules) {\n        const linkedPath = path.join(_this.linkFolder, dir);\n\n        if (dir[0] === '@') {\n          // it's a scope, not a package\n          const scopedLinked = yield (_fs || _load_fs()).readdir(linkedPath);\n          _this.linkedModules.push(...scopedLinked.map(function (scopedDir) {\n            return path.join(dir, scopedDir);\n          }));\n        } else {\n          _this.linkedModules.push(dir);\n        }\n      }\n\n      for (const key of Object.keys((_index2 || _load_index2()).registries)) {\n        const Registry = (_index2 || _load_index2()).registries[key];\n\n        // instantiate registry\n        const registry = new Registry(_this.cwd, _this.registries, _this.requestManager);\n        yield registry.init();\n\n        _this.registries[key] = registry;\n        _this.registryFolders.push(registry.folder);\n        const rootModuleFolder = path.join(_this.cwd, registry.folder);\n        if (_this.rootModuleFolders.indexOf(rootModuleFolder) < 0) {\n          _this.rootModuleFolders.push(rootModuleFolder);\n        }\n      }\n\n      _this.networkConcurrency = opts.networkConcurrency || Number(_this.getOption('network-concurrency')) || (_constants || _load_constants()).NETWORK_CONCURRENCY;\n\n      _this.requestManager.setOptions({\n        userAgent: String(_this.getOption('user-agent')),\n        httpProxy: String(opts.httpProxy || _this.getOption('proxy') || ''),\n        httpsProxy: String(opts.httpsProxy || _this.getOption('https-proxy') || ''),\n        strictSSL: Boolean(_this.getOption('strict-ssl')),\n        ca: Array.prototype.concat(opts.ca || _this.getOption('ca') || []).map(String),\n        cafile: String(opts.cafile || _this.getOption('cafile') || ''),\n        cert: String(opts.cert || _this.getOption('cert') || ''),\n        key: String(opts.key || _this.getOption('key') || ''),\n        networkConcurrency: _this.networkConcurrency\n      });\n      _this._cacheRootFolder = String(opts.cacheFolder || _this.getOption('cache-folder') || (_constants || _load_constants()).MODULE_CACHE_DIRECTORY);\n\n      //init & create cacheFolder, tempFolder\n      _this.cacheFolder = path.join(_this._cacheRootFolder, 'v' + String((_constants || _load_constants()).CACHE_VERSION));\n      _this.tempFolder = opts.tempFolder || path.join(_this.cacheFolder, '.tmp');\n      yield (_fs || _load_fs()).mkdirp(_this.cacheFolder);\n      yield (_fs || _load_fs()).mkdirp(_this.tempFolder);\n\n      if (opts.production === 'false') {\n        _this.production = false;\n      } else if (_this.getOption('production') || process.env.NODE_ENV === 'production' && process.env.NPM_CONFIG_PRODUCTION !== 'false' && process.env.YARN_PRODUCTION !== 'false') {\n        _this.production = true;\n      } else {\n        _this.production = !!opts.production;\n      }\n    })();\n  }\n\n  _init(opts) {\n    this.rootModuleFolders = [];\n    this.registryFolders = [];\n    this.linkedModules = [];\n\n    this.registries = (0, (_map || _load_map()).default)();\n    this.cache = (0, (_map || _load_map()).default)();\n    this.cwd = opts.cwd || this.cwd || process.cwd();\n\n    this.looseSemver = opts.looseSemver == undefined ? true : opts.looseSemver;\n\n    this.commandName = opts.commandName || '';\n\n    this.preferOffline = !!opts.preferOffline;\n    this.modulesFolder = opts.modulesFolder;\n    this.globalFolder = opts.globalFolder || (_constants || _load_constants()).GLOBAL_MODULE_DIRECTORY;\n    this.linkFolder = opts.linkFolder || (_constants || _load_constants()).LINK_REGISTRY_DIRECTORY;\n    this.offline = !!opts.offline;\n    this.binLinks = !!opts.binLinks;\n\n    this.ignorePlatform = !!opts.ignorePlatform;\n    this.ignoreScripts = !!opts.ignoreScripts;\n\n    this.nonInteractive = !!opts.nonInteractive;\n\n    this.requestManager.setOptions({\n      offline: !!opts.offline && !opts.preferOffline,\n      captureHar: !!opts.captureHar\n    });\n\n    if (this.modulesFolder) {\n      this.rootModuleFolders.push(this.modulesFolder);\n    }\n  }\n\n  /**\n   * Generate an absolute module path.\n   */\n\n  generateHardModulePath(pkg, ignoreLocation) {\n    invariant(this.cacheFolder, 'No package root');\n    invariant(pkg, 'Undefined package');\n\n    if (pkg.location && !ignoreLocation) {\n      return pkg.location;\n    }\n\n    let name = pkg.name;\n    let uid = pkg.uid;\n    if (pkg.registry) {\n      name = `${pkg.registry}-${name}`;\n    }\n\n    const hash = pkg.remote.hash;\n\n\n    if (pkg.version && pkg.version !== pkg.uid) {\n      uid = `${pkg.version}-${uid}`;\n    } else if (hash) {\n      uid += `-${hash}`;\n    }\n\n    return path.join(this.cacheFolder, `${name}-${uid}`);\n  }\n\n  /**\n   * Execute lifecycle scripts in the specified directory. Ignoring when the --ignore-scripts flag has been\n   * passed.\n   */\n\n  executeLifecycleScript(commandName, cwd) {\n    if (this.ignoreScripts) {\n      return Promise.resolve();\n    } else {\n      return (0, (_executeLifecycleScript || _load_executeLifecycleScript()).execFromManifest)(this, commandName, cwd || this.cwd);\n    }\n  }\n\n  /**\n   * Generate an absolute temporary filename location based on the input filename.\n   */\n\n  getTemp(filename) {\n    invariant(this.tempFolder, 'No temp folder');\n    return path.join(this.tempFolder, filename);\n  }\n\n  /**\n   * Remote packages may be cached in a file system to be available for offline installation.\n   * Second time the same package needs to be installed it will be loaded from there.\n   * Given a package's filename, return a path in the offline mirror location.\n   */\n\n  getOfflineMirrorPath(packageFilename) {\n    let mirrorPath;\n\n    for (const key of ['npm', 'yarn']) {\n      const registry = this.registries[key];\n\n      if (registry == null) {\n        continue;\n      }\n\n      const registryMirrorPath = registry.config['yarn-offline-mirror'];\n\n      if (registryMirrorPath == null) {\n        continue;\n      }\n\n      mirrorPath = registryMirrorPath;\n    }\n\n    if (mirrorPath == null) {\n      return null;\n    }\n\n    if (packageFilename == null) {\n      return mirrorPath;\n    }\n\n    return path.join(mirrorPath, path.basename(packageFilename));\n  }\n\n  /**\n   * Checker whether the folder input is a valid module folder. We output a yarn metadata\n   * file when we've successfully setup a folder so use this as a marker.\n   */\n\n  isValidModuleDest(dest) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (!(yield (_fs || _load_fs()).exists(dest))) {\n        return false;\n      }\n\n      if (!(yield (_fs || _load_fs()).exists(path.join(dest, (_constants || _load_constants()).METADATA_FILENAME)))) {\n        return false;\n      }\n\n      return true;\n    })();\n  }\n\n  /**\n   * Read package metadata and normalized package info.\n   */\n\n  readPackageMetadata(dir) {\n    var _this2 = this;\n\n    return this.getCache(`metadata-${dir}`, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const metadata = yield _this2.readJson(path.join(dir, (_constants || _load_constants()).METADATA_FILENAME));\n      const pkg = yield _this2.readManifest(dir, metadata.registry);\n\n      return {\n        package: pkg,\n        artifacts: metadata.artifacts || [],\n        hash: metadata.hash,\n        remote: metadata.remote,\n        registry: metadata.registry\n      };\n    }));\n  }\n\n  /**\n   * Read normalized package info according yarn-metadata.json\n   * throw an error if package.json was not found\n   */\n\n  readManifest(dir, priorityRegistry) {\n    var _this3 = this;\n\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifest = yield _this3.maybeReadManifest(dir, priorityRegistry, isRoot);\n\n      if (manifest) {\n        return manifest;\n      } else {\n        throw new (_errors || _load_errors()).MessageError(_this3.reporter.lang('couldntFindPackagejson', dir), 'ENOENT');\n      }\n    })();\n  }\n\n  /**\n  * try get the manifest file by looking\n  * 1. mainfest file in cache\n  * 2. manifest file in registry\n  */\n  maybeReadManifest(dir, priorityRegistry) {\n    var _this4 = this;\n\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return this.getCache(`manifest-${dir}`, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const metadataLoc = path.join(dir, (_constants || _load_constants()).METADATA_FILENAME);\n      if (!priorityRegistry && (yield (_fs || _load_fs()).exists(metadataLoc))) {\n        var _ref3 = yield _this4.readJson(metadataLoc);\n\n        priorityRegistry = _ref3.registry;\n      }\n\n      if (priorityRegistry) {\n        const file = yield _this4.tryManifest(dir, priorityRegistry, isRoot);\n        if (file) {\n          return file;\n        }\n      }\n\n      for (const registry of Object.keys((_index2 || _load_index2()).registries)) {\n        if (priorityRegistry === registry) {\n          continue;\n        }\n\n        const file = yield _this4.tryManifest(dir, registry, isRoot);\n        if (file) {\n          return file;\n        }\n      }\n\n      return null;\n    }));\n  }\n\n  /**\n   * Read the root manifest.\n   */\n\n  readRootManifest() {\n    return this.readManifest(this.cwd, 'npm', true);\n  }\n\n  /**\n   * Try and find package info with the input directory and registry.\n   */\n\n  tryManifest(dir, registry, isRoot) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const filename = (_index2 || _load_index2()).registries[registry].filename;\n\n      const loc = path.join(dir, filename);\n      if (yield (_fs || _load_fs()).exists(loc)) {\n        const data = yield _this5.readJson(loc);\n        data._registry = registry;\n        data._loc = loc;\n        return (0, (_index || _load_index()).default)(data, dir, _this5, isRoot);\n      } else {\n        return null;\n      }\n    })();\n  }\n\n  /**\n   * Description\n   */\n\n  getFolder(pkg) {\n    let registryName = pkg._registry;\n    if (!registryName) {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      registryName = ref.registry;\n    }\n    return this.registries[registryName].folder;\n  }\n\n  /**\n   * Get root manifests.\n   */\n\n  getRootManifests() {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const manifests = {};\n      for (const registryName of (_index2 || _load_index2()).registryNames) {\n        const registry = (_index2 || _load_index2()).registries[registryName];\n        const jsonLoc = path.join(_this6.cwd, registry.filename);\n\n        let object = {};\n        let exists = false;\n        let indent;\n        if (yield (_fs || _load_fs()).exists(jsonLoc)) {\n          exists = true;\n\n          const info = yield _this6.readJson(jsonLoc, (_fs || _load_fs()).readJsonAndFile);\n          object = info.object;\n          indent = detectIndent(info.content).indent || undefined;\n        }\n        manifests[registryName] = { loc: jsonLoc, object, exists, indent };\n      }\n      return manifests;\n    })();\n  }\n\n  /**\n   * Save root manifests.\n   */\n\n  saveRootManifests(manifests) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      for (const registryName of (_index2 || _load_index2()).registryNames) {\n        var _manifests$registryNa = manifests[registryName];\n        const loc = _manifests$registryNa.loc,\n              object = _manifests$registryNa.object,\n              exists = _manifests$registryNa.exists,\n              indent = _manifests$registryNa.indent;\n\n        if (!exists && !Object.keys(object).length) {\n          continue;\n        }\n\n        for (const field of (_constants || _load_constants()).DEPENDENCY_TYPES) {\n          if (object[field]) {\n            object[field] = sortObject(object[field]);\n          }\n        }\n\n        yield (_fs || _load_fs()).writeFilePreservingEol(loc, JSON.stringify(object, null, indent || (_constants || _load_constants()).DEFAULT_INDENT) + '\\n');\n      }\n    })();\n  }\n\n  /**\n   * Call the passed factory (defaults to fs.readJson) and rethrow a pretty error message if it was the result\n   * of a syntax error.\n   */\n\n  readJson(loc) {\n    var _this7 = this;\n\n    let factory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_fs || _load_fs()).readJson;\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield factory(loc);\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          throw new (_errors || _load_errors()).MessageError(_this7.reporter.lang('jsonError', loc, err.message));\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  static create() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let reporter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_index3 || _load_index3()).NoopReporter();\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const config = new Config(reporter);\n      yield config.init(opts);\n      return config;\n    })();\n  }\n}\nexports.default = Config;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/constants.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathKey = getPathKey;\nexports.isRootUser = isRootUser;\nconst path = require('path');\nconst userHome = require('./util/user-home-dir').default;\n\nconst DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];\n\nconst YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';\n\nconst YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';\nconst YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';\nconst YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';\n\nconst SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version';\nconst SELF_UPDATE_TARBALL_URL = exports.SELF_UPDATE_TARBALL_URL = 'https://yarnpkg.com/latest.tar.gz';\nconst SELF_UPDATE_DOWNLOAD_FOLDER = exports.SELF_UPDATE_DOWNLOAD_FOLDER = 'updates';\n\n// cache version, bump whenever we make backwards incompatible changes\nconst CACHE_VERSION = exports.CACHE_VERSION = 1;\n\n// lockfile version, bump whenever we make backwards incompatible changes\nconst LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1;\n\n// max amount of network requests to perform concurrently\nconst NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8;\n\n// max amount of child processes to execute concurrently\nconst CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;\n\nconst REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];\n\nfunction getDirectory(category) {\n  // use %LOCALAPPDATA%/Yarn on Windows\n  if (process.platform === 'win32' && process.env.LOCALAPPDATA) {\n    return path.join(process.env.LOCALAPPDATA, 'Yarn', category);\n  }\n\n  // otherwise use ~/.{category}/yarn\n  return path.join(userHome, `.${category}`, 'yarn');\n}\n\nfunction getCacheDirectory() {\n  if (process.platform === 'darwin') {\n    return path.join(userHome, 'Library', 'Caches', 'Yarn');\n  }\n\n  return getDirectory('cache');\n}\n\nconst MODULE_CACHE_DIRECTORY = exports.MODULE_CACHE_DIRECTORY = getCacheDirectory();\nconst CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getDirectory('config');\nconst LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(CONFIG_DIRECTORY, 'link');\nconst GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(CONFIG_DIRECTORY, 'global');\nconst CACHE_FILENAME = exports.CACHE_FILENAME = path.join(MODULE_CACHE_DIRECTORY, '.roadrunner.json');\n\nconst INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';\nconst LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';\nconst METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';\nconst TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';\nconst CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';\n\nconst DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';\nconst SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;\nconst SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';\n\nconst ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);\n\nfunction getPathKey(platform, env) {\n  let pathKey = 'PATH';\n\n  // windows calls its path \"Path\" usually, but this is not guaranteed.\n  if (platform === 'win32') {\n    pathKey = 'Path';\n\n    for (const key in env) {\n      if (key.toLowerCase() === 'path') {\n        pathKey = key;\n      }\n    }\n  }\n\n  return pathKey;\n}\n\nfunction getUid() {\n  if (process.platform !== 'win32' && process.getuid) {\n    return process.getuid();\n  }\n  return null;\n}\n\nconst ROOT_USER = exports.ROOT_USER = isRootUser(getUid());\n\nfunction isRootUser(uid) {\n  return uid === 0;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/user-home-dir.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst path = require('path');\n\nvar _require = require('../constants');\n\nconst ROOT_USER = _require.ROOT_USER;\n\n\nconst userHomeDir = process.platform === 'linux' && ROOT_USER ? path.resolve('/usr/local/share') : require('os').homedir();\n\nexports.default = userHomeDir;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/errors.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MessageError extends Error {\n  constructor(msg, code) {\n    super(msg);\n    this.code = code;\n  }\n\n}\n\nexports.MessageError = MessageError;\nclass SecurityError extends MessageError {}\n\nexports.SecurityError = SecurityError;\nclass SpawnError extends MessageError {}\nexports.SpawnError = SpawnError;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-compatibility.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testEngine = testEngine;\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\n\nconst semver = require('semver');\n\nconst VERSIONS = Object.assign({}, process.versions, {\n  yarn: require('../package.json').version\n});\n\nfunction isValid(items, actual) {\n  let isNotWhitelist = true;\n  let isBlacklist = false;\n\n  for (const item of items) {\n    // blacklist\n    if (item[0] === '!') {\n      isBlacklist = true;\n\n      if (actual === item.slice(1)) {\n        return false;\n      }\n      // whitelist\n    } else {\n      isNotWhitelist = false;\n\n      if (item === actual) {\n        return true;\n      }\n    }\n  }\n\n  // npm allows blacklists and whitelists to be mixed. Blacklists with\n  // whitelisted items should be treated as whitelists.\n  return isBlacklist && isNotWhitelist;\n}\n\nconst aliases = (0, (_map || _load_map()).default)({\n  iojs: 'node' });\n\nconst ignore = ['npm', // we'll never satisfy this for obvious reasons\n'teleport', // a module bundler used by some modules\n'rhino'];\n\nfunction testEngine(name, range, versions, looseSemver) {\n  const actual = versions[name];\n  if (!actual) {\n    return false;\n  }\n\n  if (!semver.valid(actual, looseSemver)) {\n    return false;\n  }\n\n  if (semver.satisfies(actual, range, looseSemver)) {\n    return true;\n  }\n\n  if (name === 'node' && semver.gt(actual, '1.0.0', looseSemver)) {\n    // WARNING: this is a massive hack and is super gross but necessary for compatibility\n    // some modules have the `engines.node` field set to a caret version below semver major v1\n    // eg. ^0.12.0. this is problematic as we enforce engines checks and node is now on version >=1\n    // to allow this pattern we transform the node version to fake ones in the minor range 10-13\n    const major = semver.major(actual, looseSemver);\n    const fakes = [`0.10.${major}`, `0.11.${major}`, `0.12.${major}`, `0.13.${major}`];\n    for (const actualFake of fakes) {\n      if (semver.satisfies(actualFake, range, looseSemver)) {\n        return true;\n      }\n    }\n  }\n\n  // incompatible version\n  return false;\n}\n\nclass PackageCompatibility {\n  constructor(config, resolver, ignoreEngines) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n    this.ignoreEngines = ignoreEngines;\n  }\n\n  static isValidArch(archs) {\n    return isValid(archs, process.arch);\n  }\n\n  static isValidPlatform(platforms) {\n    return isValid(platforms, process.platform);\n  }\n\n  check(info) {\n    let didIgnore = false;\n    let didError = false;\n    const reporter = this.reporter;\n    const human = `${info.name}@${info.version}`;\n\n    const pushError = msg => {\n      const ref = info._reference;\n      invariant(ref, 'expected package reference');\n\n      if (ref.optional) {\n        ref.ignore = true;\n\n        reporter.warn(`${human}: ${msg}`);\n        if (!didIgnore) {\n          reporter.info(reporter.lang('optionalCompatibilityExcluded', human));\n          didIgnore = true;\n        }\n      } else {\n        reporter.error(`${human}: ${msg}`);\n        didError = true;\n      }\n    };\n\n    const invalidPlatform = !this.config.ignorePlatform && Array.isArray(info.os) && info.os.length > 0 && !PackageCompatibility.isValidPlatform(info.os);\n    if (invalidPlatform) {\n      pushError(this.reporter.lang('incompatibleOS', process.platform));\n    }\n\n    const invalidCpu = !this.config.ignorePlatform && Array.isArray(info.cpu) && info.cpu.length > 0 && !PackageCompatibility.isValidArch(info.cpu);\n    if (invalidCpu) {\n      pushError(this.reporter.lang('incompatibleCPU', process.arch));\n    }\n\n    if (!this.ignoreEngines && typeof info.engines === 'object') {\n      for (const entry of (0, (_misc || _load_misc()).entries)(info.engines)) {\n        let name = entry[0];\n        const range = entry[1];\n\n        if (aliases[name]) {\n          name = aliases[name];\n        }\n\n        if (VERSIONS[name]) {\n          if (!testEngine(name, range, VERSIONS, this.config.looseSemver)) {\n            pushError(this.reporter.lang('incompatibleEngine', name, range));\n          }\n        } else if (ignore.indexOf(name) < 0) {\n          this.reporter.warn(`${human}: ${this.reporter.lang('invalidEngine', name)}`);\n        }\n      }\n    }\n\n    if (didError) {\n      throw new (_errors || _load_errors()).MessageError(reporter.lang('foundIncompatible'));\n    }\n  }\n\n  init() {\n    const infos = this.resolver.getManifests();\n    for (const info of infos) {\n      this.check(info);\n    }\n    return Promise.resolve();\n  }\n}\nexports.default = PackageCompatibility;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/map.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = nullify;\nfunction nullify() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (Array.isArray(obj)) {\n    for (const item of obj) {\n      nullify(item);\n    }\n  } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {\n    Object.setPrototypeOf(obj, null);\n\n    // for..in can only be applied to 'object', not 'function'\n    if (typeof obj === 'object') {\n      for (const key in obj) {\n        nullify(obj[key]);\n      }\n    }\n  }\n\n  return obj;\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-constraint-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst semver = require('semver');\n\n// This isn't really a \"proper\" constraint resolver. We just return the highest semver\n// version in the versions passed that satisfies the input range. This vastly reduces\n// the complexity and is very efficient for package resolution.\n\nclass PackageConstraintResolver {\n  constructor(config, reporter) {\n    this.reporter = reporter;\n    this.config = config;\n  }\n\n  reduce(versions, range) {\n    if (range === 'latest') {\n      // Usually versions are already ordered and the last one is the latest\n      return Promise.resolve(versions[versions.length - 1]);\n    } else {\n      return Promise.resolve(semver.maxSatisfying(versions, range, this.config.looseSemver));\n    }\n  }\n}\nexports.default = PackageConstraintResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-fetcher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./fetchers/index.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageFetcher {\n  constructor(config, resolver) {\n    this.reporter = config.reporter;\n    this.resolver = resolver;\n    this.config = config;\n  }\n\n  fetchCache(dest, fetcher) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref = yield _this.config.readPackageMetadata(dest);\n\n      const hash = _ref.hash,\n            pkg = _ref.package;\n\n      return {\n        package: pkg,\n        resolved: yield fetcher.getResolvedFromCached(hash),\n        hash,\n        dest,\n        cached: true\n      };\n    })();\n  }\n\n  fetch(ref) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const dest = _this2.config.generateHardModulePath(ref);\n\n      const remote = ref.remote;\n      const Fetcher = (_index || _load_index())[remote.type];\n      if (!Fetcher) {\n        throw new (_errors || _load_errors()).MessageError(_this2.reporter.lang('unknownFetcherFor', remote.type));\n      }\n\n      const fetcher = new Fetcher(dest, remote, _this2.config);\n\n      if (yield _this2.config.isValidModuleDest(dest)) {\n        return _this2.fetchCache(dest, fetcher);\n      }\n\n      // remove as the module may be invalid\n      yield (_fs || _load_fs()).unlink(dest);\n\n      try {\n        return yield fetcher.fetch();\n      } catch (err) {\n        try {\n          yield (_fs || _load_fs()).unlink(dest);\n        } catch (err2) {\n          // what do?\n        }\n        throw err;\n      }\n    })();\n  }\n\n  maybeFetch(ref) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      try {\n        return yield _this3.fetch(ref);\n      } catch (err) {\n        if (ref.optional) {\n          _this3.reporter.error(err.message);\n          return null;\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  init() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const pkgs = _this4.resolver.getPackageReferences();\n      const tick = _this4.reporter.progress(pkgs.length);\n\n      yield (_promise || _load_promise()).queue(pkgs, (() => {\n        var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (ref) {\n          const res = yield _this4.maybeFetch(ref);\n          let newPkg;\n\n          if (res) {\n            newPkg = res.package;\n\n            // update with new remote\n            // but only if there was a hash previously as the tarball fetcher does not provide a hash.\n            if (ref.remote.hash) {\n              ref.remote.hash = res.hash;\n            }\n\n            if (res.resolved) {\n              ref.remote.resolved = res.resolved;\n            }\n          }\n\n          if (newPkg) {\n            // update with fresh manifest\n            yield _this4.resolver.updateManifest(ref, newPkg);\n          }\n\n          if (tick) {\n            tick(ref.name);\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      })(), _this4.config.networkConcurrency);\n    })();\n  }\n}\nexports.default = PackageFetcher;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-hoister.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HoistManifest = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nlet historyCounter = 0;\n\nclass HoistManifest {\n  constructor(key, parts, pkg, loc, isIgnored, inheritIsIgnored) {\n    this.isIgnored = isIgnored;\n    this.inheritIsIgnored = inheritIsIgnored;\n    this.loc = loc;\n    this.pkg = pkg;\n\n    this.key = key;\n    this.parts = parts;\n    this.originalKey = key;\n    this.previousKeys = [];\n\n    this.history = [];\n    this.addHistory(`Start position = ${key}`);\n  }\n\n  addHistory(msg) {\n    this.history.push(`${++historyCounter}: ${msg}`);\n  }\n}\n\nexports.HoistManifest = HoistManifest;\nclass PackageHoister {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.config = config;\n\n    this.taintedKeys = new Map();\n    this.levelQueue = [];\n    this.tree = new Map();\n  }\n\n  /**\n   * Taint this key and prevent any modules from being hoisted to it.\n   */\n\n  taintKey(key, info) {\n    const existingTaint = this.taintedKeys.get(key);\n    if (existingTaint && existingTaint.loc !== info.loc) {\n      return false;\n    } else {\n      this.taintedKeys.set(key, info);\n      return true;\n    }\n  }\n\n  /**\n   * Implode an array of ancestry parts into a key.\n   */\n\n  implodeKey(parts) {\n    return parts.join('#');\n  }\n\n  /**\n   * Seed the hoister with patterns taken from the included resolver.\n   */\n\n  seed(patterns) {\n    this.prepass(patterns);\n\n    for (const pattern of this.resolver.dedupePatterns(patterns)) {\n      this._seed(pattern);\n    }\n\n    while (true) {\n      let queue = this.levelQueue;\n      if (!queue.length) {\n        this._propagateNonIgnored();\n        return;\n      }\n\n      this.levelQueue = [];\n\n      // sort queue to get determinism between runs\n      queue = queue.sort((_ref, _ref2) => {\n        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 1);\n\n        let aPattern = _ref4[0];\n\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 1);\n\n        let bPattern = _ref3[0];\n\n        return (0, (_misc || _load_misc()).sortAlpha)(aPattern, bPattern);\n      });\n\n      //\n      const infos = [];\n      for (const _ref5 of queue) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const pattern = _ref6[0];\n        const parents = _ref6[1];\n\n        const info = this._seed(pattern, parents);\n        if (info) {\n          infos.push(info);\n        }\n      }\n\n      //\n      for (const info of infos) {\n        this.hoist(info);\n      }\n    }\n  }\n\n  /**\n   * Seed the hoister with a specific pattern.\n   */\n\n  _seed(pattern, parent) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(pattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    let parentParts = [];\n    let isIgnored = ref.ignore;\n    let inheritIsIgnored = false;\n\n    if (parent) {\n      if (!this.tree.get(parent.key)) {\n        return null;\n      }\n      // non ignored dependencies inherit parent's ignored status\n      // parent may transition from ignored to non ignored when hoisted if it is used in another non ignored branch\n      if (!isIgnored && parent.isIgnored) {\n        isIgnored = parent.isIgnored;\n        inheritIsIgnored = true;\n      }\n      parentParts = parent.parts;\n    }\n\n    //\n    const loc = this.config.generateHardModulePath(ref);\n    const parts = parentParts.concat(pkg.name);\n    const key = this.implodeKey(parts);\n    const info = new HoistManifest(key, parts, pkg, loc, isIgnored, inheritIsIgnored);\n\n    //\n    this.tree.set(key, info);\n    this.taintKey(key, info);\n\n    //\n    for (const depPattern of ref.dependencies) {\n      this.levelQueue.push([depPattern, info]);\n    }\n\n    return info;\n  }\n\n  /**\n   * Propagate inherited ignore statuses from non-ignored to ignored packages\n  */\n\n  _propagateNonIgnored() {\n    //\n    const toVisit = [];\n\n    // enumerate all non-ignored packages\n    for (const entry of this.tree.entries()) {\n      if (!entry[1].isIgnored) {\n        toVisit.push(entry[1]);\n      }\n    }\n\n    // visit them\n    while (toVisit.length) {\n      const info = toVisit.shift();\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      for (const depPattern of ref.dependencies) {\n        const depinfo = this._lookupDependency(info, depPattern);\n        if (depinfo && depinfo.isIgnored && depinfo.inheritIsIgnored) {\n          depinfo.isIgnored = false;\n          info.addHistory(`Mark as non-ignored because of usage by ${info.key}`);\n          toVisit.push(depinfo);\n        }\n      }\n    }\n  }\n\n  /**\n   * Looks up the package a dependency resolves to\n  */\n\n  _lookupDependency(info, depPattern) {\n    //\n    const pkg = this.resolver.getStrictResolvedPattern(depPattern);\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    //\n    for (let i = info.parts.length; i >= 0; i--) {\n      const checkParts = info.parts.slice(0, i).concat(pkg.name);\n      const checkKey = this.implodeKey(checkParts);\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the highest position we can hoist this module to.\n   */\n\n  getNewParts(key, info, parts) {\n    let stepUp = false;\n\n    const fullKey = this.implodeKey(parts);\n    const stack = []; // stack of removed parts\n    const name = parts.pop();\n\n    //\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const checkParts = parts.slice(0, i).concat(name);\n      const checkKey = this.implodeKey(checkParts);\n      info.addHistory(`Looked at ${checkKey} for a match`);\n\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        if (existing.loc === info.loc) {\n          // switch to non ignored if earlier deduped version was ignored\n          if (existing.isIgnored && !info.isIgnored) {\n            existing.isIgnored = info.isIgnored;\n          }\n\n          existing.addHistory(`Deduped ${fullKey} to this item`);\n          return { parts: checkParts, duplicate: true };\n        } else {\n          // everything above will be shadowed and this is a conflict\n          info.addHistory(`Found a collision at ${checkKey}`);\n          break;\n        }\n      }\n\n      const existingTaint = this.taintedKeys.get(checkKey);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        info.addHistory(`Broken by ${checkKey}`);\n        break;\n      }\n    }\n\n    // remove redundant parts that wont collide\n    while (parts.length) {\n      const checkParts = parts.concat(name);\n      const checkKey = this.implodeKey(checkParts);\n\n      //\n      const existing = this.tree.get(checkKey);\n      if (existing) {\n        stepUp = true;\n        break;\n      }\n\n      // check if we're trying to hoist ourselves to a previously unflattened module key,\n      // this will result in a conflict and we'll need to move ourselves up\n      if (key !== checkKey && this.taintedKeys.has(checkKey)) {\n        stepUp = true;\n        break;\n      }\n\n      //\n      stack.push(parts.pop());\n    }\n\n    //\n    parts.push(name);\n\n    //\n    const isValidPosition = parts => {\n      const key = this.implodeKey(parts);\n      const existing = this.tree.get(key);\n      if (existing && existing.loc === info.loc) {\n        return true;\n      }\n\n      // ensure there's no taint or the taint is us\n      const existingTaint = this.taintedKeys.get(key);\n      if (existingTaint && existingTaint.loc !== info.loc) {\n        return false;\n      }\n\n      return true;\n    };\n\n    // we need to special case when we attempt to hoist to the top level as the `existing` logic\n    // wont be hit in the above `while` loop and we could conflict\n    if (!isValidPosition(parts)) {\n      stepUp = true;\n    }\n\n    // sometimes we need to step up to a parent module to install ourselves\n    while (stepUp && stack.length) {\n      info.addHistory(`Stepping up from ${this.implodeKey(parts)}`);\n\n      parts.pop(); // remove `name`\n      parts.push(stack.pop(), name);\n\n      if (isValidPosition(parts)) {\n        info.addHistory(`Found valid position ${this.implodeKey(parts)}`);\n        stepUp = false;\n      }\n    }\n\n    return { parts, duplicate: false };\n  }\n\n  /**\n   * Hoist all seeded patterns to their highest positions.\n   */\n\n  hoist(info) {\n    const key = info.key,\n          rawParts = info.parts;\n\n    // remove this item from the `tree` map so we can ignore it\n\n    this.tree.delete(key);\n\n    var _getNewParts = this.getNewParts(key, info, rawParts.slice());\n\n    const parts = _getNewParts.parts,\n          duplicate = _getNewParts.duplicate;\n\n    const newKey = this.implodeKey(parts);\n    const oldKey = key;\n    if (duplicate) {\n      info.addHistory(`Satisfied from above by ${newKey}`);\n      this.declareRename(info, rawParts, parts);\n      return;\n    }\n\n    // update to the new key\n    if (oldKey === newKey) {\n      info.addHistory(\"Didn't hoist - conflicts above\");\n      this.setKey(info, oldKey, parts);\n      return;\n    }\n\n    //\n    this.declareRename(info, rawParts, parts);\n    this.setKey(info, newKey, parts);\n  }\n\n  /**\n   * Declare that a module has been hoisted and update our internal references.\n   */\n\n  declareRename(info, oldParts, newParts) {\n    // go down the tree from our new position reserving our name\n    this.taintParents(info, oldParts.slice(0, -1), newParts.length - 1);\n  }\n\n  /**\n   * Crawl upwards through a list of ancestry parts and taint a package name.\n   */\n\n  taintParents(info, processParts, start) {\n    for (let i = start; i < processParts.length; i++) {\n      const parts = processParts.slice(0, i).concat(info.pkg.name);\n      const key = this.implodeKey(parts);\n\n      if (this.taintKey(key, info)) {\n        info.addHistory(`Tainted ${key} to prevent collisions`);\n      }\n    }\n  }\n\n  /**\n   * Update the key of a module and update our references.\n   */\n\n  setKey(info, newKey, parts) {\n    const oldKey = info.key;\n\n    info.key = newKey;\n    info.parts = parts;\n    this.tree.set(newKey, info);\n\n    if (oldKey === newKey) {\n      return;\n    }\n\n    info.previousKeys.push(newKey);\n    info.addHistory(`New position = ${newKey}`);\n  }\n\n  /**\n   * Perform a prepass and if there's multiple versions of the same package, hoist the one with\n   * the most dependents to the top.\n   */\n\n  prepass(patterns) {\n    patterns = this.resolver.dedupePatterns(patterns).sort();\n\n    const occurences = {};\n\n    // add an occuring package to the above data structure\n    const add = (pattern, ancestry) => {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      if (ancestry.indexOf(pkg) >= 0) {\n        // prevent recursive dependencies\n        return;\n      }\n\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n\n      const versions = occurences[pkg.name] = occurences[pkg.name] || {};\n      const version = versions[pkg.version] = versions[pkg.version] || { occurences: new Set(), pattern };\n      version.occurences.add(ancestry[ancestry.length - 1]);\n\n      for (const depPattern of ref.dependencies) {\n        add(depPattern, ancestry.concat(pkg));\n      }\n    };\n\n    // get a list of root package names since we can't hoist other dependencies to these spots!\n    const rootPackageNames = new Set();\n    for (const pattern of patterns) {\n      const pkg = this.resolver.getStrictResolvedPattern(pattern);\n      rootPackageNames.add(pkg.name);\n    }\n\n    // seed occurences\n    for (const pattern of patterns) {\n      add(pattern, []);\n    }\n\n    for (const packageName of Object.keys(occurences).sort()) {\n      const versionOccurences = occurences[packageName];\n      const versions = Object.keys(versionOccurences);\n\n      if (versions.length === 1) {\n        // only one package type so we'll hoist this to the top anyway\n        continue;\n      }\n\n      if (this.tree.get(packageName)) {\n        // a transitive dependency of a previously hoisted dependency exists\n        continue;\n      }\n\n      if (rootPackageNames.has(packageName)) {\n        // can't replace top level packages\n        continue;\n      }\n\n      let mostOccurenceCount;\n      let mostOccurencePattern;\n      for (const version of Object.keys(versionOccurences).sort()) {\n        var _versionOccurences$ve = versionOccurences[version];\n        const occurences = _versionOccurences$ve.occurences,\n              pattern = _versionOccurences$ve.pattern;\n\n        const occurenceCount = occurences.size;\n\n        if (!mostOccurenceCount || occurenceCount > mostOccurenceCount) {\n          mostOccurenceCount = occurenceCount;\n          mostOccurencePattern = pattern;\n        }\n      }\n      invariant(mostOccurencePattern, 'expected most occuring pattern');\n      invariant(mostOccurenceCount, 'expected most occuring count');\n\n      // only hoist this module if it occured more than once\n      if (mostOccurenceCount > 1) {\n        this._seed(mostOccurencePattern);\n      }\n    }\n  }\n\n  /**\n   * Produce a flattened list of module locations and manifests.\n   */\n\n  init() {\n    const flatTree = [];\n\n    //\n    for (const _ref7 of this.tree.entries()) {\n      var _ref8 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref7, 2);\n\n      const key = _ref8[0];\n      const info = _ref8[1];\n\n      // decompress the location and push it to the flat tree. this path could be made\n      const parts = [];\n      const keyParts = key.split('#');\n      for (let i = 0; i < keyParts.length; i++) {\n        const key = keyParts.slice(0, i + 1).join('#');\n        const hoisted = this.tree.get(key);\n        invariant(hoisted, 'expected hoisted manifest');\n        parts.push(this.config.getFolder(hoisted.pkg));\n        parts.push(keyParts[i]);\n      }\n\n      if (this.config.modulesFolder) {\n        // remove the first part which will be the folder name and replace it with a\n        // hardcoded modules folder\n        parts.shift();\n        const modulesFolder = this.config.modulesFolder == null ? '' : this.config.modulesFolder;\n        parts.unshift(modulesFolder);\n      } else {\n        // first part will be the registry-specific module folder\n        const cwd = this.config.cwd == null ? '' : this.config.cwd;\n        parts.unshift(cwd);\n      }\n\n      const loc = path.join(...parts);\n      flatTree.push([loc, info]);\n    }\n\n    // remove ignored modules from the tree\n    const visibleFlatTree = [];\n    for (const _ref9 of flatTree) {\n      var _ref10 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref9, 2);\n\n      const loc = _ref10[0];\n      const info = _ref10[1];\n\n      const ref = info.pkg._reference;\n      invariant(ref, 'expected reference');\n\n      if (info.isIgnored) {\n        info.addHistory('Deleted as this module was ignored');\n      } else {\n        visibleFlatTree.push([loc, info]);\n      }\n    }\n    return visibleFlatTree;\n  }\n}\n\nexports.default = PackageHoister;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-install-scripts.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2;\n\nfunction _load_extends() {\n  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _executeLifecycleScript;\n\nfunction _load_executeLifecycleScript() {\n  return _executeLifecycleScript = _interopRequireDefault(require('./util/execute-lifecycle-script.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst path = require('path');\n\nconst INSTALL_STAGES = ['preinstall', 'install', 'postinstall'];\n\nclass PackageInstallScripts {\n  constructor(config, resolver, force) {\n    this.installed = 0;\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n    this.force = force;\n  }\n\n  getInstallCommands(pkg) {\n    const scripts = pkg.scripts;\n    if (scripts) {\n      const cmds = [];\n      for (const stage of INSTALL_STAGES) {\n        const cmd = scripts[stage];\n        if (cmd) {\n          cmds.push([stage, cmd]);\n        }\n      }\n      return cmds;\n    } else {\n      return [];\n    }\n  }\n\n  walk(loc) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const files = yield (_fs || _load_fs()).walk(loc, null, new Set(_this.config.registryFolders));\n      const mtimes = new Map();\n      for (const file of files) {\n        mtimes.set(file.relative, file.mtime);\n      }\n      return mtimes;\n    })();\n  }\n\n  saveBuildArtifacts(loc, pkg, beforeFiles, spinner) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const afterFiles = yield _this2.walk(loc);\n\n      // work out what files have been created/modified\n      const buildArtifacts = [];\n      for (const _ref of afterFiles) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const file = _ref2[0];\n        const mtime = _ref2[1];\n\n        if (!beforeFiles.has(file) || beforeFiles.get(file) !== mtime) {\n          buildArtifacts.push(file);\n        }\n      }\n\n      if (!buildArtifacts.length) {\n        // nothing else to do here since we have no build artifacts\n        return;\n      }\n\n      // if the process is killed while copying over build artifacts then we'll leave\n      // the cache in a bad state. remove the metadata file and add it back once we've\n      // done our copies to ensure cache integrity.\n      const cachedLoc = _this2.config.generateHardModulePath(pkg._reference, true);\n      const metadata = yield _this2.config.readPackageMetadata(cachedLoc);\n      metadata.artifacts = buildArtifacts;\n\n      const metadataLoc = path.join(cachedLoc, (_constants || _load_constants()).METADATA_FILENAME);\n      yield (_fs || _load_fs()).writeFile(metadataLoc, JSON.stringify((0, (_extends2 || _load_extends()).default)({}, metadata, {\n\n        // config.readPackageMetadata also returns the package manifest but that's not in the original\n        // metadata json\n        package: undefined\n      }), null, '  '));\n    })();\n  }\n\n  install(cmds, pkg, spinner) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const loc = _this3.config.generateHardModulePath(ref);\n\n      try {\n        for (const _ref3 of cmds) {\n          var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 2);\n\n          const stage = _ref4[0];\n          const cmd = _ref4[1];\n\n          yield (0, (_executeLifecycleScript || _load_executeLifecycleScript()).default)(stage, _this3.config, loc, cmd, spinner);\n        }\n      } catch (err) {\n        err.message = `${loc}: ${err.message}`;\n\n        invariant(ref, 'expected reference');\n\n        if (ref.optional) {\n          ref.ignore = true;\n          _this3.reporter.warn(_this3.reporter.lang('optionalModuleScriptFail', err.message));\n          _this3.reporter.info(_this3.reporter.lang('optionalModuleFail'));\n\n          // Cleanup node_modules\n          try {\n            yield (_fs || _load_fs()).unlink(loc);\n          } catch (e) {\n            _this3.reporter.error(_this3.reporter.lang('optionalModuleCleanupFail', e.message));\n          }\n        } else {\n          throw err;\n        }\n      }\n    })();\n  }\n\n  packageCanBeInstalled(pkg) {\n    const cmds = this.getInstallCommands(pkg);\n    if (!cmds.length) {\n      return false;\n    }\n    const ref = pkg._reference;\n    invariant(ref, 'Missing package reference');\n    if (!ref.fresh && !this.force) {\n      // this package hasn't been touched\n      return false;\n    }\n\n    // we haven't actually written this module out\n    if (ref.ignore) {\n      return false;\n    }\n    return true;\n  }\n\n  runCommand(spinner, pkg) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const cmds = _this4.getInstallCommands(pkg);\n      spinner.setPrefix(++_this4.installed, pkg.name);\n      yield _this4.install(cmds, pkg, spinner);\n    })();\n  }\n\n  // detect if there is a circularDependency in the dependency tree\n  detectCircularDependencies(root, seenManifests, pkg) {\n    const ref = pkg._reference;\n    invariant(ref, 'expected reference');\n\n    const deps = ref.dependencies;\n    for (const dep of deps) {\n      const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n      if (seenManifests.has(pkgDep)) {\n        // there is a cycle but not with the root\n        continue;\n      }\n      seenManifests.add(pkgDep);\n      // found a dependency pointing to root\n      if (pkgDep == root) {\n        return true;\n      }\n      if (this.detectCircularDependencies(root, seenManifests, pkgDep)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // find the next package to be installed\n  findInstallablePackage(workQueue, installed) {\n    for (const pkg of workQueue) {\n      const ref = pkg._reference;\n      invariant(ref, 'expected reference');\n      const deps = ref.dependencies;\n\n      let dependenciesFullfilled = true;\n      for (const dep of deps) {\n        const pkgDep = this.resolver.getStrictResolvedPattern(dep);\n        if (!installed.has(pkgDep)) {\n          dependenciesFullfilled = false;\n          break;\n        }\n      }\n\n      // all depedencies are installed\n      if (dependenciesFullfilled) {\n        return pkg;\n      }\n\n      // detect circular dependency, mark this pkg as installable to break the circle\n      if (this.detectCircularDependencies(pkg, new Set(), pkg)) {\n        return pkg;\n      }\n    }\n    return null;\n  }\n\n  worker(spinner, workQueue, installed, waitQueue) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      while (true) {\n        // No more work to be done\n        if (workQueue.size == 0) {\n          break;\n        }\n\n        // find a installable package\n        const pkg = _this5.findInstallablePackage(workQueue, installed);\n\n        // can't find a package to install, register into waitQueue\n        if (pkg == null) {\n          spinner.clear();\n          yield new Promise(function (resolve) {\n            return waitQueue.add(resolve);\n          });\n          continue;\n        }\n\n        // found a package to install\n        workQueue.delete(pkg);\n        if (_this5.packageCanBeInstalled(pkg)) {\n          yield _this5.runCommand(spinner, pkg);\n        }\n        installed.add(pkg);\n        for (const workerResolve of waitQueue) {\n          workerResolve();\n        }\n        waitQueue.clear();\n      }\n    })();\n  }\n\n  init(seedPatterns) {\n    var _this6 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const workQueue = new Set();\n      const installed = new Set();\n      const pkgs = _this6.resolver.getTopologicalManifests(seedPatterns);\n      let installablePkgs = 0;\n      // A map to keep track of what files exist before installation\n      const beforeFilesMap = new Map();\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          beforeFilesMap.set(loc, (yield _this6.walk(loc)));\n          installablePkgs += 1;\n        }\n        workQueue.add(pkg);\n      }\n\n      // waitQueue acts like a semaphore to allow workers to register to be notified\n      // when there are more work added to the work queue\n      const waitQueue = new Set();\n      const workers = [];\n\n      const set = _this6.reporter.activitySet(installablePkgs, Math.min((_constants || _load_constants()).CHILD_CONCURRENCY, workQueue.size));\n\n      for (const spinner of set.spinners) {\n        workers.push(_this6.worker(spinner, workQueue, installed, waitQueue));\n      }\n\n      yield Promise.all(workers);\n\n      // cache all build artifacts\n      for (const pkg of pkgs) {\n        if (_this6.packageCanBeInstalled(pkg)) {\n          const ref = pkg._reference;\n          invariant(ref, 'expected reference');\n          const loc = _this6.config.generateHardModulePath(ref);\n          const beforeFiles = beforeFilesMap.get(loc);\n          invariant(beforeFiles, 'files before installation should always be recorded');\n          yield _this6.saveBuildArtifacts(loc, pkg, beforeFiles, set.spinners[0]);\n        }\n      }\n\n      set.end();\n    })();\n  }\n}\nexports.default = PackageInstallScripts;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-linker.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linkBin = undefined;\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nlet linkBin = exports.linkBin = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    if (process.platform === 'win32') {\n      const unlockMutex = yield (0, (_mutex || _load_mutex()).default)(src);\n      try {\n        yield cmdShim(src, dest);\n      } finally {\n        unlockMutex();\n      }\n    } else {\n      yield (_fs || _load_fs()).mkdirp(path.dirname(dest));\n      yield (_fs || _load_fs()).symlink(src, dest);\n      yield (_fs || _load_fs()).chmod(dest, '755');\n    }\n  });\n\n  return function linkBin(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _packageHoister;\n\nfunction _load_packageHoister() {\n  return _packageHoister = _interopRequireDefault(require('./package-hoister.js'));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(require('./util/promise.js'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nvar _mutex;\n\nfunction _load_mutex() {\n  return _mutex = _interopRequireDefault(require('./util/mutex.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst cmdShim = (_promise || _load_promise()).promisify(require('cmd-shim'));\nconst semver = require('semver');\nconst path = require('path');\n\nclass PackageLinker {\n  constructor(config, resolver) {\n    this.resolver = resolver;\n    this.reporter = config.reporter;\n    this.config = config;\n  }\n\n  linkSelfDependencies(pkg, pkgLoc, targetBinLoc) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      targetBinLoc = yield (_fs || _load_fs()).realpath(targetBinLoc);\n      pkgLoc = yield (_fs || _load_fs()).realpath(pkgLoc);\n      for (const _ref2 of (0, (_misc || _load_misc()).entries)(pkg.bin)) {\n        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 2);\n\n        const scriptName = _ref3[0];\n        const scriptCmd = _ref3[1];\n\n        const dest = path.join(targetBinLoc, scriptName);\n        const src = path.join(pkgLoc, scriptCmd);\n        if (!(yield (_fs || _load_fs()).exists(src))) {\n          // TODO maybe throw an error\n          continue;\n        }\n        yield linkBin(src, dest);\n      }\n    })();\n  }\n\n  linkBinDependencies(pkg, dir) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const deps = [];\n\n      const ref = pkg._reference;\n      invariant(ref, 'Package reference is missing');\n\n      const remote = pkg._remote;\n      invariant(remote, 'Package remote is missing');\n\n      // link up `bin scripts` in `dependencies`\n      for (const pattern of ref.dependencies) {\n        const dep = _this.resolver.getStrictResolvedPattern(pattern);\n        if (dep.bin && Object.keys(dep.bin).length) {\n          deps.push({ dep, loc: _this.config.generateHardModulePath(dep._reference) });\n        }\n      }\n\n      // link up the `bin` scripts in bundled dependencies\n      if (pkg.bundleDependencies) {\n        for (const depName of pkg.bundleDependencies) {\n          const loc = path.join(_this.config.generateHardModulePath(ref), _this.config.getFolder(pkg), depName);\n\n          const dep = yield _this.config.readManifest(loc, remote.registry);\n\n          if (dep.bin && Object.keys(dep.bin).length) {\n            deps.push({ dep, loc });\n          }\n        }\n      }\n\n      // no deps to link\n      if (!deps.length) {\n        return;\n      }\n\n      // ensure our .bin file we're writing these to exists\n      const binLoc = path.join(dir, '.bin');\n      yield (_fs || _load_fs()).mkdirp(binLoc);\n\n      // write the executables\n      for (const _ref4 of deps) {\n        const dep = _ref4.dep,\n              loc = _ref4.loc;\n\n        yield _this.linkSelfDependencies(dep, loc, binLoc);\n      }\n    })();\n  }\n\n  getFlatHoistedTree(patterns) {\n    const hoister = new (_packageHoister || _load_packageHoister()).default(this.config, this.resolver);\n    hoister.seed(patterns);\n    return Promise.resolve(hoister.init());\n  }\n\n  copyModules(patterns, linkDuplicates) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      let flatTree = yield _this2.getFlatHoistedTree(patterns);\n\n      // sorted tree makes file creation and copying not to interfere with each other\n      flatTree = flatTree.sort(function (dep1, dep2) {\n        return dep1[0].localeCompare(dep2[0]);\n      });\n\n      // list of artifacts in modules to remove from extraneous removal\n      const artifactFiles = [];\n\n      const copyQueue = new Map();\n      const hardlinkQueue = new Map();\n      const hardlinksEnabled = linkDuplicates && (yield (_fs || _load_fs()).hardlinksWork(_this2.config.cwd));\n\n      const copiedSrcs = new Map();\n      for (const _ref5 of flatTree) {\n        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);\n\n        const dest = _ref6[0];\n        var _ref6$ = _ref6[1];\n        const pkg = _ref6$.pkg;\n        const src = _ref6$.loc;\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected package reference');\n        ref.setLocation(dest);\n\n        // get a list of build artifacts contained in this module so we can prevent them from being marked as\n        // extraneous\n        const metadata = yield _this2.config.readPackageMetadata(src);\n        for (const file of metadata.artifacts) {\n          artifactFiles.push(path.join(dest, file));\n        }\n\n        const copiedDest = copiedSrcs.get(src);\n        if (!copiedDest) {\n          if (hardlinksEnabled) {\n            copiedSrcs.set(src, dest);\n          }\n          copyQueue.set(dest, {\n            src,\n            dest,\n            onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        } else {\n          hardlinkQueue.set(dest, {\n            src: copiedDest,\n            dest,\n            onFresh() {\n              if (ref) {\n                ref.setFresh(true);\n              }\n            }\n          });\n        }\n      }\n\n      // keep track of all scoped paths to remove empty scopes after copy\n      const scopedPaths = new Set();\n\n      // register root & scoped packages as being possibly extraneous\n      const possibleExtraneous = new Set();\n      for (const folder of _this2.config.registryFolders) {\n        const loc = path.join(_this2.config.cwd, folder);\n\n        if (yield (_fs || _load_fs()).exists(loc)) {\n          const files = yield (_fs || _load_fs()).readdir(loc);\n          let filepath;\n          for (const file of files) {\n            filepath = path.join(loc, file);\n            if (file[0] === '@') {\n              // it's a scope, not a package\n              scopedPaths.add(filepath);\n              const subfiles = yield (_fs || _load_fs()).readdir(filepath);\n              for (const subfile of subfiles) {\n                possibleExtraneous.add(path.join(filepath, subfile));\n              }\n            } else {\n              possibleExtraneous.add(filepath);\n            }\n          }\n        }\n      }\n\n      // linked modules\n      for (const loc of possibleExtraneous) {\n        const stat = yield (_fs || _load_fs()).lstat(loc);\n        if (stat.isSymbolicLink()) {\n          possibleExtraneous.delete(loc);\n          copyQueue.delete(loc);\n        }\n      }\n\n      //\n      let tick;\n      yield (_fs || _load_fs()).copyBulk(Array.from(copyQueue.values()), _this2.reporter, {\n        possibleExtraneous,\n        artifactFiles,\n\n        ignoreBasenames: [(_constants || _load_constants()).METADATA_FILENAME, (_constants || _load_constants()).TARBALL_FILENAME],\n\n        onStart: function (num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n      yield (_fs || _load_fs()).hardlinkBulk(Array.from(hardlinkQueue.values()), _this2.reporter, {\n        possibleExtraneous,\n        artifactFiles,\n\n        onStart: function (num) {\n          tick = _this2.reporter.progress(num);\n        },\n\n        onProgress(src) {\n          if (tick) {\n            tick(src);\n          }\n        }\n      });\n\n      // remove all extraneous files that weren't in the tree\n      for (const loc of possibleExtraneous) {\n        _this2.reporter.verbose(_this2.reporter.lang('verboseFileRemoveExtraneous', loc));\n        yield (_fs || _load_fs()).unlink(loc);\n      }\n\n      // remove any empty scoped directories\n      for (const scopedPath of scopedPaths) {\n        const files = yield (_fs || _load_fs()).readdir(scopedPath);\n        if (files.length === 0) {\n          yield (_fs || _load_fs()).unlink(scopedPath);\n        }\n      }\n\n      //\n      if (_this2.config.binLinks) {\n        const tickBin = _this2.reporter.progress(flatTree.length);\n        yield (_promise || _load_promise()).queue(flatTree, (() => {\n          var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref8) {\n            var _ref9 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref8, 2);\n\n            let dest = _ref9[0],\n                pkg = _ref9[1].pkg;\n\n            const binLoc = path.join(dest, _this2.config.getFolder(pkg));\n            yield _this2.linkBinDependencies(pkg, binLoc);\n            tickBin(dest);\n          });\n\n          return function (_x3) {\n            return _ref7.apply(this, arguments);\n          };\n        })(), 4);\n      }\n    })();\n  }\n\n  resolvePeerModules() {\n    for (const pkg of this.resolver.getManifests()) {\n      this._resolvePeerModules(pkg);\n    }\n  }\n\n  _resolvePeerModules(pkg) {\n    const peerDeps = pkg.peerDependencies;\n    if (!peerDeps) {\n      return;\n    }\n\n    const ref = pkg._reference;\n    invariant(ref, 'Package reference is missing');\n\n    for (const name in peerDeps) {\n      const range = peerDeps[name];\n      const patterns = this.resolver.patternsByPackage[name] || [];\n      const foundPattern = patterns.find(pattern => {\n        const resolvedPattern = this.resolver.getResolvedPattern(pattern);\n        return resolvedPattern ? this._satisfiesPeerDependency(range, resolvedPattern.version) : false;\n      });\n\n      if (foundPattern) {\n        ref.addDependencies([foundPattern]);\n      } else {\n        const depError = patterns.length > 0 ? 'incorrectPeer' : 'unmetPeer';\n        const pkgHuman = `${pkg.name}@${pkg.version}`,\n              depHuman = `${name}@${range}`;\n\n        this.reporter.warn(this.reporter.lang(depError, pkgHuman, depHuman));\n      }\n    }\n  }\n\n  _satisfiesPeerDependency(range, version) {\n    return range === '*' || semver.satisfies(version, range, this.config.looseSemver);\n  }\n\n  init(patterns, linkDuplicates) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this3.resolvePeerModules();\n      yield _this3.copyModules(patterns, linkDuplicates);\n      yield _this3.saveAll(patterns);\n    })();\n  }\n\n  save(pattern) {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const resolved = _this4.resolver.getResolvedPattern(pattern);\n      invariant(resolved, `Couldn't find resolved name/version for ${pattern}`);\n\n      const ref = resolved._reference;\n      invariant(ref, 'Missing reference');\n\n      //\n      const src = _this4.config.generateHardModulePath(ref);\n\n      // link bins\n      if (_this4.config.binLinks && resolved.bin && Object.keys(resolved.bin).length && !ref.ignore) {\n        const folder = _this4.config.modulesFolder || path.join(_this4.config.cwd, _this4.config.getFolder(resolved));\n        const binLoc = path.join(folder, '.bin');\n        yield (_fs || _load_fs()).mkdirp(binLoc);\n        yield _this4.linkSelfDependencies(resolved, src, binLoc);\n      }\n    })();\n  }\n\n  saveAll(deps) {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      deps = _this5.resolver.dedupePatterns(deps);\n      yield (_promise || _load_promise()).queue(deps, function (dep) {\n        return _this5.save(dep);\n      });\n    })();\n  }\n}\nexports.default = PackageLinker;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/util/promise.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wait = wait;\nexports.promisify = promisify;\nexports.promisifyObject = promisifyObject;\nexports.queue = queue;\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\nfunction promisify(fn, firstData) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise(function (resolve, reject) {\n      args.push(function (err) {\n        for (var _len2 = arguments.length, result = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          result[_key2 - 1] = arguments[_key2];\n        }\n\n        let res = result;\n\n        if (result.length <= 1) {\n          res = result[0];\n        }\n\n        if (firstData) {\n          res = err;\n          err = null;\n        }\n\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n}\n\nfunction promisifyObject(obj) {\n  const promisedObj = {};\n  for (const key in obj) {\n    promisedObj[key] = promisify(obj[key]);\n  }\n  return promisedObj;\n}\n\nfunction queue(arr, promiseProducer) {\n  let concurrency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n  concurrency = Math.min(concurrency, arr.length);\n\n  // clone\n  arr = arr.slice();\n\n  const results = [];\n  let total = arr.length;\n  if (!total) {\n    return Promise.resolve(results);\n  }\n\n  return new Promise((resolve, reject) => {\n    for (let i = 0; i < concurrency; i++) {\n      next();\n    }\n\n    function next() {\n      const item = arr.shift();\n      const promise = promiseProducer(item);\n\n      promise.then(function (result) {\n        results.push(result);\n\n        total--;\n        if (total === 0) {\n          resolve(results);\n        } else {\n          if (arr.length) {\n            next();\n          }\n        }\n      }, reject);\n    }\n  });\n}","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-reference.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PackageReference {\n  constructor(request, info, remote) {\n    this.resolver = request.resolver;\n    this.lockfile = request.lockfile;\n    this.requests = [];\n    this.config = request.config;\n\n    this.registry = remote.registry;\n    this.version = info.version;\n    this.name = info.name;\n    this.uid = info._uid;\n\n    this.remote = remote;\n\n    this.dependencies = [];\n\n    this.permissions = {};\n    this.patterns = [];\n    this.optional = null;\n    this.root = false;\n    this.ignore = false;\n    this.fresh = false;\n    this.location = null;\n    this.addRequest(request);\n  }\n\n  setFresh(fresh) {\n    this.fresh = fresh;\n  }\n\n  setLocation(loc) {\n    return this.location = loc;\n  }\n\n  addRequest(request) {\n    this.requests.push(request);\n\n    if (!request.parentRequest) {\n      this.root = true;\n    }\n  }\n\n  prune() {\n    for (const selfPattern of this.patterns) {\n      // remove ourselves from the resolver\n      this.resolver.removePattern(selfPattern);\n    }\n  }\n\n  addDependencies(deps) {\n    this.dependencies = this.dependencies.concat(deps);\n  }\n\n  setPermission(key, val) {\n    this.permissions[key] = val;\n  }\n\n  hasPermission(key) {\n    if (key in this.permissions) {\n      return this.permissions[key];\n    } else {\n      return false;\n    }\n  }\n\n  addPattern(pattern, manifest) {\n    this.resolver.addPattern(pattern, manifest);\n\n    this.patterns.push(pattern);\n\n    const shrunk = this.lockfile.getLocked(pattern);\n    if (shrunk && shrunk.permissions) {\n      for (const _ref of (0, (_misc || _load_misc()).entries)(shrunk.permissions)) {\n        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n        const key = _ref2[0];\n        const perm = _ref2[1];\n\n        this.setPermission(key, perm);\n      }\n    }\n  }\n\n  addOptional(optional) {\n    if (this.optional == null) {\n      // optional is uninitialised\n      this.optional = optional;\n    } else if (!optional) {\n      // otherwise, ignore all subsequent optional assignments and only accept ones making\n      // this not optional\n      this.optional = false;\n    }\n  }\n}\nexports.default = PackageReference;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-request.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _slicedToArray2;\n\nfunction _load_slicedToArray() {\n  return _slicedToArray2 = _interopRequireDefault(require('babel-runtime/helpers/slicedToArray'));\n}\n\nvar _validate;\n\nfunction _load_validate() {\n  return _validate = require('./util/normalize-manifest/validate.js');\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _packageReference;\n\nfunction _load_packageReference() {\n  return _packageReference = _interopRequireDefault(require('./package-reference.js'));\n}\n\nvar _index;\n\nfunction _load_index() {\n  return _index = _interopRequireWildcard(require('./resolvers/index.js'));\n}\n\nvar _index2;\n\nfunction _load_index2() {\n  return _index2 = require('./resolvers/index.js');\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = require('./errors.js');\n}\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = require('./util/misc.js');\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = _interopRequireWildcard(require('./constants.js'));\n}\n\nvar _version;\n\nfunction _load_version() {\n  return _version = _interopRequireWildcard(require('./util/version.js'));\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(require('./util/fs.js'));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = require('path');\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageRequest {\n  constructor(req, resolver) {\n    this.parentRequest = req.parentRequest;\n    this.lockfile = resolver.lockfile;\n    this.registry = req.registry;\n    this.reporter = resolver.reporter;\n    this.resolver = resolver;\n    this.optional = req.optional;\n    this.pattern = req.pattern;\n    this.config = resolver.config;\n\n    resolver.usedRegistries.add(req.registry);\n  }\n\n  static getExoticResolver(pattern) {\n    // TODO make this type more refined\n    for (const _ref of (0, (_misc || _load_misc()).entries)((_index || _load_index()).exotics)) {\n      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);\n\n      const Resolver = _ref2[1];\n\n      if (Resolver.isVersion(pattern)) {\n        return Resolver;\n      }\n    }\n    return null;\n  }\n\n  getParentNames() {\n    const chain = [];\n\n    let request = this.parentRequest;\n    while (request) {\n      const info = this.resolver.getStrictResolvedPattern(request.pattern);\n      chain.unshift(info.name);\n\n      request = request.parentRequest;\n    }\n\n    return chain;\n  }\n\n  getLocked(remoteType) {\n    // always prioritise root lockfile\n    const shrunk = this.lockfile.getLocked(this.pattern);\n\n    if (shrunk && shrunk.resolved) {\n      const resolvedParts = (_version || _load_version()).explodeHashedUrl(shrunk.resolved);\n\n      return {\n        name: shrunk.name,\n        version: shrunk.version,\n        _uid: shrunk.uid,\n        _remote: {\n          resolved: shrunk.resolved,\n          type: remoteType,\n          reference: resolvedParts.url,\n          hash: resolvedParts.hash,\n          registry: shrunk.registry\n        },\n        optionalDependencies: shrunk.optionalDependencies,\n        dependencies: shrunk.dependencies\n      };\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * If the input pattern matches a registry one then attempt to find it on the registry.\n   * Otherwise fork off to an exotic resolver if one matches.\n   */\n\n  findVersionOnRegistry(pattern) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref3 = yield _this.normalize(pattern);\n\n      const range = _ref3.range,\n            name = _ref3.name;\n\n\n      const exoticResolver = PackageRequest.getExoticResolver(range);\n      if (exoticResolver) {\n        let data = yield _this.findExoticVersionInfo(exoticResolver, range);\n\n        // clone data as we're manipulating it in place and this could be resolved multiple\n        // times\n        data = Object.assign({}, data);\n\n        // this is so the returned package response uses the overridden name. ie. if the\n        // package's actual name is `bar`, but it's been specified in the manifest like:\n        //   \"foo\": \"http://foo.com/bar.tar.gz\"\n        // then we use the foo name\n        data.name = name;\n\n        return data;\n      }\n\n      const Resolver = _this.getRegistryResolver();\n      const resolver = new Resolver(_this, name, range);\n      return resolver.resolve();\n    })();\n  }\n\n  /**\n   * Get the registry resolver associated with this package request.\n   */\n\n  getRegistryResolver() {\n    const Resolver = (_index2 || _load_index2()).registries[this.registry];\n    if (Resolver) {\n      return Resolver;\n    } else {\n      throw new (_errors || _load_errors()).MessageError(this.reporter.lang('unknownRegistryResolver', this.registry));\n    }\n  }\n\n  normalizeRange(pattern) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      if (pattern.includes(':') || pattern.includes('@') || PackageRequest.getExoticResolver(pattern)) {\n        return Promise.resolve(pattern);\n      }\n\n      if (yield (_fs || _load_fs()).exists(path.join(_this2.config.cwd, pattern))) {\n        return Promise.resolve(`file:${pattern}`);\n      }\n\n      return Promise.resolve(pattern);\n    })();\n  }\n\n  normalize(pattern) {\n    var _this3 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _PackageRequest$norma = PackageRequest.normalizePattern(pattern);\n\n      const name = _PackageRequest$norma.name,\n            range = _PackageRequest$norma.range,\n            hasVersion = _PackageRequest$norma.hasVersion;\n\n      const newRange = yield _this3.normalizeRange(range);\n      return { name, range: newRange, hasVersion };\n    })();\n  }\n\n  /**\n   * Explode and normalize a pattern into it's name and range.\n   */\n\n  static normalizePattern(pattern) {\n    let hasVersion = false;\n    let range = 'latest';\n    let name = pattern;\n\n    // if we're a scope then remove the @ and add it back later\n    let isScoped = false;\n    if (name[0] === '@') {\n      isScoped = true;\n      name = name.slice(1);\n    }\n\n    // take first part as the name\n    const parts = name.split('@');\n    if (parts.length > 1) {\n      name = parts.shift();\n      range = parts.join('@');\n\n      if (range) {\n        hasVersion = true;\n      } else {\n        range = '*';\n      }\n    }\n\n    // add back @ scope suffix\n    if (isScoped) {\n      name = `@${name}`;\n    }\n\n    return { name, range, hasVersion };\n  }\n\n  /**\n   * Construct an exotic resolver instance with the input `ExoticResolver` and `range`.\n   */\n\n  findExoticVersionInfo(ExoticResolver, range) {\n    const resolver = new ExoticResolver(this, range);\n    return resolver.resolve();\n  }\n\n  /**\n   * If the current pattern matches an exotic resolver then delegate to it or else try\n   * the registry.\n   */\n\n  findVersionInfo() {\n    var _this4 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const exoticResolver = PackageRequest.getExoticResolver(_this4.pattern);\n      if (exoticResolver) {\n        return yield _this4.findExoticVersionInfo(exoticResolver, _this4.pattern);\n      } else {\n        return yield _this4.findVersionOnRegistry(_this4.pattern);\n      }\n    })();\n  }\n\n  reportResolvedRangeMatch(info, resolved) {}\n\n  /**\n   * TODO description\n   */\n\n  find() {\n    var _this5 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // find version info for this package pattern\n      const info = yield _this5.findVersionInfo();\n      if (!info) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('unknownPackage', _this5.pattern));\n      }\n\n      (0, (_validate || _load_validate()).cleanDependencies)(info, false, _this5.reporter, function () {\n        // swallow warnings\n      });\n\n      // check if while we were resolving this dep we've already resolved one that satisfies\n      // the same range\n\n      var _PackageRequest$norma2 = PackageRequest.normalizePattern(_this5.pattern);\n\n      const range = _PackageRequest$norma2.range,\n            name = _PackageRequest$norma2.name;\n\n      const resolved = _this5.resolver.getHighestRangeVersionMatch(name, range);\n      if (resolved) {\n        _this5.reportResolvedRangeMatch(info, resolved);\n        const ref = resolved._reference;\n        invariant(ref, 'Resolved package info has no package reference');\n        ref.addRequest(_this5);\n        ref.addPattern(_this5.pattern, resolved);\n        return;\n      }\n\n      if (info.flat && !_this5.resolver.flat) {\n        throw new (_errors || _load_errors()).MessageError(_this5.reporter.lang('flatGlobalError'));\n      }\n\n      // validate version info\n      PackageRequest.validateVersionInfo(info, _this5.reporter);\n\n      //\n      const remote = info._remote;\n      invariant(remote, 'Missing remote');\n\n      // set package reference\n      const ref = new (_packageReference || _load_packageReference()).default(_this5, info, remote);\n      ref.addPattern(_this5.pattern, info);\n      ref.addOptional(_this5.optional);\n      info._reference = ref;\n      info._remote = remote;\n\n      // start installation of dependencies\n      const promises = [];\n      const deps = [];\n\n      // normal deps\n      for (const depName in info.dependencies) {\n        const depPattern = depName + '@' + info.dependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: false,\n          parentRequest: _this5\n        }));\n      }\n\n      // optional deps\n      for (const depName in info.optionalDependencies) {\n        const depPattern = depName + '@' + info.optionalDependencies[depName];\n        deps.push(depPattern);\n        promises.push(_this5.resolver.find({\n          pattern: depPattern,\n          registry: remote.registry,\n          optional: true,\n          parentRequest: _this5\n        }));\n      }\n\n      yield Promise.all(promises);\n      ref.addDependencies(deps);\n\n      // Now that we have all dependencies, it's safe to propagate optional\n      for (const otherRequest of ref.requests.slice(1)) {\n        ref.addOptional(otherRequest.optional);\n      }\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  static validateVersionInfo(info, reporter) {\n    // human readable name to use in errors\n    const human = `${info.name}@${info.version}`;\n\n    info.version = PackageRequest.getPackageVersion(info);\n\n    for (const key of (_constants || _load_constants()).REQUIRED_PACKAGE_KEYS) {\n      if (!info[key]) {\n        throw new (_errors || _load_errors()).MessageError(reporter.lang('missingRequiredPackageKey', human, key));\n      }\n    }\n  }\n\n  /**\n   * Returns the package version if present, else defaults to the uid\n   */\n\n  static getPackageVersion(info) {\n    // TODO possibly reconsider this behaviour\n    return info.version === undefined ? info._uid : info.version;\n  }\n\n  /**\n   * Gets all of the outdated packages and sorts them appropriately\n   */\n\n  static getOutdatedPackages(lockfile, install, config, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      var _ref4 = yield install.fetchRequestFromCwd();\n\n      const depReqPatterns = _ref4.requests;\n\n\n      const deps = yield Promise.all(depReqPatterns.map((() => {\n        var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (_ref6) {\n          let pattern = _ref6.pattern,\n              hint = _ref6.hint;\n\n          const locked = lockfile.getLocked(pattern);\n          if (!locked) {\n            throw new (_errors || _load_errors()).MessageError(reporter.lang('lockfileOutdated'));\n          }\n\n          const name = locked.name,\n                current = locked.version;\n\n          let latest = '';\n          let wanted = '';\n          let url = '';\n\n          const normalized = PackageRequest.normalizePattern(pattern);\n\n          if (PackageRequest.getExoticResolver(pattern) || PackageRequest.getExoticResolver(normalized.range)) {\n            latest = wanted = 'exotic';\n            url = normalized.range;\n          } else {\n            const registry = config.registries[locked.registry];\n\n            var _ref7 = yield registry.checkOutdated(config, name, normalized.range);\n\n            latest = _ref7.latest;\n            wanted = _ref7.wanted;\n            url = _ref7.url;\n          }\n\n          return { name, current, wanted, latest, url, hint };\n        });\n\n        return function (_x) {\n          return _ref5.apply(this, arguments);\n        };\n      })()));\n\n      // Make sure to always output `exotic` versions to be compatible with npm\n      const isDepOld = function (_ref8) {\n        let current = _ref8.current,\n            latest = _ref8.latest,\n            wanted = _ref8.wanted;\n        return latest === 'exotic' || latest !== 'exotic' && (semver.lt(current, wanted) || semver.lt(current, latest));\n      };\n      const orderByName = function (depA, depB) {\n        return depA.name.localeCompare(depB.name);\n      };\n\n      return deps.filter(isDepOld).sort(orderByName);\n    })();\n  }\n}\nexports.default = PackageRequest;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/package-resolver.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));\n}\n\nvar _packageRequest;\n\nfunction _load_packageRequest() {\n  return _packageRequest = _interopRequireDefault(require('./package-request.js'));\n}\n\nvar _requestManager;\n\nfunction _load_requestManager() {\n  return _requestManager = _interopRequireDefault(require('./util/request-manager.js'));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(require('./util/blocking-queue.js'));\n}\n\nvar _wrapper;\n\nfunction _load_wrapper() {\n  return _wrapper = _interopRequireDefault(require('./lockfile/wrapper.js'));\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(require('./util/map.js'));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = require('invariant');\nconst semver = require('semver');\n\nclass PackageResolver {\n  constructor(config, lockfile) {\n    this.patternsByPackage = (0, (_map || _load_map()).default)();\n    this.fetchingPatterns = (0, (_map || _load_map()).default)();\n    this.fetchingQueue = new (_blockingQueue || _load_blockingQueue()).default('resolver fetching');\n    this.newPatterns = [];\n    this.patterns = (0, (_map || _load_map()).default)();\n    this.usedRegistries = new Set();\n    this.flat = false;\n\n    this.reporter = config.reporter;\n    this.lockfile = lockfile;\n    this.config = config;\n  }\n\n  // whether the dependency graph will be flattened\n\n\n  // list of registries that have been used in this resolution\n\n\n  // activity monitor\n\n\n  // patterns we've already resolved or are in the process of resolving\n\n\n  // new patterns that didn't exist in the lockfile\n\n\n  // TODO\n\n\n  // these are patterns that the package resolver was seeded with. these are required in\n  // order to resolve top level peerDependencies\n\n\n  // manages and throttles json api http requests\n\n\n  // list of patterns associated with a package\n\n\n  // lockfile instance which we can use to retrieve version info\n\n\n  // a map of dependency patterns to packages\n\n\n  // reporter instance, abstracts out display logic\n\n\n  // environment specific config methods and options\n\n\n  /**\n   * TODO description\n   */\n\n  isNewPattern(pattern) {\n    return this.newPatterns.indexOf(pattern) >= 0;\n  }\n\n  /**\n   * TODO description\n   */\n\n  updateManifest(ref, newPkg) {\n    // inherit fields\n    const oldPkg = this.patterns[ref.patterns[0]];\n    newPkg._reference = ref;\n    newPkg._remote = ref.remote;\n    newPkg.name = oldPkg.name;\n\n    // update patterns\n    for (const pattern of ref.patterns) {\n      this.patterns[pattern] = newPkg;\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a list of patterns, dedupe them to a list of unique patterns.\n   */\n\n  dedupePatterns(patterns) {\n    const deduped = [];\n    const seen = new Set();\n\n    for (const pattern of patterns) {\n      const info = this.getResolvedPattern(pattern);\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      deduped.push(pattern);\n    }\n\n    return deduped;\n  }\n\n  /**\n   * Get a list of all manifests by topological order.\n   */\n\n  getTopologicalManifests(seedPatterns) {\n    const pkgs = new Set();\n    const skip = new Set();\n\n    const add = seedPatterns => {\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n        skip.add(pkg);\n        add(ref.dependencies);\n        pkgs.add(pkg);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all manifests by level sort order.\n   */\n\n  getLevelOrderManifests(seedPatterns) {\n    const pkgs = new Set();\n    const skip = new Set();\n\n    const add = seedPatterns => {\n      const refs = [];\n\n      for (const pattern of seedPatterns) {\n        const pkg = this.getStrictResolvedPattern(pattern);\n        if (skip.has(pkg)) {\n          continue;\n        }\n\n        const ref = pkg._reference;\n        invariant(ref, 'expected reference');\n\n        refs.push(ref);\n        skip.add(pkg);\n        pkgs.add(pkg);\n      }\n\n      for (const ref of refs) {\n        add(ref.dependencies);\n      }\n    };\n\n    add(seedPatterns);\n\n    return pkgs;\n  }\n\n  /**\n   * Get a list of all package names in the depenency graph.\n   */\n\n  getAllDependencyNamesByLevelOrder(seedPatterns) {\n    const names = new Set();\n    for (const _ref of this.getLevelOrderManifests(seedPatterns)) {\n      const name = _ref.name;\n\n      names.add(name);\n    }\n    return names;\n  }\n\n  /**\n   * Retrieve all the package info stored for this package name.\n   */\n\n  getAllInfoForPackageName(name) {\n    const infos = [];\n    const seen = new Set();\n\n    for (const pattern of this.patternsByPackage[name]) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      seen.add(info);\n      infos.push(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * Get a flat list of all package references.\n   */\n\n  getPackageReferences() {\n    const refs = [];\n\n    for (const manifest of this.getManifests()) {\n      const ref = manifest._reference;\n      if (ref) {\n        refs.push(ref);\n      }\n    }\n\n    return refs;\n  }\n\n  /**\n   * Get a flat list of all package info.\n   */\n\n  getManifests() {\n    const infos = [];\n    const seen = new Set();\n\n    for (const pattern in this.patterns) {\n      const info = this.patterns[pattern];\n      if (seen.has(info)) {\n        continue;\n      }\n\n      infos.push(info);\n      seen.add(info);\n    }\n\n    return infos;\n  }\n\n  /**\n   * replace pattern in resolver, e.g. `name` is replaced with `name@^1.0.1`\n   */\n  replacePattern(pattern, newPattern) {\n    const pkg = this.getResolvedPattern(pattern);\n    invariant(pkg, `missing package ${pattern}`);\n    const ref = pkg._reference;\n    invariant(ref, 'expected package reference');\n    ref.patterns = [newPattern];\n    this.newPatterns.splice(this.newPatterns.indexOf(pattern), 1, newPattern);\n    this.addPattern(newPattern, pkg);\n    this.removePattern(pattern);\n  }\n\n  /**\n   * Make all versions of this package resolve to it.\n   */\n\n  collapseAllVersionsOfPackage(name, version) {\n    const patterns = this.dedupePatterns(this.patternsByPackage[name]);\n    const human = `${name}@${version}`;\n\n    // get manifest that matches the version we're collapsing too\n    let collapseToReference;\n    let collapseToManifest;\n    let collapseToPattern;\n    for (const pattern of patterns) {\n      const _manifest = this.patterns[pattern];\n      if (_manifest.version === version) {\n        collapseToReference = _manifest._reference;\n        collapseToManifest = _manifest;\n        collapseToPattern = pattern;\n        break;\n      }\n    }\n    invariant(collapseToReference && collapseToManifest && collapseToPattern, `Couldn't find package manifest for ${human}`);\n\n    for (const pattern of patterns) {\n      // don't touch the pattern we're collapsing to\n      if (pattern === collapseToPattern) {\n        continue;\n      }\n\n      // remove this pattern\n      const ref = this.getStrictResolvedPattern(pattern)._reference;\n      invariant(ref, 'expected package reference');\n      const refPatterns = ref.patterns.slice();\n      ref.prune();\n\n      // add pattern to the manifest we're collapsing to\n      for (const pattern of refPatterns) {\n        collapseToReference.addPattern(pattern, collapseToManifest);\n      }\n    }\n\n    return collapseToPattern;\n  }\n\n  /**\n   * TODO description\n   */\n\n  addPattern(pattern, info) {\n    this.patterns[pattern] = info;\n\n    const byName = this.patternsByPackage[info.name] = this.patternsByPackage[info.name] || [];\n    byName.push(pattern);\n  }\n\n  /**\n   * TODO description\n   */\n\n  removePattern(pattern) {\n    const pkg = this.patterns[pattern];\n    if (!pkg) {\n      return;\n    }\n\n    const byName = this.patternsByPackage[pkg.name];\n    if (!byName) {\n      return;\n    }\n\n    byName.splice(byName.indexOf(pattern), 1);\n    delete this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getResolvedPattern(pattern) {\n    return this.patterns[pattern];\n  }\n\n  /**\n   * TODO description\n   */\n\n  getStrictResolvedPattern(pattern) {\n    const manifest = this.getResolvedPattern(pattern);\n    invariant(manifest, 'expected manifest');\n    return manifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  getExactVersionMatch(name, version) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    for (const pattern of patterns) {\n      const info = this.getStrictResolvedPattern(pattern);\n      if (info.version === version) {\n        return info;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the manifest of the highest known version that satisfies a package range\n   */\n\n  getHighestRangeVersionMatch(name, range) {\n    const patterns = this.patternsByPackage[name];\n    if (!patterns) {\n      return null;\n    }\n\n    const versionNumbers = [];\n    const resolvedPatterns = patterns.map(pattern => {\n      const info = this.getStrictResolvedPattern(pattern);\n      versionNumbers.push(info.version);\n\n      return info;\n    });\n\n    const maxValidRange = semver.maxSatisfying(versionNumbers, range);\n    if (!maxValidRange) {\n      return null;\n    }\n\n    const indexOfmaxValidRange = versionNumbers.indexOf(maxValidRange);\n    const maxValidRangeManifest = resolvedPatterns[indexOfmaxValidRange];\n\n    return maxValidRangeManifest;\n  }\n\n  /**\n   * TODO description\n   */\n\n  find(req) {\n    var _this = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      const fetchKey = `${req.registry}:${req.pattern}`;\n      if (_this.fetchingPatterns[fetchKey]) {\n        return;\n      } else {\n        _this.fetchingPatterns[fetchKey] = true;\n      }\n\n      if (_this.activity) {\n        _this.activity.tick(req.pattern);\n      }\n\n      if (!_this.lockfile.getLocked(req.pattern, true)) {\n        _this.newPatterns.push(req.pattern);\n      }\n\n      const request = new (_packageRequest || _load_packageRequest()).default(req, _this);\n      yield request.find();\n    })();\n  }\n\n  /**\n   * TODO description\n   */\n\n  init(deps, isFlat) {\n    var _this2 = this;\n\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      _this2.flat = isFlat;\n\n      //\n      const activity = _this2.activity = _this2.reporter.activity();\n\n      //\n      _this2.seedPatterns = deps.map(function (dep) {\n        return dep.pattern;\n      });\n\n      //\n      yield Promise.all(deps.map(function (req) {\n        return _this2.find(req);\n      }));\n\n      activity.end();\n      _this2.activity = null;\n    })();\n  }\n}\nexports.default = PackageResolver;","/home/travis/build/npmtest/node-npmtest-yarn/node_modules/yarn/lib/types.js":"'use strict';"}